<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="postlfs-config-profile" xreflabel="Os Arquivos de Iniciação do Shell Bash">
  <?dbhtml filename="profile-pt_br.html"?>

  <sect1info>
    <date>$Date$</date>
  </sect1info>

  <title>Os Arquivos de Iniciação do Shell Bash</title>

  <para>

    O aplicativo de shell <filename>/bin/bash</filename> (doravante 
    referenciado apenas como "o shell") usa uma coleção de arquivos de 
    iniciação para auxiliar a criar um ambiente.  Cada arquivo tem um 
    uso específico e possivelmente afete os ambientes de login e os 
    interativos diferentemente.  Os arquivos no diretório
<filename class="directory">/etc</filename> geralmente fornecem configurações 
    globais.  Se um arquivo equivalente existir no seu diretório home, 
    [então] ele possivelmente substitua as configurações globais.

  </para>

  <para>

    Um shell de login interativo é iniciado depois de um login exitoso, 
    usando o <filename>/bin/login</filename>, pela leitura do arquivo 
    <filename>/etc/passwd</filename>.  Essa invocação do shell 
    normalmente lê <filename>/etc/profile</filename> e o equivalente 
    privado dele <filename>~/.bash_profile</filename> (ou o 
    <filename>~/.profile</filename>, se chamado como 
    <command>/bin/sh</command>) assim que iniciar.

  </para>

  <para>

    Um shell de não login interativo normalmente é iniciado em linha de 
    comando usando um aplicativo de shell (por exemplo, 
    <prompt>[prompt]$</prompt><command>/bin/bash</command>) ou pelo 
    comando <command>/bin/su</command>.  Um shell de não login 
    interativo também é iniciado com um aplicativo de terminal, tal como 
    o <command>xterm</command> ou o <command>konsole</command>, a partir 
    de dentro de um ambiente gráfico.  Esse tipo de invocação do shell 
    normalmente copia o ambiente do(a) ascendente e, então, lê o arquivo 
    <filename>~/.bashrc</filename> do(a) usuário(a) para instruções 
    adicionais de configuração de iniciação.

  </para>

  <para>

    Um shell não interativo usualmente está presente quando um script de 
    shell está executando.  Ele é não interativo, pois está processando 
    um script e não aguardando por entradas do(a) usuário(a) entre os 
    comandos.  Para essas invocações de shell, somente o ambiente 
    herdado a partir do shell ascendente é usado.

  </para>

  <para>

    O arquivo <filename>~/.bash_logout</filename> não é usado para uma 
    invocação do shell.  Ele é lido e executado quando um(a) usuário(a) 
    sai de um shell de login interativo.

  </para>

  <para>

    Muitas distribuições usam o <filename>/etc/bashrc</filename> para a 
    abrangente inicialização de sistema dos shells de não login.  Esse 
    arquivo usualmente é chamado a partir do arquivo 
    <filename>~/.bashrc</filename> do(a) usuário(a) e não é construído 
    diretamente no próprio <command>bash</command>.  Essa convenção é 
    seguida nesta seção.

  </para>

  <para>

    Para mais informação, veja-se <command>info bash</command> --
<emphasis role="strong">Nós: Arquivos de Iniciação do Bash e Shells Interativos</emphasis>.

  </para>

  <note>

    <para>

      A maioria das instruções abaixo é usada para criar arquivos 
      localizados na estrutura de diretório
<filename class='directory'>/etc</filename>, o que exige que você
      execute os comandos como o(a) usuário(a)
<systemitem class='username'>root</systemitem>.  Se você escolher criar os 
      arquivos nos diretórios home dos(as) usuários(as) em vez disso, 
      [então] você deveria executar os comandos como um(a) usuário(a) 
      desprivilegiado(a).

    </para>

  </note>

  <para condition="html" role="usernotes">Observações de Usuário(a):
  <ulink url="&blfs-wiki;/bash-shell-startup-files"/></para>

  <sect2 id="etc-profile-profile">
    <title>/etc/profile</title>

    <indexterm zone="postlfs-config-profile etc-profile-profile">
      <primary sortas="e-etc-profile">/etc/profile</primary>
    </indexterm>

    <para>

      Aqui está um <filename>/etc/profile</filename> de base.  Esse 
      arquivo inicia configurando algumas funções auxiliares e alguns 
      parâmetros básicos.  Ele especifica alguns parâmetros do histórico 
      do <command>bash</command> e, para propósitos de segurança, 
      desabilita a manutenção de um arquivo permanente do histórico para 
      o(a) usuário(a) <systemitem class="username">root</systemitem>.  
      Também configura um prompt padrão do(a) usuário(a).  Então chama 
      scripts pequenos e de propósito único no diretório
<filename class='directory'>/etc/profile.d</filename> para fornecer a maior 
      parte da inicialização.

    </para>

    <para>

      Para mais informação acerca das sequências de escape que você pode 
      usar para o seu prompt (isto é, a variável de ambiente 
      <envar>PS1</envar>), veja-se <command>info bash</command> -- 
      <emphasis role="strong">Nó: Imprimindo um Prompt</emphasis>.

    </para>

<screen role="root"><?dbfo keep-together="auto"?><userinput>cat &gt; /etc/profile &lt;&lt; "EOF"
<literal># Begin /etc/profile
# Written for Beyond Linux From Scratch
# by James Robertson &lt;jameswrobertson@earthlink.net&gt;
# modifications by Dagmar d'Surreal &lt;rivyqntzne@pbzpnfg.arg&gt;

# System wide environment variables and startup programs.

# System wide aliases and functions should go in /etc/bashrc.  Personal
# environment variables and startup programs should go into
# ~/.bash_profile.  Personal aliases and functions should go into
# ~/.bashrc.

# Functions to help us manage paths.  Second argument is the name of the
# path variable to be modified (default: PATH)
pathremove () {
        local IFS=':'
        local NEWPATH
        local DIR
        local PATHVARIABLE=${2:-PATH}
        for DIR in ${!PATHVARIABLE} ; do
                if [ "$DIR" != "$1" ] ; then
                  NEWPATH=${NEWPATH:+$NEWPATH:}$DIR
                fi
        done
        export $PATHVARIABLE="$NEWPATH"
}

pathprepend () {
        pathremove $1 $2
        local PATHVARIABLE=${2:-PATH}
        export $PATHVARIABLE="$1${!PATHVARIABLE:+:${!PATHVARIABLE}}"
}

pathappend () {
        pathremove $1 $2
        local PATHVARIABLE=${2:-PATH}
        export $PATHVARIABLE="${!PATHVARIABLE:+${!PATHVARIABLE}:}$1"
}

export -f pathremove pathprepend pathappend

# Set the initial path
export PATH=/usr/bin

# Attempt to provide backward compatibility with LFS earlier than 11
if [ ! -L /bin ]; then
        pathappend /bin
fi

if [ $EUID -eq 0 ] ; then
        pathappend /usr/sbin
        if [ ! -L /sbin ]; then
                pathappend /sbin
        fi
        unset HISTFILE
fi

# Setup some environment variables.
export HISTSIZE=1000
export HISTIGNORE="&amp;:[bf]g:exit"

# Set some defaults for graphical systems
export XDG_DATA_DIRS=${XDG_DATA_DIRS:-/usr/share/}
export XDG_CONFIG_DIRS=${XDG_CONFIG_DIRS:-/etc/xdg/}
export XDG_RUNTIME_DIR=${XDG_RUNTIME_DIR:-/tmp/xdg-$USER}

# Setup a red prompt for root and a green one for users.
NORMAL="\[\e[0m\]"
RED="\[\e[1;31m\]"
GREEN="\[\e[1;32m\]"
if [[ $EUID == 0 ]] ; then
  PS1="$RED\u [ $NORMAL\w$RED ]# $NORMAL"
else
  PS1="$GREEN\u [ $NORMAL\w$GREEN ]\$ $NORMAL"
fi

for script in /etc/profile.d/*.sh ; do
        if [ -r $script ] ; then
                . $script
        fi
done

unset script RED GREEN NORMAL

# End /etc/profile</literal>
EOF</userinput></screen>

    <sect3 id="etc-profile.d">
      <title>O Diretório /etc/profile.d</title>

      <indexterm zone="postlfs-config-profile etc-profile.d">
        <primary sortas="e-etc-profile.d">/etc/profile.d</primary>
      </indexterm>

      <para>

        Agora crie o diretório
<filename class='directory'>/etc/profile.d</filename>, onde os scripts 
        individuais da inicialização são colocados:

      </para>

<screen role="root"><userinput>install --directory --mode=0755 --owner=root --group=root /etc/profile.d</userinput></screen>

    </sect3>

    <sect3 id="etc-profile.d-bash-completion.sh">
      <title>/etc/profile.d/bash_completion.sh</title>

      <indexterm zone="postlfs-config-profile etc-profile.d-bash-completion.sh">
        <primary sortas="e-etc-profile.d-bash-completion.sh">/etc/profile.d/bash_completion.sh</primary>
      </indexterm>

      <note>

        <para>

          Usar o script de completação do bash abaixo é controverso.  
          Nem todos(as) os(as) usuários(as) gostam dele.  Ele adiciona 
          muitas (usualmente mais que mil (1.000)) linhas ao ambiente do 
          bash e torna difícil usar o comando 'set' para examinar 
          variáveis simples de ambiente.  Omitir-se este script não 
          interfere na habilidade do bash de usar a tecla tab para a 
          completação de nome de arquivo.

        </para>

      </note>

      <para>

        Este script importa scripts de completação do bash, instalados 
        por muitos outros pacotes do BLFS, para permitir a completação 
        de linha de comando TAB.

      </para>

<screen role="root"><userinput>cat &gt; /etc/profile.d/bash_completion.sh &lt;&lt; "EOF"
<literal># Begin /etc/profile.d/bash_completion.sh
# Import bash completion scripts

# If the bash-completion package is installed, use its configuration instead
if [ -f /usr/share/bash-completion/bash_completion ]; then

  # Check for interactive bash and that we haven't already been sourced.
  if [ -n "${BASH_VERSION-}" -a -n "${PS1-}" -a -z "${BASH_COMPLETION_VERSINFO-}" ]; then

    # Check for recent enough version of bash.
    if [ ${BASH_VERSINFO[0]} -gt 4 ] || \
       [ ${BASH_VERSINFO[0]} -eq 4 -a ${BASH_VERSINFO[1]} -ge 1 ]; then
       [ -r "${XDG_CONFIG_HOME:-$HOME/.config}/bash_completion" ] &amp;&amp; \
            . "${XDG_CONFIG_HOME:-$HOME/.config}/bash_completion"
       if shopt -q progcomp &amp;&amp; [ -r /usr/share/bash-completion/bash_completion ]; then
          # Source completion code.
          . /usr/share/bash-completion/bash_completion
       fi
    fi
  fi

else

  # bash-completions are not installed, use only bash completion directory
  if shopt -q progcomp; then
    for script in /etc/bash_completion.d/* ; do
      if [ -r $script ] ; then
        . $script
      fi
    done
  fi
fi

# End /etc/profile.d/bash_completion.sh</literal>
EOF</userinput></screen>

      <para>

        Tenha certeza de que o diretório existe:

      </para>

<screen role="root"><userinput>install --directory --mode=0755 --owner=root --group=root /etc/bash_completion.d</userinput></screen>

      <para>

        Para uma instalação mais completa, veja-se
<ulink url="&blfs-wiki;/bash-shell-startup-files#bash-completions"/>.

      </para>

    </sect3>

    <sect3 id="etc-profile.d-dircolors.sh">
      <title>/etc/profile.d/dircolors.sh</title>

      <indexterm zone="postlfs-config-profile etc-profile.d-dircolors.sh">
        <primary sortas="e-etc-profile.d-dircolors.sh">/etc/profile.d/dircolors.sh</primary>
      </indexterm>

      <para>

        Este script usa os arquivos <filename>~/.dircolors</filename> e 
        <filename>/etc/dircolors</filename> para controlar as cores dos 
        nomes de arquivos em uma listagem de diretório.  Eles controlam 
        a saída gerada colorida de coisas como
<command>ls --color</command>.  A explicação do como inicializar esses 
        arquivos está ao final desta seção.

      </para>

<screen role="root"><userinput>cat &gt; /etc/profile.d/dircolors.sh &lt;&lt; "EOF"
<literal># Setup for /bin/ls and /bin/grep to support color, the alias is in /etc/bashrc.
if [ -f "/etc/dircolors" ] ; then
        eval $(dircolors -b /etc/dircolors)
fi

if [ -f "$HOME/.dircolors" ] ; then
        eval $(dircolors -b $HOME/.dircolors)
fi

alias ls='ls --color=auto'
alias grep='grep --color=auto'</literal>
EOF</userinput></screen>

    </sect3>

    <sect3 id="extrapaths.sh">
      <title>/etc/profile.d/extrapaths.sh</title>

      <indexterm zone="postlfs-config-profile extrapaths.sh">
        <primary sortas="e-etc-profile.d-extrapaths.sh">/etc/profile.d/extrapaths.sh</primary>
      </indexterm>

      <para>

        Este script adiciona alguns caminhos úteis à <envar>PATH</envar> 
        e pode ser usado para personalizar outras variáveis de ambiente 
        relacionadas a PATH (por exemplo, LD_LIBRARY_PATH, etc) que 
        possivelmente sejam necessárias para todos(as) os(as) 
        usuários(as).

      </para>

<screen role="root"><userinput>cat &gt; /etc/profile.d/extrapaths.sh &lt;&lt; "EOF"
<literal>if [ -d /usr/local/lib/pkgconfig ] ; then
        pathappend /usr/local/lib/pkgconfig PKG_CONFIG_PATH
fi
if [ -d /usr/local/bin ]; then
        pathprepend /usr/local/bin
fi
if [ -d /usr/local/sbin -a $EUID -eq 0 ]; then
        pathprepend /usr/local/sbin
fi

if [ -d /usr/local/share ]; then
        pathprepend /usr/local/share XDG_DATA_DIRS
fi

# Set some defaults before other applications add to these paths.
pathappend /usr/share/man  MANPATH
pathappend /usr/share/info INFOPATH</literal>
EOF</userinput></screen>

    </sect3>

    <sect3 id="readline.sh">
      <title>/etc/profile.d/readline.sh</title>

      <indexterm zone="postlfs-config-profile readline.sh">
        <primary sortas="e-etc-profile.d-readline.sh">/etc/profile.d/readline.sh</primary>
      </indexterm>

      <para>

        Este script configura o arquivo padrão de configuração 
        <filename>inputrc</filename>.  Se o(a) usuário(a) não tiver 
        configurações individuais, [então] usa o arquivo global.

      </para>

<screen role="root"><userinput>cat &gt; /etc/profile.d/readline.sh &lt;&lt; "EOF"
<literal># Setup the INPUTRC environment variable.
if [ -z "$INPUTRC" -a ! -f "$HOME/.inputrc" ] ; then
        INPUTRC=/etc/inputrc
fi
export INPUTRC</literal>
EOF</userinput></screen>

    </sect3>

    <sect3 id="umask.sh">
      <title>/etc/profile.d/umask.sh</title>

      <indexterm zone="postlfs-config-profile umask.sh">
        <primary sortas="e-etc-profile.d-umask.sh">/etc/profile.d/umask.sh</primary>
      </indexterm>

      <para>

        Configurar-se o valor do <command>umask</command> é importante 
        para a segurança.  Aqui as permissões padrão de escrita do grupo 
        são desligadas para os(as) usuários(as) de sistema e quando o 
        nome do(a) usuário(a) e o nome do grupo não forem os mesmos.

      </para>

<screen role="root"><userinput>cat &gt; /etc/profile.d/umask.sh &lt;&lt; "EOF"
<literal># By default, the umask should be set.
if [ "$(id -gn)" = "$(id -un)" -a $EUID -gt 99 ] ; then
  umask 002
else
  umask 022
fi</literal>
EOF</userinput></screen>

    </sect3>

<!-- Isto é manuseado na seção Xorg do livro
    <sect3 id="X.sh">
      <title>/etc/profile.d/X.sh</title>

      <indexterm zone="postlfs-config-profile X.sh">
        <primary sortas="e-etc-profile.d-X.sh">/etc/profile.d/X.sh</primary>
      </indexterm>

      <para>

        Se o <application>X</application> estiver instalado, {então] as 
        variáveis <envar>PATH</envar> e <envar>PKG_CONFIG_PATH</envar> 
        também são atualizadas.

      </para>

<screen role="root"><userinput>cat &gt; /etc/profile.d/X.sh &lt;&lt; "EOF"
<literal>if [ -x /usr/X11R6/bin/X ]; then
        pathappend /usr/X11R6/bin
fi
if [ -d /usr/X11R6/lib/pkgconfig ] ; then
        pathappend /usr/X11R6/lib/pkgconfig PKG_CONFIG_PATH
fi</literal>
EOF</userinput></screen>

    </sect3>
-->
    <sect3 id="i18n.sh">
    <!-- Isto é manuseado abrangente ao sistema no systemd, porém LANG 
    não exportada para o ambiente; dessa maneira, o retorno dela ... 
    precisa adicionar texto adicional para somente o systemd -->
      <title>/etc/profile.d/i18n.sh</title>

    <indexterm zone="postlfs-config-profile i18n.sh">
      <primary sortas="e-etc-profile.d-i18n.sh">/etc/profile.d/i18n.sh</primary>
    </indexterm>

      <para>

        Este script configura uma variável de ambiente necessária para o 
        suporte ao idioma nativo.  Uma discussão completa acerca de se 
        determinar esta variável pode ser encontrada na página
<ulink url="&lfs-root;/chapter09/profile.html">Arquivos de Inicialização do Shell Bash do LFS</ulink>.

      </para>

<screen role="root" revision="sysv"><userinput>cat &gt; /etc/profile.d/i18n.sh &lt;&lt; "EOF"
<literal># Set up i18n variables
export LANG=<replaceable>&lt;ll&gt;</replaceable>_<replaceable>&lt;CC&gt;</replaceable>.<replaceable>&lt;charmap&gt;</replaceable><replaceable>&lt;@modifiers&gt;</replaceable></literal>
EOF</userinput></screen>

<screen role="root" revision="systemd"><userinput>cat &gt; /etc/profile.d/i18n.sh &lt;&lt; "EOF"
<literal># Set up i18n variables
. /etc/locale.conf
export LANG</literal>
EOF</userinput></screen>

    </sect3>

    <sect3>
      <title>Other Initialization Values</title>

      <para>
        Other initialization can easily be added to the
        <filename>profile</filename> by adding additional scripts to the
        <filename class='directory'>/etc/profile.d</filename> directory.
      </para>

    </sect3>

  </sect2>

  <sect2 id="etc-bashrc-profile">
    <title>/etc/bashrc</title>

    <indexterm zone="postlfs-config-profile etc-bashrc-profile">
      <primary sortas="e-etc-bashrc">/etc/bashrc</primary>
    </indexterm>

    <para>
      Here is a base <filename>/etc/bashrc</filename>.  Comments in the
      file should explain everything you need.
    </para>

<screen role="root"><userinput>cat &gt; /etc/bashrc &lt;&lt; "EOF"
<literal># Begin /etc/bashrc
# Written for Beyond Linux From Scratch
# by James Robertson &lt;jameswrobertson@earthlink.net&gt;
# updated by Bruce Dubbs &lt;bdubbs@&lfs-domainname;&gt;

# System wide aliases and functions.

# System wide environment variables and startup programs should go into
# /etc/profile.  Personal environment variables and startup programs
# should go into ~/.bash_profile.  Personal aliases and functions should
# go into ~/.bashrc

# Provides colored /bin/ls and /bin/grep commands.  Used in conjunction
# with code in /etc/profile.

alias ls='ls --color=auto'
alias grep='grep --color=auto'

# Provides prompt for non-login shells, specifically shells started
# in the X environment. [Review the LFS archive thread titled
# PS1 Environment Variable for a great case study behind this script
# addendum.]

NORMAL="\[\e[0m\]"
RED="\[\e[1;31m\]"
GREEN="\[\e[1;32m\]"
if [[ $EUID == 0 ]] ; then
  PS1="$RED\u [ $NORMAL\w$RED ]# $NORMAL"
else
  PS1="$GREEN\u [ $NORMAL\w$GREEN ]\$ $NORMAL"
fi

unset RED GREEN NORMAL

# End /etc/bashrc</literal>
EOF</userinput></screen>

  </sect2>

  <sect2 id="bash_profile-profile">
    <title>~/.bash_profile</title>

    <indexterm zone="postlfs-config-profile bash_profile-profile">
      <primary sortas="e-AA.bash_profile">~/.bash_profile</primary>
    </indexterm>

    <para>
      Here is a base <filename>~/.bash_profile</filename>.  If you want each
        new user to have this file automatically, just change the output of
      the command to <filename>/etc/skel/.bash_profile</filename> and check the
      permissions after the command is run. You can then copy <filename>
      /etc/skel/.bash_profile</filename> to the home directories of already
      existing users, including <systemitem class="username">root</systemitem>,
      and set the owner and group appropriately.
    </para>

<screen><userinput>cat &gt; ~/.bash_profile &lt;&lt; "EOF"
<literal># Begin ~/.bash_profile
# Written for Beyond Linux From Scratch
# by James Robertson &lt;jameswrobertson@earthlink.net&gt;
# updated by Bruce Dubbs &lt;bdubbs@&lfs-domainname;&gt;

# Personal environment variables and startup programs.

# Personal aliases and functions should go in ~/.bashrc.  System wide
# environment variables and startup programs are in /etc/profile.
# System wide aliases and functions are in /etc/bashrc.

if [ -f "$HOME/.bashrc" ] ; then
  source $HOME/.bashrc
fi

if [ -d "$HOME/bin" ] ; then
  pathprepend $HOME/bin
fi

# Having . in the PATH is dangerous
#if [ $EUID -gt 99 ]; then
#  pathappend .
#fi

# End ~/.bash_profile</literal>
EOF</userinput></screen>

  </sect2>

  <sect2 id="dot_profile-profile">
    <title>~/.profile</title>

    <indexterm zone="postlfs-config-profile dot_profile-profile">
      <primary sortas="e-AA.dot_profile">~/.profile</primary>
    </indexterm>

    <para>
      Here is a base <filename>~/.profile</filename>. The comments and
      instructions for using <filename class="directory">/etc/skel</filename>
      for <filename>.bash_profile</filename> above also apply here. Only the
      target file names are different.
    </para>

<screen><userinput>cat &gt; ~/.profile &lt;&lt; "EOF"
<literal># Begin ~/.profile
# Personal environment variables and startup programs.

if [ -d "$HOME/bin" ] ; then
  pathprepend $HOME/bin
fi

# Set up user specific i18n variables
#export LANG=<replaceable>&lt;ll&gt;</replaceable>_<replaceable>&lt;CC&gt;</replaceable>.<replaceable>&lt;charmap&gt;</replaceable><replaceable>&lt;@modifiers&gt;</replaceable>

# End ~/.profile</literal>
EOF</userinput></screen>

  </sect2>

  <sect2 id="bashrc-profile">
    <title>~/.bashrc</title>

    <indexterm zone="postlfs-config-profile bashrc-profile">
      <primary sortas="e-AA.bashrc">~/.bashrc</primary>
    </indexterm>

    <para>
      Here is a base <filename>~/.bashrc</filename>.
    </para>

<screen><userinput>cat &gt; ~/.bashrc &lt;&lt; "EOF"
<literal># Begin ~/.bashrc
# Written for Beyond Linux From Scratch
# by James Robertson &lt;jameswrobertson@earthlink.net&gt;

# Personal aliases and functions.

# Personal environment variables and startup programs should go in
# ~/.bash_profile.  System wide environment variables and startup
# programs are in /etc/profile.  System wide aliases and functions are
# in /etc/bashrc.

if [ -f "/etc/bashrc" ] ; then
  source /etc/bashrc
fi

# Set up user specific i18n variables
#export LANG=<replaceable>&lt;ll&gt;</replaceable>_<replaceable>&lt;CC&gt;</replaceable>.<replaceable>&lt;charmap&gt;</replaceable><replaceable>&lt;@modifiers&gt;</replaceable>

# End ~/.bashrc</literal>
EOF</userinput></screen>

  </sect2>


  <sect2 id="bash_logout-profile">
    <title>~/.bash_logout</title>

    <indexterm zone="postlfs-config-profile bash_logout-profile">
      <primary sortas="e-AA.bash_logout">~/.bash_logout</primary>
    </indexterm>

    <para>
      This is an empty <filename>~/.bash_logout</filename> that can be used as
      a template.  You will notice that the base <filename>~/.bash_logout
      </filename> does not include a <userinput>clear</userinput> command.
      This is because the clear is handled in the
      <filename>/etc/issue</filename> file.
    </para>

<screen><userinput>cat &gt; ~/.bash_logout &lt;&lt; "EOF"
<literal># Begin ~/.bash_logout
# Written for Beyond Linux From Scratch
# by James Robertson &lt;jameswrobertson@earthlink.net&gt;

# Personal items to perform on logout.

# End ~/.bash_logout</literal>
EOF</userinput></screen>

  </sect2>


  <sect2 id="etc-dircolors-profile">
    <title>/etc/dircolors</title>

    <indexterm zone="postlfs-config-profile etc-dircolors-profile">
      <primary sortas="e-etc-dircolors">/etc/dircolors</primary>
    </indexterm>

    <indexterm zone="postlfs-config-profile etc-dircolors-profile">
      <primary sortas="e-AA.dircolors">~/.dircolors</primary>
    </indexterm>

    <para>
       If you want to use the <filename>dircolors</filename> capability, then
       run the following command. The <filename class="directory">/etc/skel
       </filename> setup steps shown above also can be used here to provide
       a <filename>~/.dircolors</filename> file when a new user is set up.
       As before, just change the output file name on the following command
       and assure the permissions, owner, and group are correct on the files
       created and/or copied.
    </para>

<screen role="root"><userinput>dircolors -p > /etc/dircolors</userinput></screen>

    <para>
      If you wish to customize the colors used for different file types, you
      can edit the <filename>/etc/dircolors</filename> file. The instructions
      for setting the colors are embedded in the file.
    </para>


    <para>
      Finally, Ian Macdonald has written an excellent collection of tips and
      tricks to enhance your shell environment.  You can read it online at
      <ulink url="http://www.caliban.org/bash/index.shtml"/>.
    </para>

  </sect2>

</sect1>
