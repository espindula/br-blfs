<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="postlfs-firmware" xreflabel="Acerca de Firmware">
  <?dbhtml filename="firmware.html"?>


  <title>Acerca de Firmware</title>

  <indexterm zone="postlfs-firmware">
    <primary sortas="e-lib-firmware">/lib/firmware</primary>
  </indexterm>

  <para>
    Em alguns PCs recentes, pode ser necessário, ou desejável, carregar firmware
para fazer com que trabalhem no melhor deles. Existe um diretório, <filename
class="directory">/lib/firmware</filename>, onde o núcleo ou os
controladores de núcleo procuram por imagens de firmware.
  </para>

  <para>
    Currently, most firmware can be found at a <userinput>git</userinput>
repository: <ulink url=
"https://git.kernel.org/cgit/linux/kernel/git/firmware/linux-firmware.git/tree/"/>.
For convenience, the LFS Project has created a mirror, updated daily, where
these firmware files can be accessed via <userinput>wget</userinput> or a
web browser at <ulink url="&sources-anduin-http;/linux-firmware/"/>.
  </para>

  <para>
    Para obter o firmware, ou aponte um navegador para um dos repositórios acima
e, então, transfira o(s) item(s) que você precisar; ou instale o <xref
linkend="git"/> e clone aquele repositório.
  </para>

  <para>
    Para algum outro firmware, particularmente para microcódigo da Intel e
certos dispositivos wifi, o firmware necessário não está disponível no
repositório acima. Algo disso será endereçado abaixo, porém uma busca da
Internet pelo firmware necessário de vez em quando é necessária.
  </para>

  <para>
    Os arquivos de firmware convencionalmente são referenciados como blobs, pois
você não consegue determinar o que eles farão. Observe que o firmware é
distribuído sob diferentes licenças que não permitem desmontagem ou
engenharia reversa.
  </para>

  <para>
    Firmware para PCs caem em quatro categorias:
  </para>

  <itemizedlist spacing="compact">
    <listitem>
      <para>
        Atualizações para a CPU contornar erros, geralmente referenciadas como
microcódigo.
      </para>
    </listitem>
    <listitem>
      <para>
        Firmware para controladores de vídeo. Em máquinas x86, isso é exigido para
dispositivos ATI (chips Radeon e AMDGPU); e possivelmente seja útil para
GPUs Intel (Skylake e posteriores) e Nvidia (Kepler e posteriores).
      </para>

      <para>
        ATI Radeon and AMDGPU devices all require firmware to be able to use KMS
(kernel modesetting - the preferred option) as well as for Xorg. For old
radeon chips (before the R600), the firmware is still in the kernel source.
      </para>

      <para>
        GPUs integradas Intel a partir do Skylake em diante conseguem usar firmware
para GuC (o microcontrolador Graphics) e, também, para o HuC
(microcontrolador HEVC/H265, que descarrega para a GPU); e o DMC (Display
Microcontroller) para fornecer estados adicionais de baixa eletricidade. O
GuC e o HuC tiveram um histórico duvidoso no núcleo e o firmware atualizado
possivelmente esteja desabilitado por padrão, dependendo da sua versão de
núcleo. Maiores detalhes podem ser encontrados em <ulink
url="https://01.org/linuxgraphics/downloads/firmware/">01.org</ulink>; e
<ulink url="https://wiki.archlinux.org/index.php/intel_graphics">Arch
linux</ulink>.
      </para>

      <para>
        Nvidia GPUs from Kepler onwards require signed firmware, otherwise the
nouveau driver is unable to provide hardware acceleration. Nvidia has now
released firmware up to Ampere (GeForce30 series) to linux-firmware.  Note
that faster clocks than the default are not enabled by the released
firmware.
      </para>
    </listitem>
    <listitem>
      <para>
        Firmware updates for wired network ports. Mostly they work even without the
updates, but probably they will work better with the updated firmware. For
some modern laptops, firmware for both wired ethernet (e.g. rtl_nic) and
also for bluetooth devices (e.g. qca)  is <emphasis>required</emphasis>
before the wired network can be used.
      </para>
    </listitem>
    <listitem>
      <para>
        Firmware for other devices, such as wifi. These devices are not required for
the PC to boot, but need the firmware before these devices can be used.
      </para>
    </listitem>
  </itemizedlist>

  <note>
    <para>
      Apesar de não necessárias para carregar um blob de firmware, as seguintes
ferramentas possivelmente sejam úteis para determinar, obter ou preparar o
firmware necessário para a finalidade de carregá-lo no sistema: <xref
linkend="cpio"/>; <xref linkend="git"/>; <xref linkend="pciutils"/>; e <xref
linkend="wget"/>
    </para>
  </note>

  <para condition="html" role="usernotes">Observações de Usuário(a): <ulink url="&blfs-wiki;/aboutfirmware"/></para>

  <sect2 id="cpu-microcode">
    <title>Atualizações de microcódigo para CPUs</title>

    <para>
      Em geral, microcódigo pode ser carregado pelo BIOS ou pela UEFI e poderia
ser atualizado atualizando-se para uma versão mais recente daqueles. No
Linux, você também pode carregar o microcódigo a partir do núcleo se estiver
usando um processador AMD família 10h ou posterior (introduzido
primeiramente no final de 2007); ou um processador Intel a partir de 1998 e
posterior (Pentium4, Core, etc), se microcódigo atualizado tiver sido
lançado. Essas atualizações duram somente até que a máquina seja desligada,
de forma que elas precisam ser aplicadas a cada inicialização.
    </para>

    <para>
      Intel provide updates of their microcode for Skylake and later processors as
new vulnerabilities come to light, and have in the past provided updates for
processors from SandyBridge onwards, although those are no-longer supported
for new fixes. New versions of AMD firmware are rare and usually only apply
to a few models, although motherboard manufacturers get AGESA (AMD Generic
Encapsulated Software Architecture) updates to change BIOS values, e.g. to
support more memory variants, new vulnerability fixes or newer CPUs.
    </para>

    <para>
      There were two ways of loading the microcode, described as 'early' and
'late'. Early loading happens before userspace has been started, late
loading happens after userspace has started. However, late loading is known
to be problematic and not supported anymore (see the kernel commit <ulink
url="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d23d33e">
x86/microcode: Taint and warn on late loading</ulink>.)  Indeed, early
loading is needed to work around one particular erratum in early Intel
Haswell processors which had TSX enabled.  (See <ulink url=
"https://www.anandtech.com/show/8376/intel-disables-tsx-instructions-erratum-found-in-haswell-haswelleep-broadwelly/">
Intel Disables TSX Instructions: Erratum Found in Haswell, Haswell-E/EP,
Broadwell-Y</ulink>.)  Without this update glibc can do the wrong thing in
uncommon situations.
    </para>

    <para>
      In previous versions of this book, late loading of microcode to see if it
gets applied was recommended, followed by using an initrd to force early
loading. But now that the contents of the Intel microcode tarball is
documented, and AMD microcode can be read by a Python script to determine
which machines it covers, there is no real reason to use late loading.
    </para>

    <para>
      It might be still possible to manually force late loading of microcode.  But
it may cause kernel malfunction and you should take the risk yourself.  You
will need to reconfigure your kernel for either method. The instructions
here will show you how to create an initrd for early loading. It is also
possible to build the same microcode bin file into the kernel, which allows
early loading but requires the kernel to be recompiled to update the
microcode.
    </para>

    <para>
      To confirm what processor(s) you have (if more than one, they will be
identical) look in /proc/cpuinfo. Determine the decimal values of the cpu
family, model and stepping by running the following command (it will also
report the current microcode version):
    </para>

<screen><userinput>head -n7 /proc/cpuinfo</userinput></screen>

    <para>
      Convert the cpu family, model and stepping to pairs of hexadecimal digits,
and remember the value of the <quote>microcode</quote> field.  You can now
check if there is any microcode available.
    </para>

    <para>
      If you are creating an initrd to update firmware for different machines, as
a distro would do, go down to 'Early loading of microcode' and cat all the
Intel blobs to GenuineIntel.bin or cat all the AMD blobs to
AuthenticAMD.bin. This creates a larger initrd - for all Intel machines in
the 20200609 update the size was 3.0 MB compared to typically 24 KB for one
machine.
    </para>

    <sect3 id="intel-microcode">
      <title>Microcódigo Intel para a CPU</title>

      <para>
        <!-- at one time, some skylakes had problems with a certain revision
        secure version of the microcode, for those machines which can boot it, -->
<!-- If you have a Skylake machine, please read the
        Caution in the 'Early loading of microcode' section below.-->
The first step is to get the most recent version of the Intel microcode.
This must be done by navigating to <ulink url=
'https://github.com/intel/Intel-Linux-Processor-Microcode-Data-Files/releases/'/>
and downloading the latest file there.  As of this writing the most secure
version of the microcode is microcode-20230214.  Extract this file in the
normal way, the microcode is in the <filename>intel-ucode </filename>
directory, containing various blobs with names in the form XX-YY-ZZ. There
are also various other files, and a releasenote.
      </para>

      <para>
        In the past, intel did not provide any details of which blobs had changed
versions, but now the releasenote details this.  You can compare the
microcode version in <filename>/proc/cpuinfo</filename> with the version for
your CPU model in the releasenote to know if there is an update.
      </para>

      <para>
        O firmware recente para processadores mais antigos é fornecido para lidar
com vulnerabilidades que agora tenham sido tornadas públicas e, para algumas
dessas, tais como Microarchitectural Data Sampling (MDS), você poderia
desejar aumentar a proteção desabilitando hyperthreading; ou,
alternativamente, desabilitar a mitigação padrão do núcleo, por causa do
impacto dela sobre os tempos de compilação. Por favor, leia a documentação
online em <ulink url=
'https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/index.html'/>.
      </para>

      <para>
        For an Icelake mobile (described as Intel(R) Core(TM) i7-1065G7 CPU) the
relevant values are cpu family 6, model 126, stepping 5 so in this case the
required identification is 06-7e-05. The releasenote says the latest
microcode for it is versioned 0xb8.  If the value of the
<quote>microcode</quote> field in <filename>/proc/cpuinfo</filename> is 0xb8
or greater, it indicates the microcode update is already applied by the
BIOS.  Otherwise, configure the kernel to support loading Intel microcode,
and then proceed to <xref linkend='early-microcode'/>:
      </para>

<screen><literal>General Setup ---&gt;
  [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support [CONFIG_BLK_DEV_INITRD]
Processor type and features  ---&gt;
  [*] CPU microcode loading support  [CONFIG_MICROCODE]
  [*]      Intel microcode loading support [CONFIG_MICROCODE_INTEL]</literal></screen>

    </sect3>

    <sect3 id="amd-microcode">
      <title>Microcódigo AMD para a CPU</title>

      <para>
        Begin by downloading a container of firmware for your CPU family from <ulink
url= '&sources-anduin-http;/linux-firmware/amd-ucode/'/>.  The family is
always specified in hex. Families 10h to 14h (16 to 20)  are in
microcode_amd.bin.  Families 15h, 16h, 17h (Zen, Zen+, Zen2) and 19h (Zen3)
have their own containers, but very few machines are likely to get updated
microcode. Instead, AMD provide an updated AGESA to the motherboard makers,
who may provide an updated BIOS using this.  There is a Python3 script at
<ulink url=
'https://github.com/AMDESE/amd_ucode_info/blob/master/amd_ucode_info.py'/>.
Download that script and run it against the bin file to check which
processors have updates.
      </para>

      <para>
        For the very old Athlon(tm) II X2 in these examples the values were cpu
family 16, model 5, stepping 3 giving an identification of Family=0x10
Model=0x05 Stepping=0x03.  One line of the
<command>amd_ucode_info.py</command> script output describes the microcode
version for it:
      </para>

<screen><computeroutput>Family=0x10 Model=0x05 Stepping=0x03: Patch=0x010000c8 Length=960 bytes</computeroutput></screen>

      <para>
        If the value of the <quote>microcode</quote> field in
<filename>/proc/cpuinfo</filename> is 0x10000c8 or greater, it indicates the
BIOS has already applied the microcode update.  Otherwise, configure the
kernel to support loading AMD microcode, and then proceed to <xref
linkend='early-microcode'/>:
      </para>

<screen><literal>General Setup ---&gt;
  [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support [CONFIG_BLK_DEV_INITRD]
Processor type and features  ---&gt;
  [*] CPU microcode loading support  [CONFIG_MICROCODE]
  [*]      AMD microcode loading support [CONFIG_MICROCODE_AMD]</literal></screen>
    </sect3>

    <sect3 id="early-microcode">
      <title>Carregamento antecipado do microcódigo</title>

      <para>
        Se você tiver estabelecido que o microcódigo atualizado está disponível para
o seu sistema, [então] é hora de prepará-lo para o carregamento
antecipado. Isso exige um pacote adicional, o <xref linkend='cpio'/> e a
criação de um initrd que precisará ser adicionado ao grub.cfg.
      </para>

      <para>
        Não importa onde você prepara o initrd e, tão logo ele esteja funcionando,
você pode aplicar o mesmo initrd a sistemas LFS posteriores ou a núcleos
mais recentes na mesma máquina, ao menos até que algum microcódigo mais
recente seja liberado. Use os seguintes comandos:
      </para>

<screen><userinput>mkdir -p initrd/kernel/x86/microcode
cd initrd</userinput></screen>

      <para>
        Para uma máquina AMD, use o seguinte comando (substitua &lt;MEUCONTEINER&gt;
pelo nome do contêiner para a família da sua CPU):
      </para>

<screen><userinput>cp -v ../&lt;MYCONTAINER&gt; kernel/x86/microcode/AuthenticAMD.bin</userinput></screen>

      <para>
        Ou, para uma máquina Intel, copie o blob apropriado usando este comando:
      </para>

<!-- new version from 20201110 release onwards, assumed to work on all skylakes
   But complaints about previous version took some days to appear, so keep as a comment for now.
      <caution>

        <para>
          On some Skylake machines with hex Model Number '4e' (78 decimal) the
          upgrade to microcode version '0xdc' is reported to cause the machine to
          hang in early boot, and the fix is to revert to version 0xd6 which was
          first shipped in the 20191115 microcode release.
        </para>

        <para>
          At least one model '5e' Skylake does boot successfully with version
          0xdc, but Intel has now shipped a 20200616 release which is intended for
          distros which need an initrd that will boot on everyone's machine: it
          reverts both Skylake variants ('4e' and '5e') to the old 0xd6.
        </para>

        <para>
          For a Skylake which does not boot with 0xdc, reverting to 0xd6 will make
          the machine usable, but without the SRBDS mitigations.
        </para>
      </caution>-->
<screen><userinput>cp -v ../intel-ucode/&lt;XX-YY-ZZ&gt; kernel/x86/microcode/GenuineIntel.bin</userinput></screen>



      <para>
        Agora, prepare o initrd:
      </para>

<screen><userinput>find . | cpio -o -H newc &gt; /boot/microcode.img</userinput></screen>

      <para>
        Agora você precisa adicionar uma entrada nova a /boot/grub/grub.cfg e aqui
você deveria adicionar uma linha nova depois da linha linux dentro da
estância. Se /boot for um ponto de montagem separado:
       </para>

<screen><userinput>initrd /microcode.img</userinput></screen>

      <para>
        ou isto, se ele não for:
      </para>

<screen><userinput>initrd /boot/microcode.img</userinput></screen>

      <para>
        If you are already booting with an initrd (see <xref linkend="initramfs"/>),
you should run <command>mkinitramfs</command> again after putting the
appropriate blob or container into <filename
class="directory">/lib/firmware</filename>. More precisely, put an intel
blob in a <filename class="directory">/lib/firmware/intel-ucode</filename>
directory or an AMD container in a <filename
class="directory">/lib/firmware/amd-ucode</filename> directory before
running <command>mkinitramfs</command>.  Alternatively, you can have both
initrd on the same line, such as <userinput>initrd /microcode.img
/other-initrd.img</userinput> (adapt that as above if /boot is not a
separate mountpoint).
      </para>

      <para>
        You can now reboot with the added initrd, and then use the following command
to check that the early load worked:
      </para>

<screen><userinput>dmesg | grep -e 'microcode' -e 'Linux version' -e 'Command line'</userinput></screen>

      <para>
        If you updated to address vulnerabilities, you can look at the output of the
<command>lscpu</command> command to see what is now reported.
      </para>

      <para>
        The places and times where early loading happens are very different in AMD
and Intel machines. First, an example of an Intel (Icelake mobile) with
early loading:
      </para>

<screen><literal>[    0.000000] microcode: microcode updated early to revision 0xb8, date = 2022-08-31
[    0.000000] Linux version 6.1.11 (xry111@stargazer) (gcc (GCC) 12.2.0, GNU ld (GNU Binutils) 2.40) #2 SMP PREEMPT_DYNAMIC Tue Feb 14 23:23:31 CST 2023
[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-6.1.11-lfs-11.3-rc1 root=PARTUUID=<replaceable>&lt;CLASSIFIED&gt;</replaceable> ro
[    0.452924] microcode: sig=0x706e5, pf=0x80, revision=0xb8
[    0.453197] microcode: Microcode Update Driver: v2.2.</literal></screen>


      <para>
        Um exemplo histórico AMD:
      </para>

<screen><literal>[    0.000000] Linux version 4.15.3 (ken@testserver) (gcc version 7.3.0 (GCC))
               #2 SMP Sun Feb 18 02:32:03 GMT 2018
[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-4.15.3-sda5 root=/dev/sda5 ro
[    0.307619] microcode: microcode updated early to new patch_level=0x010000c8
[    0.307678] microcode: CPU0: patch_level=0x010000c8
[    0.307723] microcode: CPU1: patch_level=0x010000c8
[    0.307795] microcode: Microcode Update Driver: v2.2.</literal></screen>

    </sect3>

  </sect2>

  <sect2 id="video-firmware">
    <title>Firmware para Placas de Vídeo</title>

    <sect3 id="ati-video-firmware">
      <title>Firmware para chips de vídeo ATI (R600 e posteriores)</title>

      <para>
        Estas instruções NÃO se aplicam aos antigos Radeons antes da família
R600. Para aqueles, o firmware está no diretório do núcleo <filename
class='directory'>/lib/firmware/</filename>. Nem se aplicam se você
pretender evitar uma configuração gráfica como o Xorg e estiver contente em
usar a exibição padrão de 80x25 em vez de um framebuffer.
      </para>

      <para>
        Os dispositivos iniciais Radeon precisavam somente de um blob de firmware de
2K. Os dispositivos recentes precisam de vários blobs e alguns deles são
muito maiores. O tamanho total do diretório do firmware Radeon é de mais que
500K &mdash; em um sistema largo moderno você provavelmente pode poupar o
espaço, porém ainda é redundante instalar todos os arquivos não usados a
cada vez que construir um sistema.
      </para>

      <para>
        Uma abordagem melhor é a de instalar o <xref linkend='pciutils'/> e, então,
usar o <userinput>lspci</userinput> para identificar qual controlador VGA
está instalado.
      </para>

      <para>
        With that information, check the RadeonFeature page of the Xorg wiki for
<ulink url="https://wiki.x.org/wiki/RadeonFeature/#index5h2">Decoder ring
for engineering vs marketing names</ulink> to identify the family (you may
need to know this for the Xorg driver in BLFS &mdash; Southern Islands and
Sea Islands use the radeonsi driver) and the specific model.
      </para>

      <para>
        Agora que você sabe qual controlador está usando, consulte a página <ulink
url="https://wiki.gentoo.org/wiki/Radeon#Firmware">Radeon</ulink> da wiki do
Gentoo a qual tem uma tabela listando os blobs de firmware exigidos para os
vários chipsets. Observe que os chips das Ilhas do Sul e os das Ilhas do Mar
usam firmware diferente para o núcleo 3.17 e posteriores comparados a
núcleos anteriores. Identifique e baixe os blobs exigidos; então instale-os:
      </para>

<screen><userinput>mkdir -pv /lib/firmware/radeon
cp -v &lt;YOUR_BLOBS&gt; /lib/firmware/radeon</userinput></screen>

      <para>
        Atualmente existem duas maneiras de instalar esse firmware. No BLFS, na
seção 'Configuração do Núcleo para firmware adicional', parte da seção <xref
linkend="xorg-ati-driver"/> dá um exemplo de compilar o firmware no núcleo -
isso é ligeiramente mais rápido de carregar, porém usa mais memória do
núcleo. Aqui nós usaremos o método alternativo de tornar o controlador
Radeon um módulo. No seu config do núcleo, configure o seguinte:
      </para>

<screen><literal>Device Drivers ---&gt;
  Graphics support ---&gt;
      Direct Rendering Manager ---&gt;
        [*] Direct Rendering Manager (XFree86 ... support)  [CONFIG_DRM]
      [M] ATI Radeon                                        [CONFIG_DRM_RADEON]</literal></screen>

      <para>
        O carregamento de vários blobs largos a partir de /lib/firmware toma um
tempo notável, durante o qual a tela estará sem escrito. Se você não
habilitar o logotipo pinguim do framebuffer ou mudar o tamanho do console
usando uma fonte maior, [então] provavelmente isso não importa. Se desejado,
você pode reduzir ligeiramente o tempo se seguir o método alternativo de
especificar 'y' para CONFIG_DRM_RADEON coberto no BLFS no link acima &mdash;
você precisa especificar cada blob Radeon necessário se fizer isso.
      </para>

    </sect3>

    <sect3 id="amdgpu-video-firmware">
      <title>Firmware for AMD/ATI amdgpu video chips</title>

      <para>
        All video controllers using the amdgpu kernel driver require firmware,
whether you will be using the xorg amdgpu driver, the xserver's modesetting
driver, or just kernel modesetting to get a console framebuffer larger than
80x25.
      </para>

      <para>
        Install <xref linkend="pciutils"/> and use that to check the model name
(look for 'VGA compatible controller:'). If you have an APU (Accelerated
Processing Unit, i.e. CPU and video on the same chip) that will probably
tell you the name. If you have a separate amdgpu video card you will need to
search to determine which name it uses (e.g. a card described as Advanced
Micro Devices, Inc. [AMD/ATI] Baffin [Radeon RX 550 640SP / RX 560/560X]
needs Polaris11 firmware.  There is a table of "Family, Chipset name,
Product name and Firmware" at the end of the Kernel sections in <ulink
url="https://wiki.gentoo.org/wiki/AMDGPU#Known_firmware_blobs">
AMDGPU</ulink> page of the Gentoo wiki.
    </para>

    <para>
      Once you have identified the firmware name, install all the relevant files
for it. For example, the Baffin card mentioned above has 21 different
polaris11* files, APUs such as renoir and picasso have at least 12 files and
might gain more in future updates (e.g. the raven APU now has a 13th file,
raven_ta.bin).
    </para>

<screen><userinput>mkdir -pv /lib/firmware/amdgpu
cp -v &lt;YOUR_BLOBS&gt; /lib/firmware/amdgpu</userinput></screen>

    <para>
      If disk space is not a problem, you could install all the current amdgpu
firmware files and not worry about exactly which chipset is installed.
    </para>

    <para>
      Building the kernel amdgpu driver as a module is recommended.  In your
kernel .config set at least the following options and review the other
AMDGPU options according to your target hardware, for example "ACP (Audio
Co-Processor) Configuration":
    </para>

<screen><literal>Device Drivers ---&gt;
  Graphics support ---&gt;
      Direct Rendering Manager ---&gt;
        [*] Direct Rendering Manager (XFree86 ... support)  [CONFIG_DRM]
        [M] AMD GPU                                         [CONFIG_DRM_AMDGPU]
        Display Engine Configuration ---&gt;
          [*] AMD DC - Enable new display engine (NEW)      [CONFIG_DRM_AMD_DC]</literal></screen>

      <para>
        As written above at the end of the section on 'Firmware for ATI video
chips', loading large blobs from /lib/firmware can take a noticeable time
during which the screen will be blank. On a slow machine you might wish to
refer to the 'Kernel Configuration for additional firmware' part of <xref
linkend="xorg-amdgpu-driver"/> and compile all the required modules into the
kernel to reduce this time, at the cost of using more kernel memory.
      </para>

    </sect3>

    <sect3 id="nvidia-video-firmware">
      <title>Firmware para chips de vídeo Nvidia</title>

      <para>
        Nvidia has released basic signed firmware for recent graphics chips, but
significantly after the chips and its own binary drivers were first
available. For other chips it has been necessary to extract the firmware
from the binary driver.
      </para>
      <para>
        For more exact information about which chips need extracted firmware, see
<ulink url=
"https://nouveau.freedesktop.org/wiki/VideoAcceleration/#firmware"/>.
      </para>

      <para>
        Primeiro, o controlador de núcleo Nvidia precisa ser ativado:
      </para>

<screen><literal>Device Drivers ---&gt;
  Graphics support ---&gt;
      Direct Rendering Manager ---&gt;
        &lt;*&gt; Direct Rendering Manager (XFree86 ... support)  [CONFIG_DRM]
      &lt;*/M&gt; Nouveau (NVIDIA) cards                          [CONFIG_DRM_NOUVEAU]</literal></screen>

      <para>
        If the necessary firmware is available in the <filename
class="directory">nvidia/</filename> directory of linux-firmware, copy it to
<filename class="directory">/lib/firmware/nouveau</filename>.
      </para>
      <para>
        If the firmware has not been made available in linux-firmware, for the old
chips mentioned in the nouveau wiki link above ensure you have installed
<xref linkend="python2"/> and run the following commands:
      </para>

      
<screen><!-- Someone please port this to Python 3.  -->
<userinput>wget https://raw.github.com/imirkin/re-vp2/master/extract_firmware.py
wget https://us.download.nvidia.com/XFree86/Linux-x86/325.15/NVIDIA-Linux-x86-325.15.run
sh NVIDIA-Linux-x86-325.15.run --extract-only
python2 extract_firmware.py
mkdir -p /lib/firmware/nouveau
cp -d nv* vuc-* /lib/firmware/nouveau/</userinput></screen>

    </sect3>
  </sect2>

  <sect2 id="nic-firmware">
    <title>Firmware para Interfaces de Rede de Comunicação</title>

    <para>
      O núcleo gosta de carregar firmware para alguns controladores de rede de
comunicação, particularmente aqueles originários do diretório da Realtek (o
/lib/linux-firmware/rtl_nic/), porém geralmente eles aparentam funcionar sem
isso. Sendo assim, você pode inicializar o núcleo; verificar dmesg para
mensagens acerca desse firmware ausente; e, se necessário, baixar o firmware
e colocá-lo no diretório especificado no <filename
class="directory">/lib/firmware</filename>, de forma que ele será encontrado
nas inicializações subsequentes. Observe que, com os núcleos atuais, isso
funciona se ou não o controlador for compilado internamente ou construído
como um módulo; não existe necessidade de construir esse firmware
internamente ao núcleo. Aqui está um exemplo onde o controlador R8169 foi
compilado internamente, porém o firmware não foi tornado disponível. Tão
logo o firmware tenha sido fornecido, não existiu menção dele nas
inicializações posteriores.
    </para>

<screen><literal>dmesg | grep firmware | grep r8169
[    7.018028] r8169 0000:01:00.0: Direct firmware load for rtl_nic/rtl8168g-2.fw failed with error -2
[    7.018036] r8169 0000:01:00.0 eth0: unable to load firmware patch rtl_nic/rtl8168g-2.fw (-2)</literal></screen>

  </sect2>

  <sect2 id="other-firmware">
    <title>Firmware para Outros Dispositivos</title>

    <para>
      Identificar o firmware correto tipicamente exigirá que você instale o <xref
linkend='pciutils'/> e, então, use o <userinput>lspci</userinput> para
identificar o dispositivo. Você deveria então procurar online para verificar
qual módulo ele usa; qual firmware; e onde obter o firmware &mdash; nem
todos eles estão no linux-firmware.
    </para>

    <para>
      If possible, you should begin by using a wired connection when you first
boot your LFS system. To use a wireless connection you will need to use a
network tools such as <xref linkend='wireless_tools'/> and <xref
linkend='wpa_supplicant'/>.
    </para>

    <para>
      Different countries have different regulations on the radio spectrum usage
of wireless devices.  You can install a firmware to make the wireless
devices obey local spectrum regulations, so you won't be inquired by local
authority or find your wireless NIC jamming the frequencies of other devices
(for example, remote controllers).  The regulatory database firmware can be
downloaded from <ulink url =
'https://kernel.org/pub/software/network/wireless-regdb/'/>.  To install it,
simply extract <filename>regulatory.db</filename> and
<filename>regulatory.db.p7s</filename> from the tarball into <filename
class="directory">/lib/firmware</filename>.  The access point would send a
country code to your wireless NIC, and <xref linkend='wpa_supplicant'/>
would tell the kernel to load the regulation of this country from
<filename>regulatory.db</filename>, and enforce it.
    </para>

    <para>
      Firmware possivelmente também seja necessário para outros dispositivos, tais
como alguns controladores SCSI; adaptadores bluetooth; ou gravadores de
TV. Os mesmos princípios se aplicam.
    </para>

  </sect2>

</sect1>
