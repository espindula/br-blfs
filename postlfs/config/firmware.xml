<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="postlfs-firmware" xreflabel="Acerca de Firmware">
  <?dbhtml filename="firmware.html"?>


  <title>Acerca de Firmware</title>

  <indexterm zone="postlfs-firmware">
    <primary sortas="e-lib-firmware">/lib/firmware</primary>
  </indexterm>

  <para>
    Em alguns PCs recentes, pode ser necessário, ou desejável, carregar firmware
para fazer com que trabalhem no melhor deles. Existe um diretório, <filename
class="directory">/lib/firmware</filename>, onde o núcleo ou os
controladores de núcleo procuram por imagens de firmware.
  </para>

  <para>
    Atualmente, a maioria do "firmware" pode ser encontrada em um repositório
<userinput>git</userinput>: <ulink
url="https://git.kernel.org/cgit/linux/kernel/git/firmware/linux-firmware.git/tree/"/>.
Por conveniência, o Projeto LFS criou um espelho, atualizado diariamente,
onde esses arquivos de "firmware" podem ser acessados via
<userinput>wget</userinput> ou via um navegador da "web" em <ulink
url="&sources-anduin-http;/linux-firmware/"/>.
  </para>

  <para>
    Para obter o firmware, ou aponte um navegador para um dos repositórios acima
e, então, transfira o(s) item(s) que você precisar; ou instale o <xref
linkend="git"/> e clone aquele repositório.
  </para>

  <para>
    Para algum outro firmware, particularmente para microcódigo da Intel e
certos dispositivos wifi, o firmware necessário não está disponível no
repositório acima. Algo disso será endereçado abaixo, porém uma busca da
Internet pelo firmware necessário de vez em quando é necessária.
  </para>

  <para>
    Os arquivos de firmware convencionalmente são referenciados como blobs, pois
você não consegue determinar o que eles farão. Observe que o firmware é
distribuído sob diferentes licenças que não permitem desmontagem ou
engenharia reversa.
  </para>

  <para>
    Firmware para PCs caem em quatro categorias:
  </para>

  <itemizedlist spacing="compact">
    <listitem>
      <para>
        Atualizações para a CPU contornar erros, geralmente referenciadas como
microcódigo.
      </para>
    </listitem>
    <listitem>
      <para>
        Firmware para controladores de vídeo. Em máquinas x86, isso é exigido para
dispositivos ATI (chips Radeon e AMDGPU); e possivelmente seja útil para
GPUs Intel (Skylake e posteriores) e Nvidia (Kepler e posteriores).
      </para>

      <para>
        Os dispositivos "ATI Radeon" e "AMGPU" todos exigem "firmware" para estarem
aptos a usar o "KMS" (kernel modesetting - a opção preferida), bem como para
"Xorg". Para os antigos chips "Radeon" (antes do "R600"), o "firmware" ainda
está no fonte do núcleo.
      </para>

      <para>
        GPUs integradas Intel a partir do Skylake em diante conseguem usar firmware
para GuC (o microcontrolador Graphics) e, também, para o HuC
(microcontrolador HEVC/H265, que descarrega para a GPU); e o DMC (Display
Microcontroller) para fornecer estados adicionais de baixa eletricidade. O
GuC e o HuC tiveram um histórico duvidoso no núcleo e o firmware atualizado
possivelmente esteja desabilitado por padrão, dependendo da sua versão de
núcleo. Maiores detalhes podem ser encontrados em <ulink
url="https://01.org/linuxgraphics/downloads/firmware/">01.org</ulink>; e
<ulink url="https://wiki.archlinux.org/index.php/intel_graphics">Arch
linux</ulink>.
      </para>

      <para>
        "GPUs" "Nvidia" a partir do "Kepler" em diante exigem "firmware" assinado,
do contrário o controlador "nouveau" será incapaz de fornecer aceleração de
"hardware". "Nvidia" agora lançou "firmware" até o "Ampere" (série
"GeForce30") para o "linux-firmware". Observe que os relógios mais rápidos
que o padrão não são habilitados pelo "firmware" lançado.
      </para>
    </listitem>
    <listitem>
      <para>
        Atualizações de firmware para portas cabeadas de rede de comunicação. A
maioria delas funciona mesmo sem as atualizações, porém provavelmente
funcionarão melhor com o firmware atualizado. Para alguns laptops modernos,
o firmware para ambos, ethernet cabeado (por exemplo, rtl_nic), e também
para dispositivos bluetooth (por exemplo, qca), é
<emphasis>exigido</emphasis> antes que a rede de comunicação cabeada possa
ser usada.
      </para>
    </listitem>
    <listitem>
      <para>
        Firmware para outros dispositivos, tais como wifi. Esses dispositivos não
são exigidos para o PC inicializar, porém precisam do firmware antes que
esses dispositivos possam ser usados.
      </para>
    </listitem>
  </itemizedlist>

  <note>
    <para>
      Apesar de não necessárias para carregar um blob de firmware, as seguintes
ferramentas possivelmente sejam úteis para determinar, obter ou preparar o
firmware necessário para a finalidade de carregá-lo no sistema: <xref
linkend="cpio"/>; <xref linkend="git"/>; <xref linkend="pciutils"/>; e <xref
linkend="wget"/>
    </para>
  </note>

  <para condition="html" role="usernotes">Observações de Usuário(a): <ulink url="&blfs-wiki;/aboutfirmware"/></para>

  <sect2 id="cpu-microcode">
    <title>Atualizações de microcódigo para CPUs</title>

    <para>
      Em geral, microcódigo pode ser carregado pelo BIOS ou pela UEFI e poderia
ser atualizado atualizando-se para uma versão mais recente daqueles. No
Linux, você também pode carregar o microcódigo a partir do núcleo se estiver
usando um processador AMD família 10h ou posterior (introduzido
primeiramente no final de 2007); ou um processador Intel a partir de 1998 e
posterior (Pentium4, Core, etc), se microcódigo atualizado tiver sido
lançado. Essas atualizações duram somente até que a máquina seja desligada,
de forma que elas precisam ser aplicadas a cada inicialização.
    </para>

    <para>
      A "Intel" fornece atualizações do microcódigo dela para os processadores
"Skylake" e posteriores conforme vulnerabilidades novas surjam e forneceu no
passado atualizações para processadores a partir do "SandyBridge" em diante,
apesar daqueles não mais serem suportados para correções novas. Versões
novas do "firmware" "AMD" são raras e geralmente somente se aplicam a uns
poucos modelos, apesar dos(as) fabricantes de placas mãe obterem
atualizações "AMD Generic Encapsulated Software Architecture" ("AGESA") para
mudar os valores do "BIOS", por exemplo, para suportar mais variantes de
memória, correções novas de vulnerabilidades ou "CPUs" mais recentes.
    </para>

    <para>
      Existiam duas maneiras de carregar o microcódigo, descritas como
"antecipada" e "atrasada". O carregamento antecipado ocorre antes que o
espaço de usuário(a) tenha sido iniciado; o carregamento atrasado ocorre
depois que o espaço de usuário(a) iniciou. No entanto, o carregamento
atrasado é conhecido por ser problemático e não mais é suportado (veja-se o
"commit" do núcleo <ulink
url="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d23d33e">x86/microcode:
Taint and warn on late loading</ulink>). Na verdade, o carregamento
antecipado é necessário para contornar uma errata específica nos primeiros
processadores "Intel" "Haswell" que tinham "TSX" habilitado. (Veja-se <ulink
url=
"https://www.anandtech.com/show/8376/intel-disables-tsx-instructions-erratum-found-in-haswell-haswelleep-broadwelly/">
Intel Disables TSX Instructions: Erratum Found in Haswell, Haswell-E/EP,
Broadwell-Y</ulink>). Sem essa atualização, a "glibc" pode fazer a coisa
errada em situações incomuns.
    </para>

    <para>
      Nas versões anteriores deste livro, era recomendado o carregamento atrasado
do microcódigo para verificar se ele seria aplicado, seguido pelo uso de um
"initrd" para forçar o carregamento antecipado. Mas agora que o conteúdo do
"tarball" do microcódigo "Intel" está documentado e o microcódigo "AMD" pode
ser lido por um script "Python" para determinar quais máquinas ele cobre,
não existe razão real para usar o carregamento atrasado.
    </para>

    <para>
      Ainda pode ser possível forçar manualmente o carregamento atrasado do
microcódigo. Mas isso possivelmente cause mau funcionamento do núcleo e você
mesmo(a) deveria correr o risco. Você precisará reconfigurar seu núcleo para
qualquer um dos métodos. As instruções aqui te mostrarão como criar um
"initrd" para carregamento antecipado. Também é possível construir o mesmo
arquivo binário de microcódigo interno ao núcleo, o que permite o
carregamento antecipado, mas exige que o núcleo seja recompilado para
atualizar o microcódigo.
    </para>

    <para>
      Para confirmar qual(is) processador(es) você tem (se mais que um, eles serão
idênticos) olhe em "/proc/cpuinfo". Determine os valores decimais da família
da "CPU"; do modelo; e da revisão executando o seguinte comando (também
informará a versão atual do microcódigo):
    </para>

<screen><userinput>head -n7 /proc/cpuinfo</userinput></screen>

    <para>
      Converta a família da "CPU", o modelo e a revisão em pares de dígitos
hexadecimais e lembre-se do valor do campo <quote>microcode</quote>. Agora
você pode verificar se existe algum microcódigo disponível.
    </para>

    <para>
      Se você estiver criando um "initrd" para atualizar "firmware" para máquinas
diferentes, como uma distribuição faria, [então] vá para baixo até
'Carregamento antecipado do microcódigo' e concatene todos os "blobs"
"Intel" para "GenuineIntel.bin"; ou concatene todos os "blobs" "AMD" para
"AuthenticAMD.bin". Isso cria um "initrd" mais largo - para todas as
máquinas "Intel" na atualização 20200609, o tamanho era de três (3,0) MB
comparado a tipicamente vinte e quatro (24) KB para uma máquina.
    </para>

    <sect3 id="intel-microcode">
      <title>Microcódigo Intel para a CPU</title>

      <para>
        <!-- at one time, some skylakes had problems with a certain revision
        secure version of the microcode, for those machines which can boot it, -->
<!-- If you have a Skylake machine, please read the
        Caution in the 'Early loading of microcode' section below.-->
O primeiro passo é o de obter a versão mais recente do microcódigo
"Intel". Isso precisa ser feito navegando-se até <ulink url=
'https://github.com/intel/Intel-Linux-Processor-Microcode-Data-Files/releases/'/>
e baixando-se o arquivo mais recente lá. Ao tempo da escrita deste texto, a
versão mais segura do microcódigo era microcode-20230214. Extraia esse
arquivo da maneira normal; o microcódigo está no diretório
<filename>intel-ucode</filename>, contendo vários "blobs" com nomes na forma
"XX-YY-ZZ". Existem também vários outros arquivos e uma observação de
lançamento.
      </para>

      <para>
        No passado, a "Intel" não fornecia quaisquer detalhes relativos a quais
"blobs" tinham versões mudadas, mas agora a nota de lançamento detalha
isso. Você consegue comparar a versão do microcódigo em
<filename>/proc/cpuinfo</filename> com a versão do seu modelo de "CPU" na
nota de lançamento para saber se existe uma atualização.
      </para>

      <para>
        O firmware recente para processadores mais antigos é fornecido para lidar
com vulnerabilidades que agora tenham sido tornadas públicas e, para algumas
dessas, tais como Microarchitectural Data Sampling (MDS), você poderia
desejar aumentar a proteção desabilitando hyperthreading; ou,
alternativamente, desabilitar a mitigação padrão do núcleo, por causa do
impacto dela sobre os tempos de compilação. Por favor, leia a documentação
online em <ulink url=
'https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/index.html'/>.
      </para>

      <para>
        Para um dispositivo móvel "Icelake" (descrito como "CPU" "Intel(R) Core(TM)
i7-1065G7"), os valores relevantes são "cpu family 6", "model 126",
"stepping 5", de modo que, nesse caso, a identificação necessária é
"06-7e-05". A nota de lançamento diz que o microcódigo mais recente tem a
versão "0xb8". Se o valor do campo <quote>microcode</quote> em
<filename>/proc/cpuinfo</filename> for "0xb8" ou superior, [então] indica
que a atualização do microcódigo já foi aplicada pelo "BIOS". Caso
contrário, configure o núcleo para suportar o carregamento do microcódigo
"Intel" e prossiga para <xref linkend='early-microcode'/>:
      </para>

<screen><literal>General Setup ---&gt;
  [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support [CONFIG_BLK_DEV_INITRD]
Processor type and features  ---&gt;
  [*] CPU microcode loading support  [CONFIG_MICROCODE]
  [*]      Intel microcode loading support [CONFIG_MICROCODE_INTEL]</literal></screen>

    </sect3>

    <sect3 id="amd-microcode">
      <title>Microcódigo AMD para a CPU</title>

      <para>
        Comece baixando um contêiner do "firmware" para a família da sua "CPU" a
partir de <ulink url= '&sources-anduin-http;/linux-firmware/amd-ucode/'/>. A
família sempre é especificada em hexadecimal. As famílias "10h" até "14h"
(16 até 20) estão no "microcode_amd.bin". As famílias "15h", "16h", "17h"
("Zen", "Zen+", "Zen2") e "19h" ("Zen3") tem os contêineres próprios delas,
mas pouquíssimas máquinas provavelmente receberão microcódigo atualizado. Em
vez disso, a "AMD" fornece um "AGESA" atualizado para os(as) fabricantes de
placas-mãe, que possivelmente forneçam um "BIOS" atualizado usando-o. Existe
um script "Python3" em <ulink url=
'https://github.com/AMDESE/amd_ucode_info/blob/master/amd_ucode_info.py'/>.
Baixe esse script e execute-o em relação ao arquivo "bin" para verificar
quais processadores tem atualizações.
      </para>

      <para>
        Para o muito antigo "Athlon(tm) II X2" nesses exemplos os valores eram "cpu
family 16", "model 5", "stepping 3", dando uma identificação de Família=0x10
Modelo=0x05 Passo=0x03. Uma linha da saída gerada do script
<command>amd_ucode_info.py</command> descreve a versão do microcódigo para
ele:
      </para>

<screen><computeroutput>Family=0x10 Model=0x05 Stepping=0x03: Patch=0x010000c8 Length=960 bytes</computeroutput></screen>

      <para>
        Se o valor do campo <quote>microcode</quote> em
<filename>/proc/cpuinfo</filename> for "0x10000c8" ou superior, [então]
indica que o "BIOS" já aplicou a atualização do microcódigo. Caso contrário,
configure o núcleo para suportar o carregamento do microcódigo "AMD" e
prossiga para <xref linkend='early-microcode'/>:
      </para>

<screen><literal>General Setup ---&gt;
  [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support [CONFIG_BLK_DEV_INITRD]
Processor type and features  ---&gt;
  [*] CPU microcode loading support  [CONFIG_MICROCODE]
  [*]      AMD microcode loading support [CONFIG_MICROCODE_AMD]</literal></screen>
    </sect3>

    <sect3 id="early-microcode">
      <title>Carregamento antecipado do microcódigo</title>

      <para>
        Se você tiver estabelecido que o microcódigo atualizado está disponível para
o seu sistema, [então] é hora de prepará-lo para o carregamento
antecipado. Isso exige um pacote adicional, o <xref linkend='cpio'/> e a
criação de um initrd que precisará ser adicionado ao grub.cfg.
      </para>

      <para>
        Não importa onde você prepara o initrd e, tão logo ele esteja funcionando,
você pode aplicar o mesmo initrd a sistemas LFS posteriores ou a núcleos
mais recentes na mesma máquina, ao menos até que algum microcódigo mais
recente seja liberado. Use os seguintes comandos:
      </para>

<screen><userinput>mkdir -p initrd/kernel/x86/microcode
cd initrd</userinput></screen>

      <para>
        Para uma máquina AMD, use o seguinte comando (substitua &lt;MEUCONTEINER&gt;
pelo nome do contêiner para a família da sua CPU):
      </para>

<screen><userinput>cp -v ../&lt;MEU_CONTẼINER&gt; kernel/x86/microcode/AuthenticAMD.bin</userinput></screen>

      <para>
        Ou, para uma máquina Intel, copie o blob apropriado usando este comando:
      </para>

<!-- new version from 20201110 release onwards, assumed to work on all skylakes
   But complaints about previous version took some days to appear, so keep as a comment for now.
      <caution>

        <para>
          On some Skylake machines with hex Model Number '4e' (78 decimal) the
          upgrade to microcode version '0xdc' is reported to cause the machine to
          hang in early boot, and the fix is to revert to version 0xd6 which was
          first shipped in the 20191115 microcode release.
        </para>

        <para>
          At least one model '5e' Skylake does boot successfully with version
          0xdc, but Intel has now shipped a 20200616 release which is intended for
          distros which need an initrd that will boot on everyone's machine: it
          reverts both Skylake variants ('4e' and '5e') to the old 0xd6.
        </para>

        <para>
          For a Skylake which does not boot with 0xdc, reverting to 0xd6 will make
          the machine usable, but without the SRBDS mitigations.
        </para>
      </caution>-->
<screen><userinput>cp -v ../intel-ucode/&lt;XX-YY-ZZ&gt; kernel/x86/microcode/GenuineIntel.bin</userinput></screen>



      <para>
        Agora, prepare o initrd:
      </para>

<screen><userinput>find . | cpio -o -H newc &gt; /boot/microcode.img</userinput></screen>

      <para>
        Agora você precisa adicionar uma entrada nova a /boot/grub/grub.cfg e aqui
você deveria adicionar uma linha nova depois da linha linux dentro da
estância. Se /boot for um ponto de montagem separado:
       </para>

<screen><userinput>initrd /microcode.img</userinput></screen>

      <para>
        ou isto, se ele não for:
      </para>

<screen><userinput>initrd /boot/microcode.img</userinput></screen>

      <para>
        Se já estiver inicializando com um "initrd" (veja-se <xref
linkend="initramfs"/>), [então] você deveria executar
<command>mkinitramfs</command> novamente depois de colocar o "blob" ou
contêiner apropriado no <filename
class="directory">/lib/firmware</filename>. Mais precisamente, coloque um
"blob" "Intel" em um diretório <filename
class="directory">/lib/firmware/intel-ucode</filename> ou um contêiner "AMD"
em um diretório <filename
class="directory">/lib/firmware/amd-ucode</filename> antes de executar
<command>mkinitramfs</command>. Alternativamente, você pode ter ambos os
"initrd" na mesma linha, tal como <userinput>initrd /microcode.img
/outro-initrd.img</userinput> (adapte isso conforme acima se "/boot" não for
um ponto de montagem separado).
      </para>

      <para>
        Você agora pode reinicializar com o "initrd" adicionado e, então, usar o
seguinte comando para verificar se o carregamento antecipado funcionou:
      </para>

<screen><userinput>dmesg | grep -e 'microcode' -e 'Linux version' -e 'Command line'</userinput></screen>

      <para>
        Se atualizou para endereçar vulnerabilidades, [então] você pode olhar a
saída gerada do comando <command>lscpu</command> para ver o que é informado
agora.
      </para>

      <para>
        Os locais e horários onde o carregamento antecipado acontece são muito
diferentes em máquinas "AMD" e "Intel". Primeiro, um exemplo de uma "Intel"
(dispositivo móvel "Icelake") com carregamento antecipado:
      </para>

<screen><literal>[    0.000000] microcode: microcode updated early to revision 0xb8, date = 2022-08-31
[    0.000000] Linux version 6.1.11 (xry111@stargazer) (gcc (GCC) 12.2.0, GNU ld (GNU Binutils) 2.40) #2 SMP PREEMPT_DYNAMIC Tue Feb 14 23:23:31 CST 2023
[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-6.1.11-lfs-11.3-rc1 root=PARTUUID=<replaceable>&lt;CLASSIFIED&gt;</replaceable> ro
[    0.452924] microcode: sig=0x706e5, pf=0x80, revision=0xb8
[    0.453197] microcode: Microcode Update Driver: v2.2.</literal></screen>


      <para>
        Um exemplo histórico AMD:
      </para>

<screen><literal>[    0.000000] Linux version 4.15.3 (ken@testserver) (gcc version 7.3.0 (GCC))
               #2 SMP Sun Feb 18 02:32:03 GMT 2018
[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-4.15.3-sda5 root=/dev/sda5 ro
[    0.307619] microcode: microcode updated early to new patch_level=0x010000c8
[    0.307678] microcode: CPU0: patch_level=0x010000c8
[    0.307723] microcode: CPU1: patch_level=0x010000c8
[    0.307795] microcode: Microcode Update Driver: v2.2.</literal></screen>

    </sect3>

  </sect2>

  <sect2 id="video-firmware">
    <title>Firmware para Placas de Vídeo</title>

    <sect3 id="ati-video-firmware">
      <title>Firmware para chips de vídeo ATI (R600 e posteriores)</title>

      <para>
        Estas instruções NÃO se aplicam aos antigos Radeons antes da família
R600. Para aqueles, o firmware está no diretório do núcleo <filename
class='directory'>/lib/firmware/</filename>. Nem se aplicam se você
pretender evitar uma configuração gráfica como o Xorg e estiver contente em
usar a exibição padrão de 80x25 em vez de um framebuffer.
      </para>

      <para>
        Os dispositivos iniciais Radeon precisavam somente de um blob de firmware de
2K. Os dispositivos recentes precisam de vários blobs e alguns deles são
muito maiores. O tamanho total do diretório do firmware Radeon é de mais que
500K &mdash; em um sistema largo moderno você provavelmente pode poupar o
espaço, porém ainda é redundante instalar todos os arquivos não usados a
cada vez que construir um sistema.
      </para>

      <para>
        Uma abordagem melhor é a de instalar o <xref linkend='pciutils'/> e, então,
usar o <userinput>lspci</userinput> para identificar qual controlador VGA
está instalado.
      </para>

      <para>
        Com essa informação, verifique a página "RadeonFeature" da "wiki" do "Xorg"
para <ulink url="https://wiki.x.org/wiki/RadeonFeature/#index5h2">Decoder
ring for engineering vs marketing names</ulink> para identificar a família
(você possivelmente precise saber disso para o controlador "Xorg" no BLFS
&mdash; Ilhas do Sul e Ilhas do Mar usam o controlador "radeonsi") e o
modelo específico.
      </para>

      <para>
        Agora que você sabe qual controlador está usando, consulte a página <ulink
url="https://wiki.gentoo.org/wiki/Radeon#Firmware">Radeon</ulink> da wiki do
Gentoo a qual tem uma tabela listando os blobs de firmware exigidos para os
vários chipsets. Observe que os chips das Ilhas do Sul e os das Ilhas do Mar
usam firmware diferente para o núcleo 3.17 e posteriores comparados a
núcleos anteriores. Identifique e baixe os blobs exigidos; então instale-os:
      </para>

<screen><userinput>mkdir -pv /lib/firmware/radeon
cp -v &lt;YOUR_BLOBS&gt; /lib/firmware/radeon</userinput></screen>

      <para>
        Atualmente existem duas maneiras de instalar esse firmware. No BLFS, na
seção 'Configuração do Núcleo para firmware adicional', parte da seção <xref
linkend="xorg-ati-driver"/> dá um exemplo de compilar o firmware no núcleo -
isso é ligeiramente mais rápido de carregar, porém usa mais memória do
núcleo. Aqui nós usaremos o método alternativo de tornar o controlador
Radeon um módulo. No seu config do núcleo, configure o seguinte:
      </para>

<screen><literal>Device Drivers ---&gt;
  Graphics support ---&gt;
      Direct Rendering Manager ---&gt;
        [*] Direct Rendering Manager (XFree86 ... support)  [CONFIG_DRM]
      [M] ATI Radeon                                        [CONFIG_DRM_RADEON]</literal></screen>

      <para>
        O carregamento de vários blobs largos a partir de /lib/firmware toma um
tempo notável, durante o qual a tela estará sem escrito. Se você não
habilitar o logotipo pinguim do framebuffer ou mudar o tamanho do console
usando uma fonte maior, [então] provavelmente isso não importa. Se desejado,
você pode reduzir ligeiramente o tempo se seguir o método alternativo de
especificar 'y' para CONFIG_DRM_RADEON coberto no BLFS no link acima &mdash;
você precisa especificar cada blob Radeon necessário se fizer isso.
      </para>

    </sect3>

    <sect3 id="amdgpu-video-firmware">
      <title>"Firmware" para chips de vídeo "amdgpu" "AMD"/"ATI"</title>

      <para>
        Todos os controladores de vídeo que usam o controlador "amdgpu" do núcleo
exigem "firmware", se você estará usando o controlador "amdgpu" do "Xorg", o
controlador "modesetting" do "xserver" ou apenas o "modesetting" do núcleo
para obter um "framebuffer" do console maior que "80x25".
      </para>

      <para>
        Instale <xref linkend="pciutils"/> e use-o para verificar o nome do modelo
(procure por "VGA compatible controller:"). Se você tiver uma "Unidade de
Processamento Acelerado" ("APU"), ou seja, "CPU" e vídeo no mesmo chip),
provavelmente te dirá o nome. Se você tiver uma placa de vídeo "amdgpu"
separada, [então] precisará pesquisar para determinar qual nome ela usa (por
exemplo, uma placa descrita como "Advanced Micro Devices, Inc."
["AMD"/"ATI"] "Baffin" ["Radeon RX 550 640SP / RX 560/560X"] precisa de
"firmware" "Polaris11". Existe uma tabela de "Família, nome do "Chipset",
nome do Produto e Firmware" no final das seções "Kernel" na página <ulink
url="https://wiki.gentoo.org/wiki/AMDGPU#Known_firmware_blobs">
AMDGPU</ulink> do "wiki" do "Gentoo".
    </para>

    <para>
      Depois que você tiver identificado o nome do "firmware", instale todos os
arquivos relevantes para ele. Por exemplo, a placa "Baffin" mencionada acima
tem vinte e um (21) arquivos "polaris11*", "APUs" como "renoir" e "picasso"
tem pelo menos doze (12) arquivos e podem ganhar mais em atualizações
futuras (por exemplo, a "APU" "raven" agora tem um décimo terceiro (13º)
arquivo, "raven_ta.bin").
    </para>

<screen><userinput>mkdir -pv /lib/firmware/amdgpu
cp -v &lt;TEUS_BLOBS&gt; /lib/firmware/amdgpu</userinput></screen>

    <para>
      Se espaço em disco não for um problema, [então] você poderá instalar todos
os arquivos atuais de "firmware" "amdgpu" e não se preocupar exatamente com
qual "chipset" está instalado.
    </para>

    <para>
      É recomendado construir o controlador "amdgpu" do núcleo como um módulo. Em
seu ".config" do núcleo configure pelo menos as seguintes opções e revise as
outras opções "AMDGPU" de acordo com teu "hardware" alvo, por exemplo
"Configuração ACP (Coprocessador de Áudio)":
    </para>

<screen><literal>Device Drivers ---&gt;
  Graphics support ---&gt;
      Direct Rendering Manager ---&gt;
        [*] Direct Rendering Manager (XFree86 ... support)  [CONFIG_DRM]
        [M] AMD GPU                                        [CONFIG_DRM_AMDGPU]
        Display Engine Configuration ---&gt;
          [*] AMD DC - Enable new display engine (NEW)      [CONFIG_DRM_AMD_DC]</literal></screen>

      <para>
        Conforme escrito acima no final da seção sobre "Firmware para chips de vídeo
ATI", carregar grandes "blobs" a partir de "/lib/firmware" pode levar um
tempo perceptível durante o qual a tela ficará em branco. Em uma máquina
lenta, você pode desejar consultar a parte "Configuração do Núcleo para
"firmware" adicional" de <xref linkend="xorg-amdgpu-driver"/> e compilar
todos os módulos exigidos internos ao núcleo para reduzir esse tempo, ao
custo de usar mais memória do núcleo.
      </para>

    </sect3>

    <sect3 id="nvidia-video-firmware">
      <title>Firmware para chips de vídeo Nvidia</title>

      <para>
        A "Nvidia" lançou "firmware" básico assinado para chips gráficos recentes,
mas significativamente depois que os chips e os próprios controladores
binários deles foram disponibilizados pela primeira vez. Para outros chips
tem sido necessário extrair o "firmware" a partir do controlador binário.
      </para>
      <para>
        Para informações mais exatas relativas a quais chips precisam de "firmware"
extraído, veja-se <ulink url=
"https://nouveau.freedesktop.org/wiki/VideoAcceleration/#firmware"/>.
      </para>

      <para>
        Primeiro, o controlador de núcleo Nvidia precisa ser ativado:
      </para>

<screen><literal>Device Drivers ---&gt;
  Graphics support ---&gt;
      Direct Rendering Manager ---&gt;
        &lt;*&gt; Direct Rendering Manager (XFree86 ... support)  [CONFIG_DRM]
      &lt;*/M&gt; Nouveau (NVIDIA) cards                          [CONFIG_DRM_NOUVEAU]</literal></screen>

      <para>
        Se o "firmware" necessário estiver disponível no diretório <filename
class="directory">nvidia/</filename> de "linux-firmware", [então] copie-o
<filename class="directory">/lib/firmware/nouveau</filename>.
      </para>
      <para>
        Se o "firmware" não tiver sido disponibilizado em "linux-firmware", para os
chips antigos mencionados no link "nouveau" do "wiki" acima, [então]
certifique-se de ter instalado <xref linkend="python2"/> e execute os
seguintes comandos:
      </para>

      
<screen><!-- Someone please port this to Python 3.  -->
<userinput>wget https://raw.github.com/imirkin/re-vp2/master/extract_firmware.py
wget https://us.download.nvidia.com/XFree86/Linux-x86/325.15/NVIDIA-Linux-x86-325.15.run
sh NVIDIA-Linux-x86-325.15.run --extract-only
python2 extract_firmware.py
mkdir -p /lib/firmware/nouveau
cp -d nv* vuc-* /lib/firmware/nouveau/</userinput></screen>

    </sect3>
  </sect2>

  <sect2 id="nic-firmware">
    <title>Firmware para Interfaces de Rede de Comunicação</title>

    <para>
      O núcleo gosta de carregar firmware para alguns controladores de rede de
comunicação, particularmente aqueles originários do diretório da Realtek (o
/lib/linux-firmware/rtl_nic/), porém geralmente eles aparentam funcionar sem
isso. Sendo assim, você pode inicializar o núcleo; verificar dmesg para
mensagens acerca desse firmware ausente; e, se necessário, baixar o firmware
e colocá-lo no diretório especificado no <filename
class="directory">/lib/firmware</filename>, de forma que ele será encontrado
nas inicializações subsequentes. Observe que, com os núcleos atuais, isso
funciona se ou não o controlador for compilado internamente ou construído
como um módulo; não existe necessidade de construir esse firmware
internamente ao núcleo. Aqui está um exemplo onde o controlador R8169 foi
compilado internamente, porém o firmware não foi tornado disponível. Tão
logo o firmware tenha sido fornecido, não existiu menção dele nas
inicializações posteriores.
    </para>

<screen><literal>dmesg | grep firmware | grep r8169
[    7.018028] r8169 0000:01:00.0: Direct firmware load for rtl_nic/rtl8168g-2.fw failed with error -2
[    7.018036] r8169 0000:01:00.0 eth0: unable to load firmware patch rtl_nic/rtl8168g-2.fw (-2)</literal></screen>

  </sect2>

  <sect2 id="other-firmware">
    <title>Firmware para Outros Dispositivos</title>

    <para>
      Identificar o firmware correto tipicamente exigirá que você instale o <xref
linkend='pciutils'/> e, então, use o <userinput>lspci</userinput> para
identificar o dispositivo. Você deveria então procurar online para verificar
qual módulo ele usa; qual firmware; e onde obter o firmware &mdash; nem
todos eles estão no linux-firmware.
    </para>

    <para>
      Se possível, você deveria iniciar usando uma conexão com fios quando
inicializar pela primeira vez o seu sistema LFS. Para usar uma conexão sem
fios, você precisará usar ferramentas de rede de comunicação, tais como
<xref linkend='wireless_tools'/> e <xref linkend='wpa_supplicant'/>.
    </para>

    <para>
      Países diferentes tem regulações diferentes acerca do uso do espectro de
rádio dos dispositivos sem fios. Você pode instalar um firmware para fazer
com que os dispositivos sem fios obedeçam às regulações locais de espectro,
de forma que você não seria questionado(a) pela autoridade local ou não
encontraria sua NIC sem fios atrapalhando as frequências de outros
dispositivos (por exemplo, controles remotos). O firmware da base de dados
regulatória pode ser baixado a partir de <ulink url =
'https://kernel.org/pub/software/network/wireless-regdb/'/>. Para
instalá-lo, simplesmente extraia o <filename>regulatory.db</filename> e o
<filename>regulatory.db.p7s</filename> a partir do tarball no <filename
class="directory">/lib/firmware</filename>. O ponto de acesso enviaria um
código de país para a sua NIC sem fios e o <xref linkend='wpa_supplicant'/>
diria ao núcleo para carregar a regulação desse país a partir do
<filename>regulatory.db</filename>; e impô-la.
    </para>

    <para>
      Firmware possivelmente também seja necessário para outros dispositivos, tais
como alguns controladores SCSI; adaptadores bluetooth; ou gravadores de
TV. Os mesmos princípios se aplicam.
    </para>

  </sect2>

</sect1>
