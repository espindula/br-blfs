<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<!--

Direitos autorais (Copyright) da versão modificada traduzida para a 
língua portuguesa escrita e falada no Brasil: (c) 2022, 2023 Jamenson 
Ferreira Espindula de Almeida Melo (<jafesp@gmail.com>).

  Este trabalho de tradução do livro "Beyond Linux From Scratch" é 
  classificado pela Free Software Foundation como sendo uma "versão 
  modificada" do mencionado livro.  Em assim sendo, na qualidade de 
  tradutor, produtor da "versão modificada" e titular dos direitos 
  autorais sobre a versão traduzida para a língua portuguesa do livro 
  "Beyond Linux From Scratch", concede-se a seguinte permissão:

  É concedida permissão para copiar, distribuir e (ou) modificar este 
  livro "Beyond Linux From Scratch", versão traduzida para a língua 
  portuguesa, sob os termos da Licença de Documentação Livre GNU, versão 
  1.3 ou qualquer versão posterior publicada pela Free Software 
  Foundation; sem Seções Invariantes, sem Textos de Capa Frontal e sem 
  Textos de Quarta Capa.  Uma cópia da licença está incluída na seção 
  intitulada "Licença de Documentação Livre GNU".
  
# Atenção: todos os documentos aqui publicados são distribuídos sem qualquer garantia, implícita e (ou) explícita.
  
  Permission is granted to copy, distribute and (or) modify this book 
  "Beyond Linux From Scratch", translated into Brazilian Portuguese, 
  under the terms of the GNU Free Documentation License, Version 1.3 or 
  any later version published by the Free Software Foundation; with no 
  Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A 
  copy of the license is included in the section entitled "GNU Free 
  Documentation License".

# Warning: all the files herein published are released with no warranty, implicit and (or) explicit.

-->

<sect1 id="postlfs-devices" xreflabel="Acerca de Dispositivos">
  <?dbhtml filename="devices-pt_br.html"?>

  <sect1info>
    <date>$Date$</date>
  </sect1info>

  <title>Acerca de Dispositivos</title>

  <indexterm zone="postlfs-devices">
    <primary sortas="e-etc-udev-rules">/etc/udev/rules.d</primary>
  </indexterm>

  <para>

    Apesar da maioria dos dispositivos necessitados pelos pacotes no 
    BLFS e além serem configurados adequadamente pelo 
    <application>udev</application> usando as regras padrão instaladas 
    pelo LFS em
<filename class="directory">/etc/udev/rules.d</filename>, existem casos onde 
    as regras precisam ser modificadas ou estendidas.

  </para>

  <para condition="html" role="usernotes">

    Observações de Usuário(a): <ulink url="&blfs-wiki;/aboutdevices"/>

  </para>

  <sect2>
    <title>Múltiplas Placas de Som</title>

    <para>

      Se existirem múltiplas placas de som em um sistema, [então] a 
      placa de som "padrão" se torna aleatória.  O método para 
      estabelecer a ordem da placa de som depende se os controladores 
      são módulos ou não.  Se os controladores da placa de som forem 
      compilados internamente ao kernel, [então] o controle é via 
      parâmetros de linha de comando do kernel em 
      <filename>/boot/grub/grub.cfg</filename>.  Por exemplo, se um 
      sistema tiver ambas, uma placa FM801 e uma placa PCI SoundBlaster, 
      [então] o seguinte pode ser acrescentado à linha de comando:

    </para>

<screen><literal>snd-fm801.index=0 snd-ens1371.index=1</literal></screen>

    <para>

      Se os controladores da placa de som forem construídos como 
      módulos, [então] a ordem pode ser estabelecida no arquivo 
      <filename>/etc/modprobe.conf</filename> com:

    </para>

<screen><literal>options snd-fm801 index=0
options snd-ens1371 index=1</literal></screen>

  </sect2>

  <sect2 id="usb-device-issues">
    <title>Consequências do Dispositivo USB</title>

    <para>

      Os dispositivos USB geralmente tem dois tipos de nós de 
      dispositivo associados com eles.

    </para>

    <para>

      O primeiro tipo é criado pelos controladores específicos do 
      dispositivo (por exemplo, usb_storage/sd_mod ou usblp) no kernel.  
      Por exemplo, um dispositivo USB de armazenamento em massa seria 
      /dev/sdb; e uma impressora USB seria /dev/usb/lp0.  Esses nós de 
      dispositivo somente existem quando o controlador específico do 
      dispositivo estiver carregado.

    </para>

    <para>

      O segundo tipo de nós de dispositivo (/dev/bus/usb/BBB/DDD, onde 
      BBB é o número do barramento e DDD é o número do dispositivo) é 
      criado mesmo se o dispositivo não tiver um controlador de kernel.  
      Ao usar esses nós de dispositivo USB "crus", uma aplicação pode 
      trocar pacotes USB arbitrários com o dispositivo, isto é, 
      contornar o possivelmente existente controlador de kernel.

    </para>

    <para>

      O acesso a nós de dispositivo USB crus é necessário quando um 
      aplicativo do espaço do(a) usuário(a) estiver atuando como um 
      controlador de dispositivo.  Entretanto, para o aplicativo abrir o 
      dispositivo com sucesso, as permissões devem ser configuradas 
      corretamente.  Por padrão, devido a motivos de segurança, todos os 
      dispositivos USB crus são de propriedade do(a) usuário(a) root e 
      do grupo usb; e tem permissões 0664 (o acesso de leitura é 
      necessário, por exemplo, para o lsusb funcionar e para os 
      aplicativos acessarem hubs USB).  Os pacotes (tais como SANE e 
      libgphoto2) contendo controladores de dispositivo USB do espaço 
      do(a) usuário(a) também embarcam regras do udev que mudam as 
      permissões dos dispositivos USB crus controlados.  Isto é, as 
      regras instaladas pelo SANE mudam as permissões para escaneadores 
      conhecidos, porém não para impressoras.  Se um(a) mantenedor(a) de 
      pacote se esqueceu de escrever uma regra para o seu dispositivo, 
      [então] relate um defeito para ambos, o BLFS (se o pacote estiver 
      lá) e o(a) desenvolvedor(a), e você precisará escrever sua própria 
      regra.

    </para>

    <para>

      Existe uma situação quando tal controle de acesso refinado com 
      regras do udev pré-geradas não funciona.  Nomeadamente, os 
      emuladores de PC, tais como o KVM; o QEMU; e o VirtualBox, usam 
      nós de dispositivo USB crus para apresentar dispositivos USB 
      arbitrários para o sistema operacional convidado (observação: 
      remendos são necessários para a finalidade de fazer com que isso 
      funcione sem o obsoleto ponto de montagem /proc/bus/usb descrito 
      abaixo).  Obviamente, os(as) mantenedores(as) desses pacotes não 
      podem saber quais dispositivos USB serão conectados ao sistema 
      operacional convidado.  Você pode, ou escrever você mesmo(a) 
      regras do udev separadas para todos os dispositivos USB 
      necessários; ou usar o grupo padrão abrangente "usb", membros do 
      qual podem enviar comandos arbitrários para todos os dispositivos 
      USB.

    </para>

    <para>

      Antes do Linux-2.6.15, o acesso de dispositivo USB cru era 
      realizado não com nós de dispositivo /dev/bus/usb/BBB/DDD, porém 
      com pseudo arquivos /proc/bus/usb/BBB/DDD.  Alguns aplicativos 
      (por exemplo, o VMware Workstation) ainda usam somente essa 
      técnica obsoleta e não conseguem usar os novos nós de dispositivo.  
      Para eles funcionarem, use o grupo "usb", porém lembre-se de que 
      os(as) membros(as) terão acesso irrestrito a todos os dispositivos 
      USB.  Para criar a entrada fstab para o obsoleto sistema de 
      arquivos usbfs:

    </para>

<screen><literal>usbfs  /proc/bus/usb  usbfs  devgid=14,devmode=0660  0  0</literal></screen>

    <note>

      <para>

        Adicionar usuários(as) ao grupo "usb" é inerentemente inseguro, 
        já que eles(as) conseguem contornar as restrições de acesso 
        impostas por intermédio dos nós de dispositivo USB específicos 
        do controlador.  Por exemplo, eles(as) conseguem ler dados 
        sensíveis a partir de unidades rígidas USB sem estarem no grupo 
        "disk".  Evite adicionar usuários(as) a esse grupo, se puder.

      </para>

    </note>

  </sect2>

  <sect2>
    <title>Atributos de Dispositivo do Udev</title>

    <para>

      O ajuste fino dos atributos de dispositivo, tais como nome e 
      permissões do grupo, é possível criando-se regras extras do 
      <application>udev</application>, casando com algo como isto.  O 
      fornecedor e produto pode ser encontrado procurando-se nas 
      entradas do diretório
<filename class='directory'>/sys/devices</filename> ou usando-se o 
      <command>udevadm info</command> depois que o dispositivo tenha 
      sido anexado.  Veja-se a documentação no diretório do 
      <application>udev</application> atual do
<filename class='directory'>/usr/share/doc</filename> para detalhes.

    </para>

<screen><literal>SUBSYSTEM=="usb_device", SYSFS{idVendor}=="05d8", SYSFS{idProduct}=="4002", \
  GROUP:="scanner", MODE:="0660"</literal></screen>

    <note>

      <para>

        A linha acima é usada somente para propósitos descritivos.  As 
        regras do <application>udev</application> do escaneador são 
        colocadas no lugar quando se instalar o <xref linkend='sane'/>.

      </para>

    </note>

  </sect2>

<!--
  <sect2>
    <title>Múltiplas Interfaces de Rede</title>


  </sect2>
-->

<!-- Essas instruções são inválidas no systemd, pois nós não usamos 
scripts de inicialização.  Adicionalmente, nós provavelmente deveriamos 
verificar se essas são válidas no SysV também.-->

  <sect2 revision="sysv">
    <title>Dispositivos para Servidores</title>

    <para>

      Em alguns casos, faz sentido desabilitar o 
      <application>udev</application> completamente e criar dispositivos 
      estáticos.  Servidores são um exemplo dessa situação.  Um servidor 
      precisa da capacidade de manusear dispositivos dinâmicos?  Somente 
      o(a) administrador(a) do sistema pode responder a essa pergunta, 
      porém, em muitos casos, a resposta será não.

    </para>

    <para>

      Se dispositivos dinâmicos não são desejados, então dispositivos 
      estáticos precisam ser criados no sistema.  Na configuração 
      padrão, o script de inicialização 
      <filename>/etc/rc.d/rcS.d/S10udev</filename> monta uma partição 
      <systemitem class="filesystem">tmpfs</systemitem> sobre o 
      diretório <filename class="directory">/dev</filename>.  Esse 
      problema pode ser ultrapassado montando-se a partição raiz 
      temporariamente:

    </para>

    <warning>

      <para>

        Se as instruções abaixo não forem seguidas cuidadosamente, 
        [então] o seu sistema poderia se tornar não inicializável.

      </para>

    </warning>

<screen><userinput>mount --bind / /mnt
cp -a /dev/* /mnt/dev
rm /etc/rc.d/rcS.d/{S10udev,S50udev_retry}
umount /mnt</userinput></screen>

    <para>

      Neste ponto, o sistema usará dispositivos estáticos até a próxima 
      reinicialização.  Crie quaisquer dispositivos adicionais desejados 
      usando o <command>mknod</command>.

    </para>

    <para>

      Se você quiser restaurar os dispositivos dinâmicos, [então] recrie 
      os vínculos simbólicos 
      <filename>/etc/rc.d/rcS.d/{S10udev,S50udev_retry}</filename> e 
      reinicialize novamente.  Dispositivos estáticos não precisam ser 
      removidos (console e null sempre são necessários), pois eles são 
      cobertos pela partição
<systemitem class="filesystem">tmpfs</systemitem>.  O uso do disco para 
      dispositivos é desprezível (cerca de 20&ndash;30 bytes por 
      entrada).

    </para>

  </sect2>

  <sect2 id="dev-dvd">
    <title>Dispositivos para Unidades de DVD</title>

    <para>

      Se o processo inicial da inicialização não configurar o 
      dispositivo <systemitem>/dev/dvd</systemitem> adequadamente, 
      [então] ele pode ser instalado usando-se a seguinte modificação 
      para as regras padrão do udev.  Como o(a) usuário(a)
<systemitem class="username">root</systemitem>, execute:

    </para>

<screen><userinput>sed '1d;/SYMLINK.*cdrom/ a\
KERNEL=="sr0", ENV{ID_CDROM_DVD}=="1", SYMLINK+="dvd", OPTIONS+="link_priority=-100"' \
/lib/udev/rules.d/60-cdrom_id.rules > /etc/udev/rules.d/60-cdrom_id.rules</userinput></screen>

  </sect2>

</sect1>
