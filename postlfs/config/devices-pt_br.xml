<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="postlfs-devices" xreflabel="Acerca de Dispositivos">
  <?dbhtml filename="devices-pt_br.html"?>

  <sect1info>
    <date>$Date$</date>
  </sect1info>

  <title>Acerca de Dispositivos</title>

  <indexterm zone="postlfs-devices">
    <primary sortas="e-etc-udev-rules">/etc/udev/rules.d</primary>
  </indexterm>

  <para>

    Apesar da maioria dos dispositivos necessitados pelos pacotes no 
    BLFS e além serem configurados adequadamente pelo 
    <application>udev</application> usando as regras padrão instaladas 
    pelo LFS em
<filename class="directory">/etc/udev/rules.d</filename>, existem casos onde 
    as regras precisam ser modificadas ou estendidas.

  </para>

  <para condition="html" role="usernotes">

    Observações de Usuário(a): <ulink url="&blfs-wiki;/aboutdevices"/>

  </para>

  <sect2>
    <title>Múltiplas Placas de Som</title>

    <para>

      Se existirem múltiplas placas de som em um sistema, [então] a 
      placa de som "padrão" se torna aleatória.  O método para 
      estabelecer a ordem da placa de som depende se os controladores 
      são módulos ou não.  Se os controladores da placa de som forem 
      compilados internamente ao kernel, [então] o controle é via 
      parâmetros de linha de comando do kernel em 
      <filename>/boot/grub/grub.cfg</filename>.  Por exemplo, se um 
      sistema tiver ambas, uma placa FM801 e uma placa PCI SoundBlaster, 
      [então] o seguinte pode ser acrescentado à linha de comando:

    </para>

<screen><literal>snd-fm801.index=0 snd-ens1371.index=1</literal></screen>

    <para>

      Se os controladores da placa de som forem construídos como 
      módulos, [então] a ordem pode ser estabelecida no arquivo 
      <filename>/etc/modprobe.conf</filename> com:

    </para>

<screen><literal>options snd-fm801 index=0
options snd-ens1371 index=1</literal></screen>

  </sect2>

  <sect2 id="usb-device-issues">
    <title>Consequências do Dispositivo USB</title>

    <para>

      Os dispositivos USB geralmente tem dois tipos de nós de 
      dispositivo associados com eles.

    </para>

    <para>

      O primeiro tipo é criado pelos controladores específicos do 
      dispositivo (por exemplo, usb_storage/sd_mod ou usblp) no kernel.  
      Por exemplo, um dispositivo USB de armazenamento em massa seria 
      /dev/sdb; e uma impressora USB seria /dev/usb/lp0.  Esses nós de 
      dispositivo somente existem quando o controlador específico do 
      dispositivo estiver carregado.

    </para>

    <para>

      O segundo tipo de nós de dispositivo (/dev/bus/usb/BBB/DDD, onde 
      BBB é o número do barramento e DDD é o número do dispositivo) é 
      criado mesmo se o dispositivo não tiver um controlador de kernel.  
      Ao usar esses nós de dispositivo USB "crus", uma aplicação pode 
      trocar pacotes USB arbitrários com o dispositivo, isto é, 
      contornar o possivelmente existente controlador de kernel.

    </para>

    <para>

      O acesso a nós de dispositivo USB crus é necessário quando um 
      aplicativo do espaço do(a) usuário(a) estiver atuando como um 
      controlador de dispositivo.  Entretanto, para o aplicativo abrir o 
      dispositivo com sucesso, as permissões devem ser configuradas 
      corretamente.  Por padrão, devido a motivos de segurança, todos os 
      dispositivos USB crus são de propriedade do(a) usuário(a) root e 
      do grupo usb; e tem permissões 0664 (o acesso de leitura é 
      necessário, por exemplo, para o lsusb funcionar e para os 
      aplicativos acessarem hubs USB).  Os pacotes (tais como SANE e 
      libgphoto2) contendo controladores de dispositivo USB do espaço 
      do(a) usuário(a) também embarcam regras do udev que mudam as 
      permissões dos dispositivos USB crus controlados.  Isto é, as 
      regras instaladas pelo SANE mudam as permissões para escaneadores 
      conhecidos, porém não para impressoras.  Se um(a) mantenedor(a) de 
      pacote se esqueceu de escrever uma regra para o seu dispositivo, 
      [então] relate um defeito para ambos, o BLFS (se o pacote estiver 
      lá) e o(a) desenvolvedor(a), e você precisará escrever sua própria 
      regra.

    </para>





    <para>
      There is one situation when such fine-grained access control with
      pre-generated udev rules doesn't work. Namely, PC emulators such as KVM,
      QEMU and VirtualBox use raw USB device nodes to present arbitrary USB
      devices to the guest operating system (note: patches are needed in order
      to get this to work without the obsolete /proc/bus/usb mount point
      described below). Obviously, maintainers of these packages cannot know
      which USB devices are going to be connected to the guest operating
      system. You can either write separate udev rules for all needed USB
      devices yourself, or use the default catch-all "usb" group, members
      of which can send arbitrary commands to all USB devices.
    </para>

    <para>
      Before Linux-2.6.15, raw USB device access was performed not with
      /dev/bus/usb/BBB/DDD device nodes, but with /proc/bus/usb/BBB/DDD
      pseudofiles. Some applications (e.g., VMware Workstation) still use only
      this deprecated technique and can't use the new device nodes. For them to
      work, use the "usb" group, but remember that members will have
      unrestricted access to all USB devices.  To create the fstab entry for
      the obsolete usbfs filesystem:
    </para>

<screen><literal>usbfs  /proc/bus/usb  usbfs  devgid=14,devmode=0660  0  0</literal></screen>

    <note>
      <para>
        Adding users to the "usb" group is inherently insecure, as they can
        bypass access restrictions imposed through the driver-specific USB
        device nodes. For instance, they can read sensitive data from USB
        hard drives without being in the "disk" group. Avoid adding users
        to this group, if you can.
    </para>
    </note>

  </sect2>

  <sect2>
    <title>Udev Device Attributes</title>

    <para>
      Fine-tuning of device attributes such as group name and permissions
      is possible by creating extra <application>udev</application> rules,
      matching on something like this. The vendor and product can be found by
      searching the <filename class='directory'>/sys/devices</filename>
      directory entries or using <command>udevadm info</command> after the
      device has been attached. See the documentation in the current
      <application>udev</application> directory of <filename
      class='directory'>/usr/share/doc</filename> for details.
    </para>

<screen><literal>SUBSYSTEM=="usb_device", SYSFS{idVendor}=="05d8", SYSFS{idProduct}=="4002", \
  GROUP:="scanner", MODE:="0660"</literal></screen>

    <note>
      <para>
        The above line is used for descriptive purposes only. The
        scanner <application>udev</application> rules are put into place when
        installing <xref linkend='sane'/>.
      </para>
    </note>

  </sect2>

<!--
  <sect2>
    <title>Multiple Network Interfaces</title>


  </sect2>
-->

<!-- These instructions are invalid on systemd because we don't use bootscripts.
     In addition, we should probably verify that these are valid on SysV too.-->

  <sect2 revision="sysv">
    <title>Devices for Servers</title>

    <para>
      In some cases, it makes sense to disable
      <application>udev</application> completely and create static devices.
      Servers are one example of this situation.  Does a server need the
      capability of handling dynamic devices?  Only the system administrator
      can answer that question, but in many cases the answer will be no.
    </para>

    <para>
      If dynamic devices are not desired, then static devices must be
      created on the system.  In the default configuration, the
      <filename>/etc/rc.d/rcS.d/S10udev</filename> boot script mounts a
      <systemitem class="filesystem">tmpfs</systemitem> partition over the
      <filename class="directory">/dev</filename> directory. This problem can
      be overcome by mounting the root partition temporarily:
    </para>

    <warning>
      <para>
        If the instructions below are not followed carefully, your
        system could become unbootable.
      </para>
    </warning>


<screen><userinput>mount --bind / /mnt
cp -a /dev/* /mnt/dev
rm /etc/rc.d/rcS.d/{S10udev,S50udev_retry}
umount /mnt</userinput></screen>

    <para>
      At this point, the system will use static devices upon the next
      reboot.  Create any desired additional devices using
      <command>mknod</command>.
    </para>

    <para>
      If you want to restore the dynamic devices, recreate the
      <filename>/etc/rc.d/rcS.d/{S10udev,S50udev_retry}</filename> symbolic
      links and reboot again.  Static devices do not need to be removed
      (console and null are always needed) because they are covered by the
      <systemitem class="filesystem">tmpfs</systemitem> partition.  Disk
      usage for devices is negligible (about 20&ndash;30 bytes per entry.)
    </para>

  </sect2>

  <sect2 id="dev-dvd">
    <title>Devices for DVD Drives</title>

    <para>
      If the initial boot process does not set up the
      <systemitem>/dev/dvd</systemitem> device properly, it can
      be installed using the following modification to the default udev rules.
      As the <systemitem class="username">root</systemitem> user, run:
    </para>

<screen><userinput>sed '1d;/SYMLINK.*cdrom/ a\
KERNEL=="sr0", ENV{ID_CDROM_DVD}=="1", SYMLINK+="dvd", OPTIONS+="link_priority=-100"' \
/lib/udev/rules.d/60-cdrom_id.rules > /etc/udev/rules.d/60-cdrom_id.rules</userinput></screen>

  </sect2>

</sect1>
