<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<!--

Direitos autorais (Copyright) da versão modificada traduzida para a 
língua portuguesa escrita e falada no Brasil: (c) 2022, 2023 Jamenson 
Ferreira Espindula de Almeida Melo (<jafesp@gmail.com>).

  Este trabalho de tradução do livro "Beyond Linux From Scratch" é 
  classificado pela Free Software Foundation como sendo uma "versão 
  modificada" do mencionado livro.  Em assim sendo, na qualidade de 
  tradutor, produtor da "versão modificada" e titular dos direitos 
  autorais sobre a versão traduzida para a língua portuguesa do livro 
  "Beyond Linux From Scratch", concede-se a seguinte permissão:

  É concedida permissão para copiar, distribuir e (ou) modificar este 
  livro "Beyond Linux From Scratch", versão traduzida para a língua 
  portuguesa, sob os termos da Licença de Documentação Livre GNU, versão 
  1.3 ou qualquer versão posterior publicada pela Free Software 
  Foundation; sem Seções Invariantes, sem Textos de Capa Frontal e sem 
  Textos de Quarta Capa.  Uma cópia da licença está incluída na seção 
  intitulada "Licença de Documentação Livre GNU".
  
# Atenção: todos os documentos aqui publicados são distribuídos sem qualquer garantia, implícita e (ou) explícita.
  
  Permission is granted to copy, distribute and (or) modify this book 
  "Beyond Linux From Scratch", translated into Brazilian Portuguese, 
  under the terms of the GNU Free Documentation License, Version 1.3 or 
  any later version published by the Free Software Foundation; with no 
  Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A 
  copy of the license is included in the section entitled "GNU Free 
  Documentation License".

# Warning: all the files herein published are released with no warranty, implicit and (or) explicit.

-->

<sect1 id="postlfs-firmware" xreflabel="Acerca de Firmware">
  <?dbhtml filename="firmware-pt_br.html"?>

  <sect1info>
    <date>$Date$</date>
  </sect1info>

  <title>Acerca de Firmware</title>

  <indexterm zone="postlfs-firmware">
    <primary sortas="e-lib-firmware">/lib/firmware</primary>
  </indexterm>

  <para>

    Em alguns PCs recentes, pode ser necessário, ou desejável, carregar 
    firmware para fazer com que trabalhem no melhor deles.  Existe um 
    diretório, <filename class="directory">/lib/firmware</filename>, 
    onde o kernel ou os controladores de kernel procuram por imagens de 
    firmware.

  </para>

  <para>

    Atualmente, a maioria do firmware pode ser encontrada em um 
    repositório <userinput>git</userinput>:
<ulink url="http://git.kernel.org/cgit/linux/kernel/git/firmware/linux-firmware.git/tree/"/>.  
    Por conveniência, o Projeto LFS criou um espelho, atualizado 
    diariamente, onde esses arquivos de firmware podem ser acessados via 
    <userinput>wget</userinput> ou via um navegador da web em
<ulink url="&sources-anduin-http;/linux-firmware/"/>.

  </para>

  <para>

    Para obter o firmware, ou aponte um navegador para um dos 
    repositórios acima e, então, transfira o(s) item(s) que você 
    precisar; ou instale o <xref linkend="git"/> e clone aquele 
    repositório.

  </para>

  <para>

    Para algum outro firmware, particularmente para microcode da Intel e 
    certos dispositivos wifi, o firmware necessário não está disponível 
    no repositório acima.  Algo disso será endereçado abaixo, porém uma 
    busca da Internet pelo firmware necessário de vez em quando é 
    necessária.

  </para>

  <para>

    Os arquivos de firmware convencionalmente são referenciados como 
    blobs, pois você não pode determinar o que eles farão.  Observe que 
    o firmware é distribuído sob diferentes licenças que não permitem 
    desmontagem ou engenharia reversa.

  </para>

  <para>

    Firmware para PCs caem em quatro categorias:

  </para>

  <itemizedlist spacing="compact">

    <listitem>

      <para>

        Atualizações para a CPU contornar erros, geralmente 
        referenciadas como microcode.

      </para>

    </listitem>

    <listitem>

      <para>

        Firmware para controladores de vídeo.  Em máquinas x86, isso é 
        exigido para dispositivos ATI (chips Radeon e AMDGPU); e talvez 
        seja útil para GPUs Intel (Skylake e posteriores) e Nvidia 
        (Kepler e posteriores).

      </para>

      <para>

        Os dispositivos ATI Radeon e AMGPU todos exigem firmware para 
        estarem aptos a usar o KMS (kernel modesetting - a opção 
        preferida), bem como para Xorg.  Para os chips radeon antigos 
        (antes do R600), o firmware ainda está no fonte do kernel.

      </para>

      <para>

        GPUs integradas Intel a partir do Skylake em diante podem usar 
        firmware para GuC (o microcontrolador Graphics) e, também, para 
        o HuC (microcontrolador HEVC/H265, que descarrega para a GPU); e 
        o DMC (Display Microcontroller) para fornecer estados adicionais 
        de baixa energia.  O GuC e o HuC tiveram um histórico duvidoso 
        no kernel e o firmware atualizado pode estar desabilitado por 
        padrão, dependendo da sua versão de kernel.  Maiores detalhes 
        podem ser encontrados em
<ulink url="https://01.org/linuxgraphics/downloads/firmware/">01.org</ulink>; 
        e
<ulink url="https://wiki.archlinux.org/index.php/intel_graphics">Arch linux</ulink>.

      </para>

      <para>

        GPUs Nvidia a partir do Kepler em diante exigem firmware 
        assinado, do contrário o controlador nouveau é incapaz de 
        fornecer aceleração de hardware.  Nvidia agora lançou firmware 
        até o Turing (a maioria, talvez todos, GPUs GTX16xx e RTX20xx) 
        para linux-firmware e os kernels a partir do linux-5.6 deveriam 
        suportá-los, apesar do suporte a Mesa talvez exigir uma versão 
        de desenvolvimento até que o Mesa-20.2 seja lançado.  Observe 
        que os relógios mais rápidos que o padrão não são habilitados 
        pelo firmware lançado.

      </para>

    </listitem>

    <listitem>

      <para>

        Atualizações de firmware para portas cabeadas de rede.  A 
        maioria delas funciona mesmo sem as atualizações, porém 
        provavelmente funcionarão melhor com o firmware atualizado.  
        Para alguns laptops modernos, o firmware para ambos, ethernet 
        cabeado (por exemplo, rtl_nic), e também para dispositivos 
        bluetooth (por exemplo, qca), é <emphasis>exigido</emphasis> 
        antes que a rede cabeada possa ser usada.

      </para>

    </listitem>

    <listitem>

      <para>

        Firmware para outros dispositivos, tais como wifi.  Esses 
        dispositivos não são exigidos para o PC inicializar, porém 
        precisam do firmware antes que esses dispositivos possam ser 
        usados.

      </para>

    </listitem>

  </itemizedlist>

  <note>

    <para>

      Apesar de não necessárias para carregar um blob de firmware, as 
      seguintes ferramentas possivelmente sejam úteis para determinar, 
      obter ou preparar o firmware necessário para a finalidade de 
      carregá-lo no sistema: <xref linkend="cpio"/>;
      <xref linkend="git"/>; <xref linkend="pciutils"/>; e
      <xref linkend="wget"/>

    </para>

  </note>

  <para condition="html" role="usernotes">Observações de Usuário(a):
  <ulink url="&blfs-wiki;/aboutfirmware"/></para>

  <sect2 id="cpu-microcode">
    <title>Atualizações de microcode para CPUs</title>

    <para>

      Em geral, microcode pode ser carregado pelo BIOS ou pela UEFI e 
      poderia ser atualizado atualizando-se para uma versão mais recente 
      daqueles.  No Linux, você também pode carregar o microcode a 
      partir do kernel se estiver usando um processador AMD família 10h 
      ou posterior (introduzido primeiramente no final de 2007); ou um 
      processador Intel a partir de 1998 e posterior (Pentium4, Core, 
      etc), se microcode atualizado tiver sido lançado.  Essas 
      atualizações duram somente até que a máquina seja desligada, de 
      forma que elas precisam ser aplicadas a cada inicialização.

    </para>

    <para>

      A Intel fornece atualizações do microcode dela para os 
      processadores Skylake e posteriores conforme vulnerabilidades 
      novas surjam e forneceu no passado atualizações para processadores 
      a partir do SandyBridge em diante, apesar daqueles não mais serem 
      suportados para correções novas.  Versões novas do firmware AMD 
      são raras e geralmente somente se aplicam a uns poucos modelos, 
      apesar dos(as) fabricantes de placas mãe obterem atualizações 
      extras que talvez atualizem o microcode juntamente com as mudanças 
      para suportar CPUs mais recentes e memória mais rápida.

    </para>

    <para>

      Existem duas maneiras de se carregar o microcode, descritas como 
      'antecipada' e 'atrasada'.  O carregamento antecipado acontece 
      antes que o espaço de usuário(a) tenha sido iniciado; o 
      carregamento atrasado acontece depois que o espaço de usuário(a) 
      foi iniciado.  Não surpreendentemente, o carregamento antecipado é 
      o preferido (veja-se, por exemplo, um comentário explicativo em um 
      commit do kernel anotado em
<ulink url="https://lwn.net/Articles/530346/">x86/microcode: Microcode de carregamento antecipado</ulink>
      no LWN).  Além disso, é necessário se trabalhar em torno de uma
      errata em particular nos processadores iniciais Intel Haswell que
      tinham TSX habilitado.  (Veja-se
<ulink url="http://www.anandtech.com/show/8376/intel-disables-tsx-instructions-erratum-found-in-haswell-haswelleep-broadwellyi/">
Intel Desabilita as Instruções TSX: Errata Encontrada em Haswell, Haswell-E/EP, Broadwell-Y</ulink>).  Sem
      essa atualização, a glibc pode fazer a coisa errada em situações
      incomuns.

    </para>


    <para>

      Ainda é possível forçar manualmente o carregamento atrasado do 
      microcode, seja para testar, seja para evitar ter que 
      reinicializar.  Você precisará reconfigurar seu kernel para ambos 
      os métodos.  As instruções aqui criarão um 
      <filename>.config</filename> do kernel para acomodar o 
      carregamento antecipado, antes de forçar o carregamento atrasado 
      para ver se existe algum microcode.  Se existir, as instruções 
      então te mostram como criar um initrd para o carregamento 
      antecipado.

    </para>

    <para>

      Para confirmar que processador(es) você tem (se mais que um, eles 
      serão idênticos) olhe em /proc/cpuinfo.

    </para>

    <para>

      Se você estiver criando um initrd para atualizar firmware para 
      máquinas diferentes, como uma distribuição faria, [então] vá para 
      baixo até 'Carregamento antecipado do microcode' e concatene todos 
      os blobs Intel para GenuineIntel.bin; ou concatene todos os blobs 
      AMD para AuthenticAMD.bin.  Isso cria um initrd mais largo - para 
      todas as máquinas Intel na atualização 20200609, o tamanho é de 
      três (3,0) MB comparado a tipicamente vinte e quatro (24) KB para 
      uma máquina.

    </para>

    <sect3 id="intel-microcode">
      <title>Microcode Intel para a CPU</title>

      <para>

        O primeiro passo é o de obter a versão mais recente do microcode 
        Intel.  Isso precisa ser feito navegando-se até
<ulink url='https://github.com/intel/Intel-Linux-Processor-Microcode-Data-Files/releases/'/> 
        e baixando-se o arquivo mais recente lá.  Ao tempo da escrita 
        deste texto, a versão mais segura do microcode era 
        microcode-20220207.  Extraia esse arquivo da maneira normal; o 
        microcode está no diretório <filename>intel-ucode</filename>, 
        contendo vários blobs com nomes na forma XX-YY-ZZ.  Existem 
        também vários outros arquivos e as observações de lançamento.

      </para>

      <para>

        No passado, a Intel não fornecia quaisquer detalhes de quais 
        blobs tinham versões mudadas, porém, agora, a observação de 
        lançamento detalha isso.

      </para>

      <para>

        O firmware recente para processadores mais antigos é fornecido 
        para lidar com vulnerabilidades que agora tenham sido tornadas 
        públicas e, para algumas dessas, tais como Microarchitectural 
        Data Sampling (MDS), você poderia desejar aumentar a proteção 
        desabilitando hyperthreading; ou, alternativamente, desabilitar 
        a mitigação padrão do kernel, por causa do impacto dela sobre os 
        tempos de compilação.  Por favor, leia a documentação online em
<ulink url='https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/index.html'/>.

      </para>

      <!-- comentado, eu não penso que existe um item novo listado para 
      as vulnerabilidades 2011-11 (platypus etc : intel-sa-00381 e 0389) 
      e, de qualquer maneira, os lançamentos estáveis muito mais 
      recentes tem portas dos fundos : ken
      <para>
        A documentação acerca das vulnerabilidades/correções SRBDS 
        (Special Register Buffer Data Sampling) mais recentes estará 
        documentada nos kernels 5.4.46, 5.6.18, 5.7.2, 5.8.0 e 
        posteriores.
      </para>-->

      <para>

        Agora você precisa determinar a identidade do seu processador 
        para ver se existe algum microcode para ele.  Determine os 
        valores decimais da família da CPU; do modelo; e da revisão 
        executando o seguinte comando (também relatará a versão atual do 
        microcode):

      </para>

<screen><userinput>head -n7 /proc/cpuinfo</userinput></screen>

      <para>

        Converta a família da CPU; o modelo; e a revisão para pares de 
        dígitos hexadecimais.  Para um Skylake i3 6100 (descrito como 
        Intel(R) Core(TM) i3-6100 CPU) os valores relevantes são família 
        da CPU 6; modelo 94; revisão 3; de forma que, nesse caso, a 
        identificação exigida é 06-5e-03.  Uma olhada nos blobs mostrará 
        que existe um para essa CPU (apesar de para problemas mais 
        antigos poderia já ter sido aplicado pelo BIOS).  Se existir um 
        blob para o seu sistema, então teste se ele será aplicado 
        copiando-o (substitua &lt;XX-YY-ZZ&gt; pelo identificador para a 
        sua CPU) para onde o kernel possa encontrá-lo:

      </para>

<screen><userinput>mkdir -pv /lib/firmware/intel-ucode
cp -v intel-ucode/&lt;XX-YY-ZZ&gt; /lib/firmware/intel-ucode</userinput></screen>

      <para>

        Agora que o microcode Intel foi preparado, use as seguintes 
        opções quando você configurar o kernel para carregar o microcode 
        Intel:

      </para>

<screen><literal>General Setup ---&gt;
  [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support [CONFIG_BLK_DEV_INITRD]
Processor type and features  ---&gt;
  [*] CPU microcode loading support  [CONFIG_MICROCODE]
  [*]      Intel microcode loading support [CONFIG_MICROCODE_INTEL]</literal></screen>

      <para>

        Depois que você tiver inicializado com sucesso o sistema novo, 
        force o carregamento atrasado usando o comando:

      </para>

<screen><userinput>echo 1 > /sys/devices/system/cpu/microcode/reload</userinput></screen>

      <para>

        Então use o seguinte comando para ver se alguma coisa foi 
        carregada: (observe bem: as datas quando o microcode foi criado 
        possivelmente estejam meses antes de quando foi lançado)

      </para>

<screen><userinput>dmesg | grep -e 'microcode' -e 'Linux version' -e 'Command line'</userinput></screen>

      <para>

        Este exemplo antigo mostrando a versão muito antiga do firmware 
        do BIOS foi criada para inicializar temporariamente sem 
        microcode, para mostrar as mensagens atuais dos Defeitos do 
        Firmware; então o carregamento atrasado mostra ele sendo 
        atualizado para a revisão 0xea, que era atual naquela época.

      </para>

<screen><literal>[    0.000000] Linux version 5.12.8 (lfs@leshp) (gcc (GCC) 11.1.0,
               GNU ld (GNU Binutils) 2.36.1)
               #2 SMP PREEMPT Fri Jun 4 01:25:02 BST 2021
[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-5.12.8-sda11 root=/dev/sda11 ro
               resume=/dev/sda10
[    0.028741] [Firmware Bug]: TSC_DEADLINE disabled due to Errata;
               please update microcode to version: 0xb2 (or later)
[    0.115716] SRBDS: Vulnerable: No microcode
[    0.115826] MDS: Vulnerable: Clear CPU buffers attempted, no microcode
[    0.389005] microcode: sig=0x506e3, pf=0x2, revision=0x74
[    0.389030] microcode: Microcode Update Driver: v2.2.
[   70.089502] microcode: updated to revision 0xea, date = 2021-01-25
[   70.089528] x86/CPU: CPU features have changed after loading microcode,
               but might not take effect.
[   70.089530] microcode: Reload completed, microcode revision: 0xea</literal></screen>

      <para>

        Se o microcode não foi atualizado, [então] não existe microcode 
        novo para esse processador do sistema.  Se ele foi atualizado, 
        [então] você agora pode continuar para o
        <xref linkend='early-microcode'/>.

      </para>

    </sect3>

    <sect3 id="amd-microcode">
      <title>Microcode AMD para a CPU</title>

      <para>

        Comece baixando um contêiner do firmware para a família da sua 
        CPU a partir de
        <ulink url='&sources-anduin-http;/linux-firmware/amd-ucode/'/>.  A 
        família sempre é especificada em hexadecimal.  As famílias 10h 
        até 14h (16 até 20) estão no microcode_amd.bin.  As famílias 
        15h, 16h e 17h tem os contêineres próprios delas.  Crie o 
        diretório exigido e coloque o firmware que você baixou nele, 
        como o(a) usuário(a)
        <systemitem class="username">root</systemitem>:

      </para>

<screen><userinput>mkdir -pv /lib/firmware/amd-ucode
cp -v microcode_amd* /lib/firmware/amd-ucode</userinput></screen>

      <para>

        Quando você configurar o kernel, use as seguintes opções para 
        carregar o microcode AMD:

      </para>

<screen><literal>General Setup ---&gt;
  [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support [CONFIG_BLK_DEV_INITRD]
Processor type and features  ---&gt;
  [*] CPU microcode loading support  [CONFIG_MICROCODE]
  [*]      AMD microcode loading support [CONFIG_MICROCODE_AMD]</literal></screen>

      <para>

        Depois que você tiver inicializado com sucesso o novo sistema, 
        force o carregamento atrasado usando o comando:

      </para>

<screen><userinput>echo 1 > /sys/devices/system/cpu/microcode/reload</userinput></screen>

      <para>

        Então, use o seguinte comando para ver se alguma coisa foi 
        carregada:

      </para>

<screen><userinput>dmesg | grep -e 'microcode' -e 'Linux version' -e 'Command line'</userinput></screen>

      <para>

        Este exemplo histórico originário de um antigo Athlon(tm) II X2 
        mostra que foi atualizado.  Naquela época, todas as CPUs ainda 
        eram relatadas nos detalhes do microcode em máquinas AMD (a 
        posição atual para máquinas AMD onde microcode mais recente está 
        disponível é desconhecida):

      </para>

<screen><literal>[    0.000000] Linux version 4.15.3 (ken@testserver) (gcc version 7.3.0 (GCC))
               #1 SMP Sun Feb 18 02:08:12 GMT 2018
[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-4.15.3-sda5 root=/dev/sda5 ro
[    0.307619] microcode: CPU0: patch_level=0x010000b6
[    0.307671] microcode: CPU1: patch_level=0x010000b6
[    0.307743] microcode: Microcode Update Driver: v2.2.
[  187.928891] microcode: CPU0: new patch_level=0x010000c8
[  187.928899] microcode: CPU1: new patch_level=0x010000c8</literal></screen>

      <para>

        Se o microcode não foi atualizado, [então] não existe microcode 
        novo para este processador do sistema.  Se ele foi atualizado, 
        [então] você agora pode continuar para o
        <xref linkend='early-microcode'/>.

      </para>

    </sect3>

    <sect3 id="early-microcode">
      <title>Carregamento antecipado do microcode</title>

      <para>

        Se você tiver estabelecido que o microcode atualizado está 
        disponível para o seu sistema, [então] é hora de prepará-lo para 
        o carregamento antecipado.  Isso exige um pacote adicional, o 
        <xref linkend='cpio'/> e a criação de um initrd que precisará 
        ser adicionado ao grub.cfg.

      </para>

      <para>

        Não importa onde você prepara o initrd e, tão logo ele esteja 
        funcionando, você pode aplicar o mesmo initrd a sistemas LFS 
        posteriores ou a kernels mais recentes na mesma máquina, ao 
        menos até que algum microcode mais recente seja liberado.  Use 
        os seguintes comandos:

      </para>

<screen><userinput>mkdir -p initrd/kernel/x86/microcode
cd initrd</userinput></screen>

      <para>

        Para uma máquina AMD, use o seguinte comando (substitua 
        &lt;MEUCONTEINER&gt; pelo nome do contêiner para a família da 
        sua CPU):

      </para>

<screen><userinput>cp -v /lib/firmware/amd-ucode/&lt;MEUCONTEINER&gt; kernel/x86/microcode/AuthenticAMD.bin</userinput></screen>

      <para>

        Ou, para uma máquina Intel, copie o blob apropriado usando este 
        comando:

      </para>

<screen><userinput>cp -v /lib/firmware/intel-ucode/&lt;XX-YY-ZZ&gt; kernel/x86/microcode/GenuineIntel.bin</userinput></screen>

<!-- a versão nova a partir do lançamento 20201110 em diante, assumiu 
funcionar em todos os Skylakes, porém as reclamações acerca da versão 
anterior tomam alguns dias para aparecer; portanto, mantenha como um 
comentário por agora.

      <caution>

        <para>

          Em algumas máquinas Skylake com Número de Modelo hexadecimal 
          '4e' (78 em decimal) a atualização para a versão de microcode 
          '0xdc' é relatada causar a máquina travar na inicialização 
          antecipada e a correção é a de reverter para a versão 0xd6, 
          que primeiro foi embarcada no lançamento de microcode 
          20191115.

        </para>

        <para>

          Ao menos um modelo '5e' Skylake inicializa com sucesso com a 
          versão 0xdc, porém a Intel agora embarcou um lançamento 
          20200616 que é concebido para distribuições que precisam de um 
          initrd que inicializará na máquina de todos(as): ele reverte 
          ambas as variantes Skylake ('4e' e '5e') para o antigo 0xd6.

        </para>

        <para>

          Para um Skylake que não inicializa com 0xdc, reverter para 
          0xd6 tornará a máquina utilizável, porém sem as mitigações 
          SRBDS.

        </para>

      </caution>-->

      <para>

        Agora, prepare o initrd:

      </para>

<screen><userinput>find . | cpio -o -H newc &gt; /boot/microcode.img</userinput></screen>

      <para>

        Agora você precisa adicionar uma entrada nova a 
        /boot/grub/grub.cfg e aqui você deveria adicionar uma linha nova 
        depois da linha linux dentro da estância.  Se /boot for um ponto 
        de montagem separado:

      </para>

<screen><userinput>initrd /microcode.img</userinput></screen>

      <para>

        ou isto, se ele não for:

      </para>

<screen><userinput>initrd /boot/microcode.img</userinput></screen>

      <para>

        Se já estiver inicializando com um initrd (veja-se
        <xref linkend="initramfs"/>), [então] você deveria executar 
        <command>mkinitramfs</command> novamente depois de colocar o 
        blob ou contêiner apropriado no
        <filename class="directory">/lib/firmware</filename> conforme
        explicado acima.  Alternativamente, você pode ter ambos os
        initrd na mesma linha, assim
<userinput>initrd /microcode.img /outro-initrd.img</userinput>
        (adapte isso conforme acima se /boot não for um ponto de
        montagem separado).

      </para>

      <para>

        Você agora pode reinicializar com o initrd adicionado e, então, 
        usar o mesmo comando para verificar se o carregamento antecipado 
        funcionou:

      </para>

<screen><userinput>dmesg | grep -e 'microcode' -e 'Linux version' -e 'Command line'</userinput></screen>

      <para>

        Se atualizou para endereçar vulnerabilidades, [então] você pode 
        olhar no
<filename class="directory">/sys/devices/system/cpu/vulnerabilities/</filename> 
        para ver o que agora está relatado.

      </para>

      <para>

        Os locais e horários onde o carregamento antecipado acontece são 
        muito diferentes em máquinas AMD e Intel.  Primeiro, um exemplo 
        antigo de uma Intel (Skylake) com carregamento antecipado:

      </para>

<screen><literal>[    0.000000] microcode: microcode updated early to revision 0xea, date = 2021-01-25
[    0.000000] Linux version 5.12.8 (lfs@leshp) (gcc (GCC) 11.1.0,
               GNU ld (GNU Binutils) 2.36.1) #2 SMP PREEMPT Fri Jun 4 01:25:02 BST 2021
[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-5.12.8-sda11 root=/dev/sda11 ro
               resume=/dev/sda10
[    0.381420] microcode: sig=0x506e3, pf=0x2, revision=0xea
[    0.381479] microcode: Microcode Update Driver: v2.2.</literal></screen>

      <para>

        Um exemplo histórico AMD:

      </para>

<screen><literal>[    0.000000] Linux version 4.15.3 (ken@testserver) (gcc version 7.3.0 (GCC))
               #2 SMP Sun Feb 18 02:32:03 GMT 2018
[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-4.15.3-sda5 root=/dev/sda5 ro
[    0.307619] microcode: microcode updated early to new patch_level=0x010000c8
[    0.307678] microcode: CPU0: patch_level=0x010000c8
[    0.307723] microcode: CPU1: patch_level=0x010000c8
[    0.307795] microcode: Microcode Update Driver: v2.2.</literal></screen>

    </sect3>

  </sect2>

  <sect2 id="video-firmware">
    <title>Firmware para Placas de Vídeo</title>

    <sect3 id="ati-video-firmware">
      <title>Firmware para chips de vídeo ATI (R600 e posteriores)</title>

      <para>

        Estas instruções não se aplicam aos antigos radeons antes da 
        família R600.  Para aqueles, o firmware está no diretório do 
        kernel <filename class='directory'>/lib/firmware/</filename>.  
        Nem se aplicam se você pretender evitar uma configuração gráfica 
        como o Xorg e estiver contente em usar a exibição padrão de 
        80x25 em vez de um framebuffer.

      </para>

      <para>

        Os dispositivos iniciais radeon precisavam somente de um blob de 
        firmware de 2K.  Os dispositivos recentes precisam de vários 
        blobs e alguns deles são muito maiores.  O tamanho total do 
        diretório do firmware radeon é de mais que 500K &mdash; em um 
        sistema largo moderno você provavelmente pode poupar o espaço, 
        porém ainda é redundante instalar todos os arquivos não usados a 
        cada vez que construir um sistema.

      </para>

      <para>

        Uma abordagem melhor é a de instalar o
        <xref linkend='pciutils'/> e, então, usar o 
        <userinput>lspci</userinput> para identificar qual controlador 
        VGA está instalado.

      </para>

      <para>

        Com essa informação, verifique a página RadeonFeature da wiki do 
        Xorg para
<ulink url="http://wiki.x.org/wiki/RadeonFeature/#index5h2">Anel decodificador para nomes de engenharia x nomes de comercialização</ulink>
        para identificar a família (você possivelmente precise saber
        disso para o controlador Xorg no BLFS &mdash; Ilhas do Sul e
        Ilhas do Mar usam o controlador radeonsi) e o modelo específico.

      </para>

      <para>

        Agora que você sabe qual controlador está usando, consulte a 
        página
<ulink url="https://wiki.gentoo.org/wiki/Radeon#Firmware">Radeon</ulink> 
        da wiki do Gentoo a qual tem uma tabela listando os blobs de 
        firmware exigidos para os vários chipsets.  Observe que os chips 
        das Ilhas do Sul e os das Ilhas do Mar usam firmware diferente 
        para o kernel 3.17 e posteriores comparados a kernels 
        anteriores.  Identifique e baixe os blobs exigidos; então 
        instale-os:

      </para>

<screen><userinput>mkdir -pv /lib/firmware/radeon
cp -v &lt;SEUS_BLOBS&gt; /lib/firmware/radeon</userinput></screen>

      <para>

        Atualmente existem duas maneiras de instalar esse firmware.  No 
        BLFS, na seção 'Configuração do Kernel para firmware adicional', 
        parte da seção <xref linkend="xorg-ati-driver"/> dá um exemplo 
        de compilar o firmware no kernel - isso é ligeiramente mais 
        rápido de carregar, porém usa mais memória do kernel.  Aqui nós 
        usaremos o método alternativo de fazer do controlador radeon um 
        módulo.  No seu config do kernel, configure o seguinte:

      </para>

<screen><literal>Device Drivers ---&gt;
  Graphics support ---&gt;
      Direct Rendering Manager ---&gt;
        [*] Direct Rendering Manager (XFree86 ... support)  [CONFIG_DRM]
      [M] ATI Radeon                                        [CONFIG_DRM_RADEON]</literal></screen>

      <para>

        O carregamento de vários blobs largos a partir de /lib/firmware 
        toma um tempo notável, durante o qual a tela estará sem escrito.  
        Se você não habilitar o logotipo de framebuffer pinguim ou mudar 
        o tamanho do console usando uma fonte maior, [então] 
        provavelmente isso não importa.  Se desejado, você pode reduzir 
        ligeiramente o tempo se seguir o método alternativo de 
        especificar 'y' para CONFIG_DRM_RADEON coberto no BLFS no link 
        acima &mdash; você precisa especificar cada blob radeon 
        necessário se fizer isso.

      </para>

    </sect3>

    <sect3 id="nvidia-video-firmware">
      <title>Firmware para chips de vídeo Nvidia</title>

      <para>

        Alguns chips gráficos Nvidia precisam de atualizações de 
        firmware para tirar proveito de toda a capacidade da placa.  
        Geralmente esses são os chips das séries GeForce 8, 9, 9300 e 
        200-900.  Para informação mais exata, veja-se
<ulink url="https://nouveau.freedesktop.org/wiki/VideoAcceleration/#firmware"/>.

      </para>

      <para>

        Primeiro, o controlador de kernel Nvidia precisa ser ativado:

      </para>

<screen><literal>Device Drivers ---&gt;
  Graphics support ---&gt;
      Direct Rendering Manager ---&gt;
        &lt;*&gt; Direct Rendering Manager (XFree86 ... support)  [CONFIG_DRM]
      &lt;*/M&gt; Nouveau (NVIDIA) cards                          [CONFIG_DRM_NOUVEAU]</literal></screen>

      <para>

        Os passos para instalar o firmware Nvidia são:

      </para>

<screen><userinput>wget https://raw.github.com/imirkin/re-vp2/master/extract_firmware.py
wget http://us.download.nvidia.com/XFree86/Linux-x86/325.15/NVIDIA-Linux-x86-325.15.run
sh NVIDIA-Linux-x86-325.15.run --extract-only
python extract_firmware.py
mkdir -p /lib/firmware/nouveau
cp -d nv* vuc-* /lib/firmware/nouveau/</userinput></screen>

    </sect3>

  </sect2>

  <sect2 id="nic-firmware">
    <title>Firmware para Interfaces de Rede</title>

    <para>

      O kernel gosta de carregar firmware para alguns controladores de 
      rede, particularmente aqueles originários do diretório da Realtek 
      (o /lib/linux-firmware/rtl_nic/), porém geralmente eles aparentam 
      funcionar sem isso.  Sendo assim, você pode inicializar o kernel; 
      verificar dmesg para mensagens acerca desse firmware ausente; e, 
      se necessário, baixar o firmware e colocá-lo no diretório 
      especificado no
      <filename class="directory">/lib/firmware</filename>, de forma
      que ele será encontrado nas inicializações subsequentes.  Observe
      que, com os kernels atuais, isso funciona se ou não o controlador
      for compilado internamente ou construído como um módulo; não existe 
      necessidade de construir esse firmware internamente ao kernel.  
      Aqui está um exemplo onde o controlador R8169 foi compilado 
      internamente, porém o firmware não foi tornado disponível.  Tão 
      logo o firmware tenha sido fornecido, não existiu menção dele nas 
      inicializações posteriores.

    </para>

<screen><literal>dmesg | grep firmware | grep r8169
[    7.018028] r8169 0000:01:00.0: Direct firmware load for rtl_nic/rtl8168g-2.fw failed with error -2
[    7.018036] r8169 0000:01:00.0 eth0: unable to load firmware patch rtl_nic/rtl8168g-2.fw (-2)</literal></screen>

  </sect2>

  <sect2 id="other-firmware">
    <title>Firmware para Outros Dispositivos</title>

    <para>

      Identificar o firmware correto tipicamente exigirá que você 
      instale o <xref linkend='pciutils'/> e, então, use o 
      <userinput>lspci</userinput> para identificar o dispositivo.  Você 
      deveria então procurar online para verificar qual módulo ele usa; 
      qual firmware; e onde obter o firmware &mdash; nem todos eles 
      estão no linux-firmware.

    </para>

    <para>

      Se possível, você deveria iniciar usando uma conexão com fios 
      quando inicializar pela primeira vez o seu sistema LFS.  Para usar 
      uma conexão sem fios, você precisará usar ferramentas de rede, 
      tais como <xref linkend='wireless_tools'/> e
      <xref linkend='wpa_supplicant'/>.

    </para>

    <para>

      Países diferentes tem regulações diferentes acerca do uso do 
      espectro de rádio dos dispositivos sem fios.  Você pode instalar 
      um firmware para fazer com que os dispositivos sem fios obedeçam 
      às regulações locais de espectro, de forma que você não seria 
      questionado(a) pela autoridade local ou não encontraria sua NIC 
      sem fios atrapalhando as frequências de outros dispositivos (por 
      exemplo, controles remotos).  O firmware da base de dados 
      regulatória pode ser baixado a partir de
<ulink url = 'https://kernel.org/pub/software/network/wireless-regdb/'/>.  Para 
      instalá-lo, simplesmente extraia o 
      <filename>regulatory.db</filename> e o 
      <filename>regulatory.db.p7s</filename> a partir do tarball no 
      <filename class="directory">/lib/firmware</filename>.  O ponto de 
      acesso enviaria um código de país para a sua NIC sem fios e o 
      <xref linkend='wpa_supplicant'/> diria ao kernel para carregar a 
      regulação desse país a partir do 
      <filename>regulatory.db</filename>; e impô-la.

    </para>

    <para>

      Firmware possivelmente também seja necessário para outros 
      dispositivos, tais como alguns controladores SCSI; adaptadores 
      bluetooth; ou gravadores de TV.  Os mesmos princípios se aplicam.

    </para>

  </sect2>

</sect1>
