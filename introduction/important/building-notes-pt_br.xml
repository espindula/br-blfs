<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<!--

Direitos autorais (Copyright) da versão modificada traduzida para a 
língua portuguesa escrita e falada no Brasil: (c) 2022 Jamenson Ferreira 
Espindula de Almeida Melo (<jafesp@gmail.com>).

  Este trabalho de tradução do livro "Beyond Linux From Scratch" é 
  classificado pela Free Software Foundation como sendo uma "versão 
  modificada" do mencionado livro.  Em assim sendo, na qualidade de 
  tradutor, produtor da "versão modificada" e titular dos direitos 
  autorais sobre a versão traduzida para a língua portuguesa do livro 
  "Beyond Linux From Scratch", concede-se a seguinte permissão:

  É concedida permissão para copiar, distribuir e (ou) modificar este 
  livro "Beyond Linux From Scratch", versão traduzida para a língua 
  portuguesa, sob os termos da Licença de Documentação Livre GNU, versão 
  1.3 ou qualquer versão posterior publicada pela Free Software 
  Foundation; sem Seções Invariantes, sem Textos de Capa Frontal e sem 
  Textos de Quarta Capa.  Uma cópia da licença está incluída na seção 
  intitulada "Licença de Documentação Livre GNU".
  
# Atenção: todos os documentos aqui publicados são distribuídos sem qualquer garantia, implícita e (ou) explícita.
  
  Permission is granted to copy, distribute and (or) modify this book 
  "Beyond Linux From Scratch", translated into Brazilian Portuguese, 
  under the terms of the GNU Free Documentation License, Version 1.3 or 
  any later version published by the Free Software Foundation; with no 
  Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A 
  copy of the license is included in the section entitled "GNU Free 
  Documentation License".

# Warning: all the files herein published are released with no warranty, implicit and (or) explicit.

-->

<sect1 id="unpacking">
  <?dbhtml filename="notes-on-building-pt_br.html"?>

  <sect1info>
    <date>$Date$</date>
  </sect1info>

  <title>Observações Acerca de Construir Software</title>

  <para>

    Aquelas pessoas que tenham construído um sistema LFS talvez estejam 
    cientes dos princípios gerais da transferência e do desempacotamento 
    de software.  Alguma daquela informação está repetida aqui para 
    aquelas novatas em construir o próprio software delas.

  </para>

  <para>

    Cada conjunto de instruções de instalação contém um URL a partir do 
    qual você pode transferir o pacote.  As correções, no entanto, estão 
    armazenadas nos servidores do LFS e estão disponíveis via HTTP.  
    Essas estão referenciadas conforme necessárias nas instruções de 
    instalação.

  </para>

  <para>

    Enquanto você pode manter os arquivos do fonte em qualquer lugar que 
    queira, nós assumimos que você desempacotou o pacote e mudou para o 
    diretório criado pelo processo de desempacotamento (o diretório de 
    'construção').  Nós assumimos também que você descomprimiu quaisquer 
    correções exigidas e que elas estão no diretório imediatamente acima 
    do diretório de 'construção'.

  </para>

  <para>

    Nós não podemos enfatizar fortemente o suficiente que você deveria 
    iniciar a partir de uma <emphasis>árvore limpa do fonte</emphasis> a 
    cada vez.  Isso significa que, se você tiver tido um erro durante a 
    configuração ou a compilação, [então] geralmente é melhor deletar a 
    árvore do fonte e desempacotá-la outra vez
    <emphasis>antes de</emphasis> tentar novamente.  Isso, obviamente,
    não se aplica se você for um(a) usuário(a) avançado(a) habituado(a)
    a hackear <filename>Makefile</filename>s e código C; porém, se em
    dúvida, [então] inicie a partir de uma árvore limpa.

  </para>

  <sect2>
    <title>Construindo Software como um(a) Usuário(a) Não Privilegiado(a) (não root)</title>

    <para>

      A regra de ouro da Administração do Sistema Unix é a de usar os 
      seus super poderes somente quando necessário.  Assim, o BLFS 
      recomenda que você construa software como um(a) usuário(a) não 
      privilegiado(a) e somente se torne o(a) usuário(a)
      <systemitem class='username'>root</systemitem> quando instalar
      o software.  Essa filosofia é seguida em todos os pacotes neste
      livro.  A menos que especificado de outra maneira, todas as
      instruções deveriam ser executadas como um(a) usuário(a) não
      privilegiado(a).  O livro alertará você acerca de instruções
      que precisarem de privilégios do(a)
      <systemitem class='username'>root</systemitem>.

    </para>

  </sect2>

  <sect2>
    <title>Desempacotando o Software</title>

    <para>

      Se um arquivo estiver no formato
      <filename class='extension'>.tar</filename> e comprimido, [então]
      ele é desempacotado executando-se um dos seguintes comandos:

    </para>

<screen><userinput>tar -xvf nome_do_arquivo.tar.gz
tar -xvf nome_do_arquivo.tgz
tar -xvf nome_do_arquivo.tar.Z
tar -xvf nome_do_arquivo.tar.bz2</userinput></screen>

    <note>

      <para>

        Você talvez omita o uso do parâmetro <option>v</option> nos 
        comandos mostrados acima e abaixo se você desejar suprimir a 
        listagem verbosa de todos os arquivos no arquivamento conforme 
        eles forem extraídos.  Isso pode ajudar a acelerar a extração, 
        bem como torna quaisquer erros produzidos durante a extração 
        mais óbvios para você.

      </para>

    </note>

    <para>Você também pode usar um método ligeiramente diferente:</para>

<screen><userinput>bzcat nome_do_arquivo.tar.bz2 | tar -xv</userinput></screen>

    <para>

      Finalmente, ocasionalmente, você precisa estar apto(a) a 
      desempacotar correções que geralmente não estão no formato 
      <filename class='extension'>.tar</filename>.  A melhor maneira de 
      fazer isso é a de copiar o arquivo da correção para o pai do 
      diretório da 'construção' e, então, executar um dos seguintes 
      comandos, dependendo se o arquivo for um arquivo
      <filename class='extension'>.gz</filename> ou um
      <filename class='extension'>.bz2</filename>:

    </para>

<screen><userinput>gunzip -v nome_da_correcao.gz
bunzip2 -v nome_da_correcao.bz2</userinput></screen>

  </sect2>

  <sect2>
    <title>Averiguando a Integridade do Arquivo</title>

    <para>

      Geralmente, para se averiguar se o arquivo transferido está 
      completo, muitos(as) mantenedores(as) de pacote também distribuem 
      somas de md5 dos arquivos.  Para averiguar a soma de md5 dos 
      arquivos transferidos, transfira ambos, o arquivo e o arquivo 
      correspondente de soma de md5, para o mesmo diretório 
      (preferencialmente a partir de locais diferentes online) e 
      (assumindo que <filename>arquivo.md5sum</filename> seja o arquivo 
      de soma de md5 transferido) execute o seguinte comando:

    </para>

<screen><userinput>md5sum -c arquivo.md5sum</userinput></screen>

    <para>

      Se existirem quaisquer erros, [então] eles serão relatados.  
      Observe que o livro BLFS inclui somas de md5 para todos os 
      arquivos de fonte também.  Para usar as somas de md5 fornecidas 
      pelo BLFS, você pode criar um <filename>arquivo.md5sum</filename> 
      (coloque os dados da soma de md5 e o nome exato do arquivo 
      transferido na mesma linha de um arquivo, separados por espaço em 
      branco) e executar o comando mostrado acima.  Alternativamente, 
      simplesmente execute o comando mostrado abaixo e compare a saída 
      gerada para os dados da soma de md5 mostrada no livro BLFS.

    </para>

<screen><userinput>md5sum <replaceable>&lt;nome_do_arquivo_transferido&gt;</replaceable></userinput></screen>

    <para>

      MD5 não é seguro criptograficamente, de forma que as somas de md5 
      são fornecidas apenas para se detectar mudanças não maliciosas 
      para o conteúdo do arquivo.  Por exemplo, um erro ou truncamento 
      introduzido durante a transferência de rede; ou uma atualização 
      <quote>furtiva</quote> para o pacote oriunda do(a) 
      desenvolvedor(a) (atualizando o conteúdo de um tarball liberado em 
      vez de fazer um lançamento novo adequadamente).

    </para>

    <para>

      Não existe maneira <quote>100%</quote> segura de garantir a 
      genuinidade dos arquivos do fonte.  Assumindo que o(a) 
      desenvolvedor(a) esteja gerenciando corretamente o sítio da web 
      dele(a) (a chave privada não vazou e o domínio não esteja 
      sequestrado); e que as âncoras de confiança tenham sido 
      configuradas corretamente usando <xref linkend="make-ca"/> no 
      sistema BLFS; nós podemos razoavelmente confiar nos URLs de 
      transferência para o sítio oficial da web do(a) desenvolvedor(a) 
      <emphasis role="bold">com protocolo https</emphasis>.  Observe que 
      o próprio livro BLFS está publicado em um sítio da web com https, 
      de forma que você já deveria ter alguma confiança no protocolo 
      https ou você não confiaria no conteúdo do livro.

    </para>

    <para>

      Se o pacote for transferido a partir de um local não oficial (por 
      exemplo, um espelho local), [então] as somas de verificação 
      geradas por algoritmos de resumo criptograficamente seguros (por 
      exemplo, SHA256) podem ser usadas para averiguar a genuinidade do 
      pacote.  Transfira o arquivo da soma de verificação a partir do 
      sítio da web <emphasis role="bold">oficial</emphasis> do(a) 
      desenvolvedor(a) (ou algum lugar que
      <emphasis role="bold">você possa confiar</emphasis>) e compare a
      soma de verificação do pacote oriunda do local não oficial com
      ele.  Por exemplo, a soma de verificação SHA256 pode ser
      verificada com o comando:

    </para>

    <note>

      <para>

        Se a soma de verificação e o pacote forem transferidos a partir 
        do mesmo local não confiável, [então] você não ganharia 
        melhoramento de segurança averiguando o pacote com a soma de 
        verificação.  O(A) atacante pode falsear a soma de verificação 
        assim como comprometer o próprio pacote.

      </para>

    </note>

<screen><userinput>sha256sum -c <replaceable>arquivo</replaceable>.sha256sum</userinput></screen>

    <para>

      Se o <xref linkend="gnupg2"/> estiver instalado, [então] você 
      também pode averiguar a genuinidade do pacote com uma assinatura 
      GPG.  Importe a chave pública GPG do(a) desenvolvedor(a) com:

    </para>

<screen><userinput>gpg --recv-key <replaceable>ID_da_chave</replaceable></userinput></screen>

    <para>

      <replaceable>ID_da_chave</replaceable> deveria ser substituído 
      pelo ID da chave oriundo de algum lugar que
      <emphasis role="bold">você possa confiar</emphasis> (por exemplo,
      copie-o a partir do sítio da web oficial do(a) desenvolvedor(a)
      usando https).  Agora, você pode averiguar a assinatura com:

    </para>

<screen><userinput>gpg --recv-key <replaceable>arquivo</replaceable>.sig <replaceable>arquivo</replaceable></userinput></screen>

    <para>

      A vantagem da assinatura <application>GnuPG</application> é, tão 
      logo você importou uma chave pública que possa ser confiada, você 
      pode transferir ambos, o pacote e a assinatura dele, a partir do 
      mesmo local não oficial e averiguá-los com a chave pública.  
      Assim, você não precisaria conectar com o sítio da web oficial 
      do(a) desenvolvedor(a) para ir buscar uma soma de verificação para 
      cada lançamento novo.  Você somente precisa atualizar a chave 
      pública se ela estiver expirada ou revogada.

    </para>

  </sect2>

  <sect2>
    <title>Criando Arquivos de Registro Durante a Instalação</title>

    <para>

      Para pacotes mais largos, é conveniente se criar arquivos de 
      registro em vez de olhar fixamente para a tela esperando pegar um 
      erro ou aviso em particular.  Os arquivos de registro também são 
      úteis para depuração e para manter registros.  O seguinte comando 
      permite a você criar um registro da instalação.  Substitua 
      <replaceable>&lt;comando&gt;</replaceable> pelo comando que você 
      pretende executar.

    </para>

<screen><userinput>( <replaceable>&lt;comando&gt;</replaceable> 2&gt;&amp;1 | tee compilar.log &amp;&amp; exit $PIPESTATUS )</userinput></screen>

    <para>

      <option>2&gt;&amp;1</option> redireciona as mensagens de erro para 
      o mesmo local que a saída gerada padrão.  O comando 
      <command>tee</command> permite visualizar a saída gerada enquanto 
      se registra os resultados em um arquivo.  Os parênteses em volta 
      do comando executam o comando inteiro em um subshell; e, 
      finalmente, o comando <command>exit $PIPESTATUS</command> garante 
      que o resultado do <replaceable>&lt;comando&gt;</replaceable> seja 
      retornado como o resultado e não o resultado do comando 
      <command>tee</command>.

    </para>

  </sect2>

  <sect2 id="parallel-builds" xreflabel="Usando Múltiplos Processadores">
    <title>Usando Múltiplos Processadores</title>

    <para>

      Para muitos sistemas modernos com múltiplos processadores (ou 
      núcleos) o tempo de compilação para um pacote pode ser reduzido 
      realizando-se um "make paralelo", ou configurando-se uma variável 
      de ambiente, ou dizendo-se ao aplicativo make quantos 
      processadores estão disponíveis.  Por exemplo, um Core2Duo pode 
      suportar dois processos simultâneos com:

    </para>

    <screen><userinput>export MAKEFLAGS='-j2'</userinput></screen>

    <para>

      ou apenas construir com:

    </para>

    <screen><userinput>make -j2</userinput></screen>

    <para>

      Se você tiver aplicado o <command>sed</command> opcional quando da 
      construção do <application>ninja</application> no LFS, [então] 
      você pode usar:

    </para>

    <screen><userinput>export NINJAJOBS=2</userinput></screen>

    <para>

      quando um pacote usar o <command>ninja</command>; ou apenas:

    </para>

    <screen><userinput>ninja -j2</userinput></screen>

    <para>

      porém, para o ninja, o número padrão de trabalhos é &lt;N&gt;+2, 
      onde &lt;N&gt; é o número de processadores disponíveis, de forma 
      que usar os comandos acima é preferencialmente para limitar o 
      número de trabalhos (veja-se abaixo para o porque isso poderia ser 
      necessário).

    </para>

    <para>

      Geralmente o número de processos não deveria exceder o número de 
      núcleos suportados pela CPU.  Para listar os processadores em seu 
      sistema, emita:
      <userinput>grep processor /proc/cpuinfo</userinput>.

    </para>

    <para>

      Em alguns casos, usar múltiplos processos talvez resulte em uma 
      condição de 'corrida' onde o sucesso da construção depende da 
      ordem dos comandos executados pelo aplicativo 
      <command>make</command>.  Por exemplo, se um executável precisar 
      do Arquivo A e do Arquivo B, [então] tentar-se vincular o 
      aplicativo antes que um dos componentes dependentes esteja 
      disponível resultará em uma falha.  Essa condição geralmente 
      surge, pois o(a) desenvolvedor(a) do aplicativo não designou 
      adequadamente todos os pré requisitos necessários para realizar um 
      passo no Makefile.

    </para>

    <para>

      Se isso ocorrer, [então] a melhor maneira de se proceder é a de se 
      voltar para uma construção de processador único.  Adicionar '-j1' 
      a um comando make substituirá a configuração semelhante na 
      variável de ambiente <envar>MAKEFLAGS</envar>.

    </para>

    <note>

      <para>

        Quando se executar os testes de pacote ou a porção install do 
        processo de construção do pacote, nós não recomendamos usar uma 
        opção maior que '-j1', a menos que especificado de outra 
        maneira.  Os procedimentos ou verificações da instalação não 
        foram validados usando-se procedimentos paralelos e talvez 
        falhem com problemas que são difíceis de se depurar.

      </para>

    </note>

    <important>

      <para>

        Outro problema talvez ocorra com CPUs modernas, as quais tem um 
        monte de núcleos.  Cada trabalho iniciado consome memória e, se 
        a soma da memória necessária para cada trabalho exceder da 
        memória disponível, [então] você talvez encontre, ou uma 
        interrupção de kernel Out of Memory (OOM), ou troca intensa, que 
        retardará a construção além de limites razoáveis.

      </para>

      <para>

        Algumas compilações com o <command>g++</command> talvez consumam 
        até 2,5 GB de memória, de forma que, para estar seguro(a), você 
        deveria restringir o número de trabalhos a (Memória Total em 
        GB)/2,5, ao menos para pacotes grandes, tais como o LLVM; o 
        WebKitGtk; o QtWebEngine; ou o libreoffice.

      </para>

    </important>

  </sect2>

  <sect2 id="automating-builds" xreflabel="Procedimentos Automatizados de Construção">
    <title>Procedimentos Automatizados de Construção</title>

    <para>

      Existem ocasiões onde automatizar a construção de um pacote pode 
      vir a calhar.  Todo mundo tem razões próprias para querer 
      automatizar a construção e todo mundo faz isso de maneira própria.  
      Criar <filename>Makefile</filename>s; scripts do 
      <application>Bash</application>; scripts do 
      <application>Perl</application>; ou, simplesmente, uma lista de 
      comandos usados para recortar e colar, são apenas alguns dos 
      métodos que você pode usar para automatizar a construção de 
      pacotes do BLFS.  Detalhar como e fornecer exemplos das muitas 
      maneiras que você pode automatizar a construção de pacotes está 
      além do escopo desta seção.  Esta seção exporá você ao uso do 
      redirecionamento de arquivo e do comando <command>yes</command> 
      para ajudar a fornecer ideias acerca do como automatizar suas 
      construções.

    </para>

    <bridgehead renderas="sect3">Redirecionamento de Arquivo para Automatizar a Entrada</bridgehead>

    <para>

      Você achará ocasiões ao longo da sua jornada BLFS quando você se 
      deparará com um pacote que tenha um comando solicitando 
      informação.  Essa informação poderia ser detalhes de configuração; 
      um caminho de diretório; ou uma resposta a um acordo de licença.  
      Isso pode apresentar um desafio para automatizar a construção 
      desse pacote.  Ocasionalmente, você será consultado(a) para 
      diferentes informações em uma série de perguntas.  Um método para 
      automatizar esse tipo de cenário exige colocar as respostas 
      desejadas em um arquivo e usar redirecionamento, de forma que o 
      aplicativo use os dados no arquivo como as respostas para as 
      perguntas.

    </para>

    <para>

      Construir o pacote <application>CUPS</application> é um bom 
      exemplo de como redirecionar um arquivo como entrada para 
      solicitações pode te ajudar a automatizar a construção.  Se você 
      executar a suíte de teste, [então] você é solicitado(a) a 
      responder a uma série de perguntas relacionadas ao tipo do teste a 
      executar e se você tem quaisquer aplicativos auxiliares que o 
      teste possa usar.  Você pode criar um arquivo com as suas 
      respostas, uma resposta por linha, e usar um comando similar ao 
      mostrado abaixo para automatizar a execução da suíte de teste:

    </para>

<screen><userinput>make check &lt; ../cups-1.1.23-testsuite_parms</userinput></screen>

    <para>

      Isso, efetivamente, faz com que a suíte de teste use as respostas 
      no arquivo como a entrada gerada para as perguntas.  
      Ocasionalmente você talvez termine fazendo um bocado de tentativa 
      e erro para determinar o formato exato do seu arquivo de entrada 
      gerada para algumas coisas, porém, tão logo determinado e 
      documentado, você pode usar isso para automatizar a construção do 
      pacote.

    </para>

    <bridgehead renderas="sect3">Usando o <command>yes</command> para Automatizar a Entrada Gerada</bridgehead>

    <para>

      Ocasionalmente você somente precisará fornecer uma resposta, ou 
      fornecer a mesma resposta para muitas solicitações.  Para tais 
      instâncias, o comando <command>yes</command> funciona realmente 
      bem.  O comando <command>yes</command> pode ser usado para 
      fornecer uma resposta (a mesma) para uma ou mais instâncias de 
      perguntas.  Ele pode ser usado para simular o pressionamento 
      apenas da tecla <keycap>Enter</keycap>; informar a tecla 
      <keycap>Y</keycap>; ou informar uma sequência de caracteres de 
      texto.  Talvez a maneira mais fácil de mostrar o uso dele é em um 
      exemplo.

    </para>

    <para>

      Primeiro, crie um script curto do <application>Bash</application> 
      informando os seguintes comandos:

    </para>

<screen><userinput>cat &gt; blfs-yes-test1 &lt;&lt; "EOF"
<literal>#!/bin/bash

echo -n -e "\n\nPor favor, digite algo (ou nada) e pressione Enter ---> "

read A_STRING

if test "$A_STRING" = ""; then A_STRING="Apenas a tecla Enter foi pressionada"
else A_STRING="Você informou '$A_STRING'"
fi

echo -e "\n\n$A_STRING\n\n"</literal>
EOF
chmod 755 blfs-yes-test1</userinput></screen>

    <para>

      Agora execute o script emitindo 
      <command>./blfs-yes-test1</command> a partir da linha de comando.  
      Ele aguardará por uma resposta, que pode ser algo (ou nada) 
      seguida pela tecla <keycap>Enter</keycap>.  Depois de informar 
      alguma coisa, o resultado será ecoado para a tela.  Agora use o 
      comando <command>yes</command> para automatizar a entrada de uma 
      resposta:

    </para>

<screen><userinput>yes | ./blfs-yes-test1</userinput></screen>

    <para>

      Perceba que canalizar o próprio <command>yes</command> para o 
      script resulta em <keycap>y</keycap> sendo passada para o script.  
      Agora tente com uma sequência de caracteres de texto:

    </para>

<screen><userinput>yes 'Este é algum texto' | ./blfs-yes-test1</userinput></screen>

    <para>

      A sequência exata de caracteres foi usada como a resposta para o 
      script.  Finalmente, tente usando uma sequência de caracteres 
      vazia (nula):

    </para>

<screen><userinput>yes '' | ./blfs-yes-test1</userinput></screen>

    <para>

      Perceba que isso resulta na passagem apenas do pressionamento da 
      tecla <keycap>Enter</keycap> para o script.  Isso é útil para 
      ocasiões quando a resposta padrão para a solicitação é suficiente.  
      Essa sintaxe é usada nas instruções do
      <xref linkend="net-tools-automate-example"/> para aceitar todos os 
      padrões para as muitas solicitações durante a etapa de 
      configuração.  Você talvez agora remova o script de teste, se 
      desejado.

    </para>

    <bridgehead renderas="sect3">Redirecionamento de Arquivo para Automatizar a Saída Gerada</bridgehead>

    <para>

      Para a finalidade de automatizar a construção de alguns pacotes, 
      especialmente aqueles que exigem que você leia um acordo de 
      licença em uma página por vez, exige-se usar um método que evite 
      ter que pressionar uma tecla para exibir cada página.  
      Redirecionar a saída gerada para um arquivo pode ser usado nessas 
      instâncias para auxiliar com a automação.  A seção anterior nesta 
      página tocou na criação de arquivos de registro da saída gerada da 
      construção.  O método de redirecionamento mostrado lá usou o 
      comando <command>tee</command> para redirecionar a saída gerada 
      para um arquivo enquanto também exibia a saída gerada na tela.  
      Aqui, a saída gerada somente será enviada para um arquivo.

    </para>

    <para>

      Novamente, a maneira mais fácil para demonstrar a técnica é 
      mostrar um exemplo.  Primeiro, emita o comando:

    </para>

<screen><userinput>ls -l /usr/bin | more</userinput></screen>

    <para>

      Certamente, você será exigido(a) a visualizar a saída gerada uma 
      página por vez, pois o filtro <command>more</command> foi usado.  
      Agora tente o mesmo comando, porém, dessa vez, redirecione a saída 
      gerada para um arquivo.  O arquivo especial 
      <filename>/dev/null</filename> pode ser usado em vez do nome de 
      arquivo mostrado, porém você não terá arquivo de registro para 
      examinar:

    </para>

<screen><userinput>ls -l /usr/bin | more &gt; redirect_test.log 2&gt;&amp;1</userinput></screen>

    <para>

      Perceba que, dessa vez, o comando imediatamente retornou ao prompt 
      do shell sem ter que paginar ao longo da saída gerada.  Você agora 
      talvez remova o arquivo de registro.

    </para>

    <para>

      O último exemplo usará o comando <command>yes</command> em 
      combinação com o redirecionamento da saída gerada para desviar-se 
      de ter que paginar ao longo da saída gerada e, então, fornecer um 
      <keycap>y</keycap> para uma solicitação.  Essa técnica poderia ser 
      usada em instâncias quando, de outra maneira, você teria que 
      paginar ao longo da saída gerada de um arquivo (como um acordo de 
      licença) e, então, responder à pergunta de
      <quote>você aceita o acima?</quote>.  Para esse exemplo, outro
      script curto do <application>Bash</application> é exigido:

    </para>

<screen><userinput>cat &gt; blfs-yes-test2 &lt;&lt; "EOF"
<literal>#!/bin/bash

ls -l /usr/bin | more

echo -n -e "\n\nVocê curtiu ler isso? (y,n) "

read A_STRING

if test "$A_STRING" = "y"; then A_STRING="Você digitou a tecla 'y'"
else A_STRING="Você NÃO digitou a tecla 'y'"
fi

echo -e "\n\n$A_STRING\n\n"</literal>
EOF
chmod 755 blfs-yes-test2</userinput></screen>

    <para>

      Esse script pode ser usado para simular um aplicativo que exige 
      que você leia um acordo de licença, então responda apropriadamente 
      que aceita o acordo antes do aplicativo instalar qualquer coisa.  
      Primeiro, execute o script sem quaisquer técnicas de automação 
      emitindo <command>./blfs-yes-test2</command>.

    </para>

    <para>

      Agora emita o seguinte comando que usa duas técnicas de automação, 
      tornando-o adequado para uso em um script automatizado de 
      construção:

    </para>

<screen><userinput>yes | ./blfs-yes-test2 &gt; blfs-yes-test2.log 2&gt;&amp;1</userinput></screen>

    <para>

      Se desejado, emita <command>tail blfs-yes-test2.log</command> para 
      ver o final da saída gerada paginada e confirmação de que 
      <keycap>y</keycap> foi passada ao longo para o script.  Tão logo 
      satisfeito que ele funciona como deveria, você talvez remova o 
      script e arquivo de registro.

    </para>

    <para>

      Finalmente, tenha em mente que existem muitas maneiras de 
      automatizar e (ou) roteirizar os comandos de construção.  Não 
      existe uma maneira única <quote>correta</quote> para fazê-lo.  Sua 
      imaginação é o único limite.

    </para>

  </sect2>

  <sect2>
    <title>Dependências</title>

    <para>

      Para cada pacote descrito, o BLFS lista as dependências 
      conhecidas.  Essas são listadas sob vários títulos, cujo 
      significado é como segue:

    </para>

    <itemizedlist>

      <listitem>

        <para>

          <emphasis>Exigida</emphasis> significa que o pacote alvo não 
          pode ser corretamente construído sem a dependência sendo 
          primeiro instalada.

        </para>

      </listitem>

      <listitem>

        <para>

          <emphasis>Recomendada</emphasis> significa que o BLFS 
          enfaticamente sugere que esse pacote seja instalado primeiro 
          para uma construção limpa e livre de problemas; que não teria 
          problemas seja durante o processo de construção, seja em tempo 
          de execução.  As instruções no livro assumem que esses pacotes 
          estão instalados.  Algumas mudanças ou gambiarras talvez sejam 
          exigidas se esses pacotes não estiverem instalados.

        </para>

      </listitem>

      <listitem>

        <para>

          <emphasis>Opcional</emphasis> significa que esse pacote 
          poderia estar instalado para funcionalidade adicionada.  
          Frequentemente o BLFS descreverá a dependência para explicar a 
          funcionalidade adicionada que resultará.

        </para>

      </listitem>

    </itemizedlist>

  </sect2>

  <sect2 id="package_updates">
    <title>Usando os Fontes de Pacote Mais Atuais</title>

    <para>

      Ocasionalmente você talvez se encontre em uma situação no livro 
      onde um pacote não construirá ou não funcionará adequadamente.  
      Apesar dos(as) Editores(as) tentarem garantir que cada pacote no 
      livro construa e funcione adequadamente, ocasionalmente um pacote 
      tenha sido negligenciado ou não foi testado com esta versão 
      particular do BLFS.

    </para>

    <para>

      Se você descobrir que um pacote não construirá ou não funcionará 
      adequadamente, [então] você deveria ver se existe uma versão mais 
      recente do pacote.  Tipicamente isso significa você ir ao sítio da 
      web do(a) mantenedor(a); e transferir o tarball mais recente; e 
      tentar construir o pacote.  Se você não puder determinar o sítio 
      da web do(a) mantenedor(a) olhando para os URLs de transferência, 
      [então] use o Google e consulte o nome do pacote.  Por exemplo, na 
      barra de pesquisa do Google, digite: 'nome_do_pacote download' 
      (omita as aspas) ou algo semelhante.  Ocasionalmente, digitar: 
      'nome_do_pacote home page' resultará em você encontrar o sítio da 
      web do(a) mantenedor(a).

    </para>

  </sect2>

  <sect2 id="stripping">
    <title>Despojando Mais Uma Vez</title>

    <warning>

      <para>

        Se você não despojou aplicativos e bibliotecas no LFS, [então] o 
        seguinte provavelmente tornará o seu sistema inutilizável.  Para 
        evitar isso, execute as instruções em
        <ulink url="&lfs-root;/chapter08/strippingagain.html"/> em vez
        disso.  Depois que os arquivos críticos estiverem despojados
        usando aquelas instruções, as instruções abaixo podem ser
        executadas a qualquer tempo que novos pacotes sejam instalados.

      </para>

    </warning>

    <para>

      No LFS, o despojamento dos símbolos de depuração foi discutido um 
      par de vezes.  Quando se construir pacotes do BLFS, geralmente não 
      existem instruções especiais que discutam o despojamento 
      novamente.  Provavelmente, não é uma boa ideia despojar um 
      executável ou uma biblioteca enquanto ele(a) estiver em uso, de 
      forma que sair-se de qualquer ambiente de janela é uma boa ideia.  
      Então você pode fazer:

    </para>

<screen><userinput>find /usr/{bin,lib,sbin} \
    -type f \( -name \*.so* -a ! -name \*dbg \) \
    -exec strip --strip-unneeded {} \;</userinput></screen>

    <para>

      Se você instalar aplicativos em outros diretórios, tais como 
      <filename class="directory">/opt</filename> ou
      <filename class="directory">/usr/local</filename>, [então] você
      talvez queira despojar os arquivos lá também.

    </para>

    <para>

      Para mais informação acerca de despojamento, veja-se
      <ulink url="http://www.technovelty.org/linux/stripping-shared-libraries.html"/>.

    </para>

  </sect2>

<!--
  <sect2 id="libtool">
    <title>Arquivos Libtool</title>

    <para>

      Um dos efeitos colaterais de pacotes que usam o Autotools, 
      incluindo o libtool, é que eles criam muitos arquivos com uma 
      extensão .la.  Esses arquivos não são necessários em um ambiente 
      LFS.  Se existirem conflitos com as entradas do pkgconfig, [então] 
      eles atualmente podem evitar construções exitosas.  Você talvez 
      queira considerar remover esses arquivos periodicamente:

    </para>

<screen><userinput>find /lib /usr/lib -not -path "*Image*" -a -name \*.la -delete</userinput></screen>

    <para>

      O comando acima remove todos os arquivos .la, com exceção daqueles 
      que tenham <quote>Image</quote> ou <quote>openldap</quote> como 
      uma parte do caminho.  Esses arquivos .la são usados pelos 
      aplicativos ImageMagick e openldap, respectivamente.  Talvez 
      existam outras exceções por pacotes fora do BLFS.

    </para>

  </sect2>
-->

  <sect2 id="buildsystems">
    <title>Trabalhando com diferentes sistemas de construção</title>

    <para>

      Existem, agora, três sistemas de construção em uso comum para 
      converter código fonte C ou C++ em aplicativos ou bibliotecas 
      compilados(as) e os detalhes deles (particularmente, descobrir 
      acerca de opções disponíveis e os valores padrão delas) diferem.  
      Talvez seja mais fácil entender os problemas causados por algumas 
      escolhas (tipicamente, execução lenta; ou uso inesperado de, ou 
      omissão de, otimizações) iniciando-se com as variáveis de ambiente 
      CFLAGS e CXXFLAGS.  Também existem alguns aplicativos que usam 
      rust.

    </para>

    <para>

      A maioria dos(as) construtores(as) do LFS e do BLFS provavelmente 
      está ciente dos básicos de CFLAGS e CXXFLAGS para alterar como um 
      aplicativo é compilado.  Tipicamente, alguma forma de otimização é 
      usada pelos(as) desenvolvedores(as) de aplicativos (-O2 ou -O3), 
      ocasionalmente com a criação de símbolos de depuração (-g), como 
      padrões.

    </para>

    <para>

      Se existirem sinalizadores contraditórios (por exemplo, múltiplos 
      valores -O), [então] o <emphasis>último</emphasis> valor será 
      usado.  Ocasionalmente, isso significa que os sinalizadores 
      especificados em variáveis de ambiente serão escolhidos antes dos 
      valores codificados rigidamente no Makefile, e, portanto, 
      ignorados.  Por exemplo, onde um(a) usuário(a) especificar '-O2' e 
      isso for seguido por '-O3', a construção usará '-O3'.

    </para>

    <para>

      Existem várias outras coisas que podem ser passadas em CFLAGS ou 
      em CXXFLAGS, tais como forçar-se a compilação para uma 
      microarquitetura específica (por exemplo, -march=amdfam10; 
      -march=native) ou especificar-se um padrão específico para C ou 
      C++ (-std=c++17, por exemplo).  Porém, uma coisa que agora veio à 
      tona é que os(as) programadores(as) poderiam incluir asserções de 
      depuração no código deles(as), esperando que sejam desabilitados 
      em lançamentos usando-se -DNDEBUG.  Especificamente, se o
      <xref linkend="mesa"/> for construído com essas asserções
      habilitadas, [então] algumas atividades, tais como o carregamento
      de níveis dos jogos, podem tomar tempos extremamente longos,
      mesmo em placas de vídeo de alta qualidade.

    </para>

    <bridgehead renderas="sect3" id="autotools-info">Autotools com Make</bridgehead>

      <para>

        Essa combinação frequentemente é descrita como 'CMMI' 
        (configure; make; make install) e é usada aqui também para 
        cobrir uns poucos pacotes que tem um script de configuração que 
        não gerado pelo autotools.

      </para>

      <para>

        Ocasionalmente, executar-se
        <command>./configure --help</command> produzirá opções úteis
        acerca de chaves que poderiam ser usadas.  Em outras ocasiões,
        depois de olhar para a saída gerada a partir do configure, você
        talvez precise olhar para os detalhes do script para descobrir
        pelo que ele estava procurando atualmente.

      </para>

      <para>

        Muitos scripts de configuração escolherão quaisquer CFLAGS ou 
        CXXFLAGS a partir do ambiente, porém os pacotes CMMI variam 
        acerca do como esses serão misturados com quaisquer 
        sinalizadores que, de outra maneira, seriam usados 
        (<emphasis>variadamente</emphasis>: ignorados; usados para 
        substituir a sugestão do(a) programador(a); usados antes da 
        sugestão do(a) programador(a); ou usados depois da sugestão 
        do(a) programador(a)).

      </para>

      <para>

        Na maioria dos pacotes CMMI, executar-se 'make' listará cada 
        comando e o executará, intercalado com quaisquer avisos.  Porém, 
        alguns pacotes tentam ser 'silenciosos' e mostram somente qual 
        arquivo eles estão compilando ou vinculando em vez de mostrar a 
        linha de comando.  Se você precisar inspecionar o comando, seja 
        por causa de um erro, seja apenas para ver quais opções e 
        sinalizadores estão sendo usados, [então] adicionar 'V=1' à 
        invocação do make talvez ajude.

      </para>

    <bridgehead renderas="sect3" id="cmake-info">CMake</bridgehead>

      <para>

        O CMake funciona de uma maneira muito diferente, e ele tem dois 
        processos internos que podem usados no BLFS: 'make' e 'ninja'.  
        O processo interno padrão é o make, porém o ninja pode ser mais 
        rápido sobre pacotes largos com múltiplos processadores.  Para 
        usar o ninja, especifique '-G Ninja' no comando cmake.  
        Entretanto, existem alguns pacotes que criam erros fatais nos 
        arquivos ninja deles, porém constroem com sucesso usando o 
        padrão dos Makefiles do Unix.

      </para>

      <para>

        A parte mais difícil do usar-se o CMake é saber quais opções 
        você poderia desejar especificar.  A única maneira de se obter 
        uma lista do que o pacote conhece é executar
        <command>cmake -LAH</command> e olhar para a saída gerada para
        esta configuração padrão.

      </para>

      <para>

        Talvez a coisa mais importante acerca do CMake é que ele tem uma 
        variedade de valores CMAKE_BUILD_TYPE e esses afetam os 
        sinalizadores.  O padrão é o de que isso não é configurado e 
        nenhum sinalizador é gerado.  Quaisquer CFLAGS ou CXXFLAGS no 
        ambiente serão usados.  Se o(a) programador(a) tiver codificado 
        quaisquer asserções de depuração, [então] essas serão 
        habilitadas, a menos que -DNDEBUG seja usado.  Os seguintes 
        valores CMAKE_BUILD_TYPE gerarão os sinalizadores mostrados, e 
        esses virão <emphasis>depois de</emphasis> quaisquer 
        sinalizadores no ambiente e, portanto, terão precedência.

      </para>

      <itemizedlist>
        <listitem>
          <para>Depuração : '-g'</para>
        </listitem>
        <listitem>
          <para>Lançamento : '-O3 -DNDEBUG'</para>
        </listitem>
        <listitem>
           <para>Lançamento Com Informação de Depuração : '-O2 -g -DNDEBUG'</para>
        </listitem>
        <listitem>
           <para>Tamanho Mínimo do Lançamento : '-Os -DNDEBUG'</para>
        </listitem>
      </itemizedlist>

      <para>

        O CMake tenta produzir construções silenciosas.  Para ver os 
        detalhes dos comandos que estão sendo executados, use 'make 
        VERBOSE=1' ou 'ninja -v'.

      </para>

    <bridgehead renderas="sect3" id="meson-info">Meson</bridgehead>

      <para>

        O Meson tem algumas semelhanças com o CMake, porém muitas 
        diferenças.  Para obter os detalhes das definições que você 
        talvez queira mudar, você pode olhar para o 
        <filename>meson_options.txt</filename> que normalmente está no 
        diretório de nível de topo.

      </para>

      <para>

        Se você já configurou o pacote executando o 
        <command>meson</command> e, agora, deseja mudar uma ou mais 
        configurações, [então] você ou pode remover o diretório de 
        construção, recriá-lo e usar as opções alteradas; ou, dentro do 
        diretório de construção, executar
        <command>meson configure</command>, por exemplo, para configurar
        uma opção:

      </para>

<screen><userinput>meson configure -D&lt;alguma_opcao&gt;=true</userinput></screen>

      <para>

        Se você fizer isso, [então] o arquivo 
        <filename>meson-private/cmd_line.txt</filename> mostrará os 
        <emphasis>últimos</emphasis> comandos que foram usados.

      </para>

      <para>

        O Meson fornece os seguintes valores de tipo de construção e os 
        sinalizadores que eles habilitam vem <emphasis>depois</emphasis> 
        de quaisquer sinalizadores fornecidos no ambiente e, portanto, 
        tem precedência.

      </para>

      <itemizedlist>

        <listitem>

          <para>

            plano : nenhum sinalizador adicionado.  Isso é para os(as) 
            distribuidores(as) fornecerem os próprios CFLAGS, CXXFLAGS e 
            LDFLAGS deles(as).  Não existe razão óbvia para usar isso no 
            BLFS.

          </para>

        </listitem>

        <listitem>

          <para>

            depuração : '-g' - isso é o padrão, se nada for 
            especificado, seja no <filename>meson.build</filename>, seja 
            na linha de comando.  Entretanto, resulta em binários largos 
            e lentos, de forma que nós deveríamos substitui-lo no BLFS.

          </para>

        </listitem>

        <listitem>

          <para>

            depuração otimizada : '-O2 -g' : isso é o padrão, 
            especificado no <filename>meson.build</filename>, de alguns 
            pacotes.

          </para>

        </listitem>

        <listitem>

          <para>

            lançamento : '-O3 -DNDEBUG' (porém, ocasionalmente, um 
            pacote forçará -O2 aqui)

          </para>

        </listitem>

      </itemizedlist>

      <para>

        Apesar do tipo de construção 'lançamento' estar descrito como 
        habilitante do -DNDEBUG e todas as construções CMake Release 
        passarem isso, tem, até agora, somente sido observado (em 
        construções verbosas) para o <xref linkend="mesa"/>.  Isso 
        sugere que somente poderia ser usado quando existirem asserções 
        de depuração presentes.

      </para>

      <para>

        O sinalizador -DNDEBUG também pode ser fornecido passando-se 
        <command>-Db_ndebug=true</command>.

      </para>

      <para>

        Para ver os detalhes dos comandos que estão sendo executados em 
        um pacote usando o meson, use 'ninja -v'.

      </para>

    <bridgehead renderas="sect3" id="rust-info">Rustc e Cargo</bridgehead>

      <para>

        A maioria dos aplicativos rustc lançados é fornecida como 
        engradado (tarballs de fonte), que consultarão um servidor para 
        verificar as versões atuais de dependências e, então, as 
        transferirão conforme necessário.  Esses pacotes são construídos 
        usando-se <command>cargo --release</command>.  Na teoria, você 
        pode manipular o RUSTFLAGS para mudar o nível de otimização 
        (padrão é 3, semelhante a -03; por exemplo, 
        <literal>-Copt-level=3</literal>) ou para forçá-lo a construir 
        para a máquina na qual está sendo compilado, usando 
        <literal>-Ctarget-cpu=native</literal>; porém, na prática, isso 
        parece não fazer uma diferença significante.

      </para>

      <para>

        Se você encontrar um aplicativo rustc interessante que seja 
        fornecido apenas como fonte desempacotado, [então] você deveria, 
        pelo menos, especificar 
        <literal>RUSTFLAGS=-Copt-level=2</literal>; do contrário, fará 
        uma compilação não otimizada, com informação de depuração e 
        executará <emphasis>muito</emphasis> mais lento.

      </para>

      <para>

        Os(As) desenvolvedores(as) do rust parecem presumir que todos 
        compilarão em uma máquina dedicada a produzir construções, de 
        forma que, por padrão, todas as CPUs são usadas.  Isso, 
        frequentemente, pode ser contornado, seja exportando-se 
        CARGO_BUILD_JOBS=&lt;N&gt;, seja passando-se --jobs &lt;N&gt; 
        para o cargo.  Para compilar o próprio rustc, especificar-se 
        --jobs &lt;N&gt; em invocações de x.py (junto com a variável de 
        ambiente <envar>CARGO_BUILD_JOBS</envar>, que se parece com uma 
        abordagem "cinto e suspensórios", porém parece ser necessária) 
        na maioria das vezes funciona.  A exceção é a de executar-se os 
        testes quando construir-se o rustc; alguns deles, ainda assim, 
        usarão todas as CPUs online, pelo menos desde o rustc-1.42.0.

      </para>

  </sect2>

  <sect2 id="optimizations">
    <title>Otimizando a construção</title>

      <para>

        Muitas pessoas preferirão otimizar compilações como acharem 
        melhor, fornecendo CFLAGS ou CXXFLAGS.  Para uma introdução às 
        opções disponíveis com o gcc e com o g++, veja-se
        <ulink url="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html"/>; 
        e
        <ulink url="https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html"/>; 
        e <command>info gcc</command>.

      </para>

      <para>

        Alguns pacotes padronizam para '-O2 -g'; outros para '-O3 -g'; 
        e, se CFLAGS ou CXXFLAGS forem fornecidos, [então] eles poderiam 
        ser adicionados ao padrão do pacote; substituir o padrão do 
        pacote; ou até serem ignorados.  Existem detalhes acerca de 
        alguns pacotes de área de trabalho que eram na maioria das vezes 
        atuais em abril de 2019 em
        <ulink url="https://www.linuxfromscratch.org/~ken/tuning/"/> - em 
        particular, README.txt, tuning-1-packages-and-notes.txt e 
        tuning-notes-2B.txt.  A coisa particular a se lembrar é a de 
        que, se você quiser tentar algum dos mais interessantes 
        sinalizadores, você talvez precise forçar construções verbosas 
        para confirmar o que está sendo usado.

      </para>

      <para>

        Claramente, se você estiver otimizando seu próprio aplicativo, 
        [então] você pode gastar tempo para perfilá-lo e, talvez, 
        recodificar algo dele, se ele estiver lento demais.  Porém, para 
        construir um sistema inteiro, essa abordagem é impraticável.  No 
        geral, -03 geralmente produz aplicativos mais rápidos que -02.  
        Especificar-se -march=native também é benéfico, porém significa 
        que você não pode mover os binários para uma máquina 
        incompatível - isso também pode se aplicar a máquinas mais 
        novas, não apenas às máquinas mais antigas.  Por exemplo, os 
        aplicativos compilados para 'amdfam10' executam em Phenoms 
        antigos; Kaveris; e Ryzens; porém, os aplicativos compilados 
        para um Kaveri não executarão em um Ryzen, pois certos códigos 
        de operação não estão presentes.  Similarmente, se você 
        construir para um Haswell, [então] nem tudo executará em um 
        SandyBridge.

      </para>

      <para>

        Existem também várias outras opções que algumas pessoas alegam 
        que são benéficas.  Na pior das hipóteses, você consegue 
        recompilar e testar e, então, descobrir que, em seu uso, as 
        opções não fornecem um benefício.

      </para>

      <para>

        Se construir módulos do Perl ou do Python; ou pacotes do Qt que 
        usam o qmake, [então], no geral, os CFLAGS e CXXFLAGS usados são 
        aqueles que foram usados por aqueles pacotes 'pai'.

      </para>

  </sect2>

  <sect2 id="hardening">
    <title>Opções para fortalecer a construção</title>

      <para>

        Mesmo em sistemas de área de trabalho, existem ainda um monte de 
        vulnerabilidades exploráveis.  Para muitas dessas, o ataque vem 
        via javascript em um navegador.  Frequentemente, uma série de 
        vulnerabilidades é usada para ganhar acesso a dados (ou, as 
        vezes, para pwn, isto é, dominar, a máquina e instalar 
        rootkits).  A maioria das distribuições comerciais aplicará 
        várias medidas de fortalecimento.

      </para>

      <para>

        Para opções de fortalecimento que sejam razoavelmente baratas, 
        existe alguma discussão no link 'tuning' acima (ocasionalmente, 
        uma ou mais dessas opções poderiam ser inapropriadas para um 
        pacote).  Essas opções são -D_FORTIFY_SOURCE=2; 
        -fstack-protector=strong; e (para C++) -D_GLIBCXX_ASSERTIONS.  
        Em máquinas modernas, essas somente deveriam ter um impacto 
        pequeno acerca do quão rápido as coisas executam e, 
        frequentemente, elas não serão perceptíveis.

      </para>

      <para>

        No passado, existia o LFS Fortalecido onde o gcc (uma versão 
        muito antiga) era forçado a usar fortalecimento (com opções para 
        desligar algumas delas em uma base por pacote.  O que está 
        sendo coberto aqui é diferente - primeiro, você tem de ter 
        certeza de que o pacote está de fato usando os seus 
        sinalizadores adicionados e não substituindo-os.

      </para>

      <para>

        As distribuições principais usam muito mais, tal como Relocação 
        Somente Leitura (RELRO) e, talvez, -fstack-clash-protection.  
        Você talvez encontre também o assim chamado 'retpoline de espaço 
        de usuário(a)' (-mindirect-branch=thunk etc.) que é o 
        equivalente das mitigações do espectro aplicado ao kernel do 
        linux no final de 2018).  As mitigações do kernel causaram um 
        monte de reclamações acerca de perda de desempenho; se você tem 
        um servidor de produção, [então] você poderia desejar considerar 
        testar isso, junto com as outras opções disponíveis, para ver se 
        o desempenho ainda está suficiente.

      </para>

      <para>

        Embora o gcc tenha muitas opções de fortalecimento, os pontos 
        fortes do clang/LLVM estão em outro lugar.  Algumas opções que o 
        gcc fornece são ditas serem menos efetivas no clang/LLVM.

      </para>

  </sect2>

</sect1>
