<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="unpacking">
  <?dbhtml filename="notes-on-building.html"?>


  <title>Observações Acerca de Construir Software</title>

  <para>Aquelas pessoas que tenham construído um sistema LFS possivelmente estejam
cientes dos princípios gerais da transferência e do desempacotamento de
software. Alguma daquela informação está repetida aqui para aquelas novatas
em construir o próprio software delas.</para>

  <para>Cada conjunto de instruções de instalação contém um URL a partir do qual
você pode transferir o pacote. Os remendos, no entanto, estão armazenados
nos servidores do LFS e estão disponíveis via HTTP. Esses estão
referenciados conforme necessários nas instruções de instalação.</para>

  <para>Enquanto você pode manter os arquivos do fonte em qualquer lugar que queira,
nós assumimos que você desempacotou o pacote e mudou para o diretório criado
pelo processo de desempacotamento (o diretório de 'construção'). Nós
assumimos também que você descomprimiu quaisquer remendos exigidos e que
eles estão no diretório imediatamente acima do diretório de 'construção'.</para>

  <para>Nós não podemos enfatizar fortemente o suficiente que você deveria iniciar a
partir de uma <emphasis>árvore limpa do fonte</emphasis> a cada vez. Isso
significa que, se você tiver tido um erro durante a configuração ou a
compilação, [então] geralmente é melhor deletar a árvore do fonte e
desempacotá-la outra vez <emphasis>antes de</emphasis> tentar
novamente. Isso, obviamente, não se aplica se você for um(a) usuário(a)
avançado(a) habituado(a) a hackear <filename>Makefile</filename>s e código
C; porém, se em dúvida, [então] inicie a partir de uma árvore limpa.</para>

  <sect2>
    <title>Construindo Software como um(a) Usuário(a) Não Privilegiado(a) (não root)</title>

    <para>A regra de ouro da Administração do Sistema Unix é a de usar os seus super
poderes somente quando necessário. Assim, o BLFS recomenda que você construa
software como um(a) usuário(a) não privilegiado(a) e somente se torne o(a)
usuário(a) <systemitem class='username'>root</systemitem> quando instalar o
software. Essa filosofia é seguida em todos os pacotes neste livro. A menos
que especificado de outra maneira, todas as instruções deveriam ser
executadas como um(a) usuário(a) não privilegiado(a). O livro alertará você
acerca de instruções que precisarem de privilégios do(a) <systemitem
class='username'>root</systemitem>.</para>

  </sect2>

  <sect2>
    <title>Desempacotando o Software</title>

    <para>Se um arquivo estiver no formato <filename class='extension'>.tar</filename>
e comprimido, [então] ele é desempacotado executando-se um dos seguintes
comandos:</para>

<screen><userinput>tar -xvf nome_arquivo.tar.gz
tar -xvf nome_arquivo.tgz
tar -xvf nome_arquivo.tar.Z
tar -xvf nome_arquivo.tar.bz2</userinput></screen>

    <note>
      <para>Você possivelmente omita o uso do parâmetro <option>v</option> nos comandos
mostrados acima e abaixo se você desejar suprimir a listagem verbosa de
todos os arquivos no arquivamento conforme eles forem extraídos. Isso pode
ajudar a acelerar a extração, bem como torna quaisquer erros produzidos
durante a extração mais óbvios para você.</para>
    </note>

    <para>Você também pode usar um método ligeiramente diferente:</para>

<screen><userinput>bzcat nome_arquivo.tar.bz2 | tar -xv</userinput></screen>

    <para>Finalmente, ocasionalmente, você precisa estar apto(a) a desempacotar
remendos que geralmente não estão no formato <filename
class='extension'>.tar</filename>. A melhor maneira de fazer isso é a de
copiar o arquivo do remendo para o ancestral do diretório da 'construção' e,
então, executar um dos seguintes comandos, dependendo se o arquivo for um
arquivo <filename class='extension'>.gz</filename> ou um <filename
class='extension'>.bz2</filename>:</para>

<screen><userinput>gunzip -v nome_remendo.gz
bunzip2 -v nome_remendo.bz2</userinput></screen>

  </sect2>

  <sect2>
    <title>Averiguando a Integridade do Arquivo</title>

    <para>Geralmente, para se averiguar se o arquivo transferido está completo,
muitos(as) mantenedores(as) de pacote também distribuem somas de verificação
md5 dos arquivos. Para averiguar a soma de verificação md5 dos arquivos
transferidos, transfira ambos, o arquivo e o arquivo correspondente de soma
de verificação md5, para o mesmo diretório (preferencialmente a partir de
locais diferentes online) e (assumindo que
<filename>arquivo.md5sum</filename> seja o arquivo de soma de verificação
md5 transferido) execute o seguinte comando:</para>

<screen><userinput>md5sum -c arquivo.md5sum</userinput></screen>

    <para>Se existirem quaisquer erros, [então] eles serão informados. Observe que o
livro BLFS inclui somas de verificação md5 para todos os arquivos de fonte
também. Para usar as somas de verificação md5 fornecidas pelo BLFS, você
pode criar um <filename>arquivo.md5sum</filename> (coloque os dados da soma
de verificação md5 e o nome exato do arquivo transferido na mesma linha de
um arquivo, separados por espaço em branco) e executar o comando mostrado
acima. Alternativamente, simplesmente execute o comando mostrado abaixo e
compare a saída gerada para os dados da soma de verificação md5 mostrada no
livro BLFS.</para>

<screen><userinput>md5sum <replaceable>&lt;nome_do_arquivo_transferido&gt;</replaceable></userinput></screen>

    <para>MD5 não é seguro criptograficamente, de forma que as somas de verificação
md5 são fornecidas somente para se detectar mudanças não maliciosas para o
conteúdo do arquivo. Por exemplo, um erro ou truncamento introduzido durante
a transferência de rede de comunicação; ou uma atualização
<quote>furtiva</quote> para o pacote oriunda do(a) desenvolvedor(a)
(atualizando o conteúdo de um tarball liberado em vez de fazer um lançamento
novo adequadamente).</para>

    <para>Não existe maneira <quote>100%</quote> segura de garantir a genuinidade dos
arquivos do fonte. Assumindo que o(a) desenvolvedor(a) esteja gerenciando
corretamente o sítio da web dele(a) (a chave privada não vazou e o domínio
não esteja sequestrado); e que as âncoras de confiança tenham sido
configuradas corretamente usando <xref linkend="make-ca"/> no sistema BLFS;
nós podemos razoavelmente confiar nos URLs de transferência para o sítio
oficial da web do(a) desenvolvedor(a) <emphasis role="bold">com protocolo
https</emphasis>. Observe que o próprio livro BLFS está publicado em um
sítio da web com https, de forma que você já deveria ter alguma confiança no
protocolo https ou você não confiaria no conteúdo do livro.</para>

    <para>Se o pacote for transferido a partir de um local não oficial (por exemplo,
um espelho local), [então] as somas de verificação geradas por algoritmos de
resumo criptograficamente seguros (por exemplo, SHA256) podem ser usadas
para averiguar a genuinidade do pacote. Transfira o arquivo da soma de
verificação a partir do sítio da web <emphasis
role="bold">oficial</emphasis> do(a) desenvolvedor(a) (ou algum lugar que
<emphasis role="bold">você possa confiar</emphasis>) e compare a soma de
verificação do pacote oriunda do local não oficial com ele. Por exemplo, a
soma de verificação SHA256 pode ser verificada com o comando:</para>

    <note>
      <para>Se a soma de verificação e o pacote forem transferidos a partir do mesmo
local não confiável, [então] você não ganharia melhoramento de segurança
averiguando o pacote com a soma de verificação. O(A) atacante pode falsear a
soma de verificação assim como comprometer o próprio pacote.</para>
    </note>

<screen><userinput>sha256sum -c <replaceable>arquivo</replaceable>.sha256sum</userinput></screen>

    <para>Se o <xref linkend="gnupg2"/> estiver instalado, [então] você também pode
averiguar a genuinidade do pacote com uma assinatura GPG. Importe a chave
pública GPG do(a) desenvolvedor(a) com:</para>

<screen><userinput>gpg --recv-key <replaceable>ID_da_chave</replaceable></userinput></screen>

    <para><replaceable>ID_da_chave</replaceable> deveria ser substituído pelo ID da
chave oriundo de algum lugar que <emphasis role="bold">você possa
confiar</emphasis> (por exemplo, copie-o a partir do sítio da web oficial
do(a) desenvolvedor(a) usando https). Agora, você consegue averiguar a
assinatura com:</para>

<screen><userinput>gpg --recv-key <replaceable>arquivo</replaceable>.sig <replaceable>arquivo</replaceable></userinput></screen>

    <para>A vantagem da assinatura <application>GnuPG</application> é, tão logo você
importou uma chave pública que possa ser confiada, você pode transferir
ambos, o pacote e a assinatura dele, a partir do mesmo local não oficial e
averiguá-los com a chave pública. Assim, você não precisaria conectar com o
sítio da web oficial do(a) desenvolvedor(a) para ir buscar uma soma de
verificação para cada lançamento novo. Você somente precisa atualizar a
chave pública se ela estiver expirada ou revogada.
    </para>

  </sect2>

  <sect2>
    <title>Criando Arquivos de Registro Durante a Instalação</title>

    <para>Para pacotes mais largos, é conveniente se criar arquivos de registro em vez
de olhar fixamente para a tela esperando pegar um erro ou aviso em
particular. Os arquivos de registro também são úteis para depuração e para
manter registros. O seguinte comando permite a você criar um registro da
instalação. Substitua <replaceable>&lt;comando&gt;</replaceable> pelo
comando que você pretende executar.</para>

<screen><userinput>( <replaceable>&lt;comando&gt;</replaceable> 2&gt;&amp;1 | tee compile.log &amp;&amp; exit $PIPESTATUS )</userinput></screen>

    <para><option>2&gt;&amp;1</option> redireciona as mensagens de erro para o mesmo
local que a saída gerada padrão. O comando <command>tee</command> permite
visualizar a saída gerada enquanto se registra os resultados em um
arquivo. Os parênteses em volta do comando executam o comando inteiro em um
sub shell; e, finalmente, o comando <command>exit $PIPESTATUS</command>
garante que o resultado do <replaceable>&lt;comando&gt;</replaceable> seja
retornado como o resultado e não o resultado do comando
<command>tee</command>.</para>

  </sect2>

  <sect2 id="parallel-builds" xreflabel="Usando Múltiplos Processadores">
    <title>Usando Múltiplos Processadores</title>

    <para>Para muitos sistemas modernos com múltiplos processadores (ou núcleos) o
tempo de compilação para um pacote pode ser reduzido realizando-se um "make
paralelo", ou configurando-se uma variável de ambiente, ou dizendo-se ao
aplicativo make quantos processadores estão disponíveis. Por exemplo, um
Core2Duo pode suportar dois processos simultâneos com: </para>

    <screen><userinput>export MAKEFLAGS='-j2'</userinput></screen>

    <para>ou apenas construir com:</para>

    <screen><userinput>make -j2</userinput></screen>

    <para>
      Se você tiver aplicado o <command>sed</command> opcional quando da
construção do <application>ninja</application> no LFS, [então] você pode
usar:
    </para>

    <screen><userinput>export NINJAJOBS=2</userinput></screen>

    <para>
      quando um pacote usar o <command>ninja</command>; ou apenas:
    </para>

    <screen><userinput>ninja -j2</userinput></screen>

    <para>
      porém, para o ninja, o número padrão de trabalhos é &lt;N&gt;+2, onde
&lt;N&gt; é o número de processadores disponíveis, de forma que usar os
comandos acima é preferencialmente para limitar o número de trabalhos
(veja-se abaixo para o porque isso poderia ser necessário).
    </para>

    <para>Geralmente o número de processos não deveria exceder o número de núcleos
suportados pela CPU. Para listar os processadores em seu sistema, emita:
<userinput>grep processor /proc/cpuinfo</userinput>.
    </para>

    <para>Em alguns casos, usar múltiplos processos possivelmente resulte em uma
condição de 'corrida' onde o sucesso da construção depende da ordem dos
comandos executados pelo aplicativo <command>make</command>. Por exemplo, se
um executável precisar do Arquivo A e do Arquivo B, [então] tentar-se
vincular o aplicativo antes que um dos componentes dependentes esteja
disponível resultará em uma falha. Essa condição geralmente surge, pois o(a)
desenvolvedor(a) do aplicativo não designou adequadamente todos os pré
requisitos necessários para realizar uma etapa no Makefile.</para>

    <para>Se isso ocorrer, [então] a melhor maneira de se proceder é a de se voltar
para uma construção de processador único. Adicionar '-j1' a um comando make
substituirá a configuração semelhante na variável de ambiente
<envar>MAKEFLAGS</envar>.</para>

    <note><para>Quando se executar os testes de pacote ou a porção instalar do processo de
construção do pacote, nós não recomendamos usar uma opção maior que '-j1', a
menos que especificado de outra maneira. Os procedimentos ou verificações da
instalação não foram validados usando-se procedimentos paralelos e
possivelmente falhem com problemas que são difíceis de se depurar.</para></note>

    <important>
      <para>
        Outro problema possivelmente ocorra com CPUs modernas, as quais tem um monte
de núcleos. Cada trabalho iniciado consome memória e, se a soma da memória
necessária para cada trabalho exceder da memória disponível, [então] você
possivelmente encontre, ou uma interrupção de kernel Out of Memory (OOM), ou
troca intensa, que retardará a construção além de limites razoáveis.
      </para>

      <para>
        Algumas compilações com o <command>g++</command> possivelmente consumam até
2,5 GB de memória, de forma que, para estar seguro(a), você deveria
restringir o número de trabalhos a (Memória Total em GB)/2,5, ao menos para
pacotes grandes, tais como o LLVM; o WebKitGtk; o QtWebEngine; ou o
Libreoffice.
      </para>
    </important>
  </sect2>

  <sect2 id="automating-builds" xreflabel="Procedimentos Automatizados de Construção">
    <title>Procedimentos Automatizados de Construção</title>

    <para>Existem ocasiões onde automatizar a construção de um pacote pode vir a
calhar. Todo mundo tem razões próprias para querer automatizar a construção
e todo mundo faz isso de maneira própria. Criar
<filename>Makefile</filename>s; scripts do <application>Bash</application>;
scripts do <application>Perl</application>; ou, simplesmente, uma lista de
comandos usados para recortar e colar, são apenas alguns dos métodos que
você pode usar para automatizar a construção de pacotes do BLFS. Detalhar
como e fornecer exemplos das muitas maneiras que você pode automatizar a
construção de pacotes está além do escopo desta seção. Esta seção exporá
você ao uso do redirecionamento de arquivo e do comando
<command>yes</command> para ajudar a fornecer ideias acerca do como
automatizar suas construções.</para>

    <bridgehead renderas="sect3">Redirecionamento de Arquivo para Automatizar a Entrada Gerada</bridgehead>

    <para>Você achará ocasiões ao longo da sua jornada BLFS quando você se deparará
com um pacote que tenha um comando solicitando informação. Essa informação
poderia ser detalhes de configuração; um caminho de diretório; ou uma
resposta a um acordo de licença. Isso pode apresentar um desafio para
automatizar a construção desse pacote. Ocasionalmente, você será
consultado(a) para diferentes informações em uma série de perguntas. Um
método para automatizar esse tipo de cenário exige colocar as respostas
desejadas em um arquivo e usar redirecionamento, de forma que o aplicativo
use os dados no arquivo como as respostas para as perguntas.</para>

    <para>Construir o pacote <application>CUPS</application> é um bom exemplo de como
redirecionar um arquivo como entrada gerada para solicitações pode te ajudar
a automatizar a construção. Se você executar a suíte de teste, [então] você
é solicitado(a) a responder a uma série de perguntas relacionadas ao tipo do
teste a executar e se você tem quaisquer aplicativos auxiliares que o teste
possa usar. Você pode criar um arquivo com as suas respostas, uma resposta
por linha, e usar um comando similar ao mostrado abaixo para automatizar a
execução da suíte de teste:</para>

<screen><userinput>make check &lt; ../cups-1.1.23-testsuite_parms</userinput></screen>

    <para>Isso, efetivamente, faz com que a suíte de teste use as respostas no arquivo
como a entrada gerada para as perguntas. Ocasionalmente você possivelmente
termine fazendo um bocado de tentativa e erro para determinar o formato
exato do seu arquivo de entrada gerada para algumas coisas, porém, tão logo
determinado e documentado, você consegue usar isso para automatizar a
construção do pacote.</para>

    <bridgehead renderas="sect3">Usando o <command>yes</command> para Automatizar a Entrada Gerada</bridgehead>

    <para>Ocasionalmente você somente precisará fornecer uma resposta ou fornecer a
mesma resposta para muitas solicitações. Para tais instâncias, o comando
<command>yes</command> funciona realmente bem. O comando
<command>yes</command> pode ser usado para fornecer uma resposta (a mesma)
para uma ou mais instâncias de perguntas. Ele pode ser usado para simular o
pressionamento apenas da tecla <keycap>Enter</keycap>; informar a tecla
<keycap>Y</keycap>; ou informar uma sequência de caracteres de texto. Talvez
a maneira mais fácil de mostrar o uso dele é em um exemplo.</para>

    <para>Primeiro, crie um script curto do <application>Bash</application> informando
os seguintes comandos:</para>

<screen><userinput>cat &gt; blfs-yes-test1 &lt;&lt; "EOF"
<literal>#!/bin/bash

echo -n -e "\n\nPor favor, digite algo (ou nada) e pressione Enter ---> "

read A_STRING

if test "$A_STRING" = ""; then A_STRING="Apenas a tecla Enter foi pressionada"
else A_STRING="Você informou '$A_STRING'"
fi

echo -e "\n\n$A_STRING\n\n"</literal>
EOF
chmod 755 blfs-yes-test1</userinput></screen>

    <para>Agora execute o script emitindo <command>./blfs-yes-test1</command> a partir
da linha de comando. Ele aguardará por uma resposta, que pode ser algo (ou
nada) seguida pela tecla <keycap>Enter</keycap>. Depois de informar alguma
coisa, o resultado será ecoado para a tela. Agora use o comando
<command>yes</command> para automatizar a entrada de uma resposta:</para>

<screen><userinput>yes | ./blfs-yes-test1</userinput></screen>

    <para>Perceba que canalizar o próprio <command>yes</command> para o script resulta
em <keycap>y</keycap> sendo passada para o script. Agora tente com uma
sequência de caracteres de texto:</para>

<screen><userinput>yes 'Este é algum texto' | ./blfs-yes-test1</userinput></screen>

    <para>A sequência exata de caracteres foi usada como a resposta para o
script. Finalmente, tente usando uma sequência de caracteres vazia (nula):</para>

<screen><userinput>yes '' | ./blfs-yes-test1</userinput></screen>

    <para>Perceba que isso resulta na passagem apenas do pressionamento da tecla
<keycap>Enter</keycap> para o script. Isso é útil para ocasiões quando a
resposta padrão para a solicitação for suficiente. Essa sintaxe é usada nas
instruções do <xref linkend="net-tools-automate-example"/> para aceitar
todos os padrões para as muitas solicitações durante a etapa de
configuração. Você possivelmente agora remova o script de teste, se
desejado.</para>

    <bridgehead renderas="sect3">Redirecionamento de Arquivo para Automatizar a Saída Gerada</bridgehead>

    <para>Para a finalidade de automatizar a construção de alguns pacotes,
especialmente aqueles que exigem que você leia um acordo de licença em uma
página por vez, exige-se usar um método que evite ter que pressionar uma
tecla para exibir cada página. Redirecionar a saída gerada para um arquivo
pode ser usado nessas instâncias para auxiliar com a automação. A seção
anterior nesta página tocou na criação de arquivos de registro da saída
gerada da construção. O método de redirecionamento mostrado lá usou o
comando <command>tee</command> para redirecionar a saída gerada para um
arquivo enquanto também exibia a saída gerada na tela. Aqui, a saída gerada
somente será enviada para um arquivo.</para>

    <para>Novamente, a maneira mais fácil para demonstrar a técnica é de mostrar um
exemplo. Primeiro, emita o comando:</para>

<screen><userinput>ls -l /usr/bin | more</userinput></screen>

    <para>Certamente, você será exigido(a) a visualizar a saída gerada uma página por
vez, pois o filtro <command>more</command> foi usado. Agora tente o mesmo
comando, porém, dessa vez, redirecione a saída gerada para um arquivo. O
arquivo especial <filename>/dev/null</filename> pode ser usado em vez do
nome de arquivo mostrado, porém você não terá arquivo de registro para
examinar:</para>

<screen><userinput>ls -l /usr/bin | more &gt; redirect_test.log 2&gt;&amp;1</userinput></screen>

    <para>Perceba que, dessa vez, o comando imediatamente retornou ao prompt do shell
sem ter que paginar ao longo da saída gerada. Você agora possivelmente
remova o arquivo de registro.</para>

    <para>O último exemplo usará o comando <command>yes</command> em combinação com o
redirecionamento da saída gerada para desviar-se de ter que paginar ao longo
da saída gerada e, então, fornecerá um <keycap>y</keycap> para uma
solicitação. Essa técnica poderia ser usada em instâncias quando, de outra
maneira, você teria que paginar ao longo da saída gerada de um arquivo (como
um acordo de licença) e, então, responder à pergunta de <quote>você aceita o
acima?</quote>. Para esse exemplo, outro script curto do
<application>Bash</application> é exigido:</para>

<screen><userinput>cat &gt; blfs-yes-test2 &lt;&lt; "EOF"
<literal>#!/bin/bash

ls -l /usr/bin | more

echo -n -e "\n\nVocê curtiu ler isso? (y,n) "

read A_STRING

if test "$A_STRING" = "y"; then A_STRING="Você informou a tecla 'y'"
else A_STRING="Você NÃO informou a tecla 'y'"
fi

echo -e "\n\n$A_STRING\n\n"</literal>
EOF
chmod 755 blfs-yes-test2</userinput></screen>

    <para>Esse script pode ser usado para simular um aplicativo que exige que você
leia um acordo de licença, então responda apropriadamente que aceita o
acordo antes do aplicativo instalar qualquer coisa. Primeiro, execute o
script sem quaisquer técnicas de automação emitindo
<command>./blfs-yes-test2</command>.</para>

    <para>Agora emita o seguinte comando que usa duas técnicas de automação,
tornando-o adequado para uso em um script automatizado de construção:</para>

<screen><userinput>yes | ./blfs-yes-test2 &gt; blfs-yes-test2.log 2&gt;&amp;1</userinput></screen>

    <para>Se desejado, emita <command>tail blfs-yes-test2.log</command> para ver o
final da saída gerada paginada e a confirmação de que <keycap>y</keycap> foi
passada ao longo para o script. Tão logo satisfeito que ele funciona como
deveria, você possivelmente remova o script e o arquivo de registro.</para>

    <para>Finalmente, tenha em mente que existem muitas maneiras de automatizar e (ou)
roteirizar os comandos de construção. Não existe maneira única
<quote>correta</quote> para fazê-lo. Sua imaginação é o único limite.</para>

  </sect2>

  <sect2>
    <title>Dependências</title>

    <para>Para cada pacote descrito, o BLFS lista as dependências conhecidas. Essas
são listadas sob vários títulos, cujo significado é como segue:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Exigida</emphasis> significa que o pacote alvo não consegue ser
corretamente construído sem a dependência tendo primeiro sido instalada.</para>
      </listitem>
      <listitem>
        <para><emphasis>Recomendada</emphasis> significa que o BLFS enfaticamente sugere
que esse pacote seja instalado primeiro para uma construção limpa e livre de
problemas; que não teria problemas seja durante o processo de construção,
seja em tempo de execução. As instruções no livro assumem que esses pacotes
estejam instalados. Algumas mudanças ou gambiarras possivelmente sejam
exigidas se esses pacotes não estiverem instalados.</para>
      </listitem>
      <listitem>
        <para><emphasis>Opcional</emphasis> significa que esse pacote poderia estar
instalado para funcionalidade adicionada. Frequentemente o BLFS descreverá a
dependência para explicar a funcionalidade adicionada que resultará.</para>
      </listitem>
    </itemizedlist>

  </sect2>

  <sect2 id="package_updates">
    <title>Usando os Fontes Mais Atuais de Pacote</title>

    <para>Ocasionalmente você possivelmente se encontre em uma situação no livro onde
um pacote não construirá ou não funcionará adequadamente. Apesar dos(as)
Editores(as) tentarem garantir que cada pacote no livro construa e funcione
adequadamente, ocasionalmente um pacote tenha sido negligenciado ou não foi
testado com esta versão particular do BLFS.</para>

    <para>Se você descobrir que um pacote não construirá ou não funcionará
adequadamente, [então] você deveria ver se existe uma versão mais recente do
pacote. Tipicamente isso significa você ir ao sítio da web do(a)
mantenedor(a) e transferir o tarball mais recente e tentar construir o
pacote. Se você não conseguir determinar o sítio da web do(a) mantenedor(a)
olhando para os URLs de transferência, [então] use o Google e consulte o
nome do pacote. Por exemplo, na barra de pesquisa do Google, digite:
'nome_do_pacote download' (omita as aspas) ou algo
semelhante. Ocasionalmente, digitar: 'nome_do_pacote home page' resultará em
você encontrar o sítio da web do(a) mantenedor(a).</para>

  </sect2>

  <sect2 id="stripping">
    <title>Despojando Mais Uma Vez</title>

    <para>
      No LFS, a remoção de símbolos de depuração e entradas desnecessárias na
tabela de símbolos foi discutida algumas vezes. Ao construir pacotes BLFS,
geralmente não existem instruções especiais que discutam a remoção
novamente. A remoção pode ser feita durante a instalação de um pacote ou
posteriormente.
    </para>

    <bridgehead renderas="sect3" id="stripping-install">Despojando enquanto se Instala um Pacote</bridgehead>

    <para>
      Existem várias maneiras de se despojar executáveis instalados por um
pacote. Elas dependem do sistema de construção usado (veja-se abaixo <link
linkend="buildsystems">a seção acerca de sistemas de construção</link>), de
modo que somente algumas generalidades podem ser listadas aqui:
    </para>

    <note>
      <para>
        Os métodos a seguir que usam o recurso de um sistema de construção
("autotools", "meson" ou "cmake") não despojarão bibliotecas estáticas, se
alguma estiver instalada. Felizmente não existem muitas bibliotecas
estáticas no BLFS, e uma biblioteca estática sempre pode ser despojada com
segurança executando <command>strip --strip-unneeded</command> nela
manualmente.
      </para>
    </note>

    <itemizedlist>
      <listitem>
        <para>
          Os pacotes que usam "Autotools" geralmente tem um alvo
<parameter>install-strip</parameter> nos arquivos
<filename>Makefile</filename> gerados deles. Portanto, instalar executáveis
despojados é apenas uma questão de usar <command>make
install-strip</command> em vez de <command>make install</command>.
        </para>
      </listitem>
      <listitem>
        <para>
          Os pacotes que usam o sistema de construção "Meson" conseguem aceitar
<parameter>-Dstrip=true</parameter> ao executar <command>meson</command>. Se
esqueceu de adicionar essa opção executando o <command>meson</command>,
[então] você também consegue executar <command>meson install
--strip</command> em vez de <command>ninja install</command>.
        </para>
      </listitem>
      <listitem>
        <para>
          <command>cmake</command> gera alvos <parameter>install/strip</parameter>
para ambos os geradores <parameter>Unix Makefiles</parameter> e
<parameter>Ninja</parameter> (o padrão é <parameter>Unix
Makefiles</parameter> no Linux). Portanto, basta executar <command>make
install/strip</command> ou <command>ninja install/strip</command> em vez das
contrapartes <command>install</command>.
        </para>
      </listitem>
      <listitem>
        <para>
          A remoção (ou não geração) de símbolos de depuração também consegue ser
obtida removendo-se as opções <parameter>-g&lt;alguma_coisa&gt;</parameter>
em chamadas &quot;C/C++&quot;. Como fazer isso é muito específico para cada
pacote. E não remove entradas desnecessárias da tabela de
símbolos. Portanto, não será explicado em detalhes aqui. Veja-se também
abaixo os parágrafos acerca de otimização.
        </para>
      </listitem>
    </itemizedlist>

    <bridgehead renderas="sect3" id="stripping-installed">Despojando Executáveis Instalados</bridgehead>

    <para>
      O utilitário <command>strip</command> muda arquivos no lugar, o que
possivelmente quebre alguma coisa que os usem se estiverem carregados na
memória. Observe que se um arquivo estiver em uso, mas recém removido, do
disco (ou seja, não sobrescrito nem modificado), isso não será um problema,
pois o núcleo consegue usar arquivos <quote>deletados</quote>. Veja-se
<filename>/proc/*/maps</filename> e é provável que você veja algumas
entradas <emphasis>(deleted)</emphasis>. O <command>mv</command> apenas
remove o arquivo de destino a partir do diretório, mas não toca no conteúdo
dele, de modo que satisfaça a condição para o núcleo usar o arquivo antigo
(deletado). O script abaixo é apenas um exemplo. Ele deveria ser executado
como o(a) usuário(a) &root;:
    </para>

<screen><userinput>cat &gt; /usr/sbin/strip-all.sh &lt;&lt; "EOF"
<literal>#!/usr/bin/bash

if [ $EUID -ne 0 ]; then
  echo "Precisa ser root"
  exit 1
fi

{ find /usr/lib -type f -name '*.so*' ! -name '*dbg'
  find /usr/lib -type f -name '*.a'
  find /usr/{bin,sbin,libexec} -type f
} |  while read file; do
       if ! readelf -h $file >/dev/null 2>&amp;1; then continue; fi
       if file $file | grep --quiet --invert-match 'not stripped'; then continue; fi

       cp --preserve $file    ${file}.tmp
       strip --strip-unneeded ${file}.tmp
       mv ${file}.tmp $file
     done</literal>
EOF
chmod 744 /usr/sbin/strip-all.sh</userinput></screen>

    <para>
      Se você instalar aplicativos em outros diretórios, como <filename
class="directory">/opt</filename> ou <filename
class="directory">/usr/local</filename>, você possivelmente queira despojar
os arquivos lá também . Basta adicionar outros diretórios a escanear na
lista composta de comandos <command>find</command> entre chaves.
    </para>

    <para>
      Para mais informações acerca de despojamento, veja-se <ulink
url="https://www.technovelty.org/linux/stripping-shared-libraries.html"/>.
    </para>

  </sect2>


  <!--
  <sect2 id="libtool">

    <title>Libtool files</title>

    <para>
      One of the side effects of packages that use Autotools, including
      libtool, is that they create many files with an .la extension.  These
      files are not needed in an LFS environment.  If there are conflicts with
      pkgconfig entries, they can actually prevent successful builds.  You
      may want to consider removing these files periodically:
    </para>

<screen><userinput>find /lib /usr/lib -not -path "*Image*" -a -name \*.la -delete</userinput></screen>

    <para>
      The above command removes all .la files with the exception of those that
      have <quote>Image</quote> or <quote>openldap</quote> as a part of the
      path.  These .la files are used by the ImageMagick and openldap programs,
      respectively.  There may be other exceptions by packages not in BLFS.
    </para>

  </sect2>
-->
<sect2 id="buildsystems">
    <title>Trabalhando com diferentes sistemas de construção</title>

    <para>
      Existem, agora, três sistemas de construção em uso comum para converter
código fonte C ou C++ em aplicativos ou bibliotecas compilados(as) e os
detalhes deles (particularmente, descobrir acerca de opções disponíveis e os
valores padrão delas) diferem. Possivelmente seja mais fácil entender os
problemas causados por algumas escolhas (tipicamente, execução lenta; ou uso
inesperado de, ou omissão de, otimizações) iniciando-se com as variáveis de
ambiente CFLAGS e CXXFLAGS. Também existem alguns aplicativos que usam rust.
    </para>

    <para>
      A maioria dos(as) construtores(as) do LFS e do BLFS provavelmente está
ciente dos básicos de CFLAGS e CXXFLAGS para alterar como um aplicativo é
compilado. Tipicamente, alguma forma de otimização é usada pelos(as)
desenvolvedores(as) de aplicativos (-O2 ou -O3), ocasionalmente com a
criação de símbolos de depuração (-g), como padrões.
    </para>

    <para>
      Se existirem sinalizadores contraditórios (por exemplo, múltiplos valores
-O), [então] o <emphasis>último</emphasis> valor será usado. Ocasionalmente,
isso significa que os sinalizadores especificados em variáveis de ambiente
serão escolhidos antes dos valores codificados rigidamente no Makefile, e,
portanto, ignorados. Por exemplo, onde um(a) usuário(a) especificar '-O2' e
isso for seguido por '-O3', a construção usará '-O3'.
    </para>

    <para>
      Existem várias outras coisas que podem ser passadas em CFLAGS ou em
CXXFLAGS, tais como forçar-se a compilação para uma microarquitetura
específica (por exemplo, -march=amdfam10; -march=native) ou especificar-se
um padrão específico para C ou C++ (-std=c++17, por exemplo). Porém, uma
coisa que agora veio à tona é que os(as) programadores(as) poderiam incluir
asserções de depuração no código deles(as), esperando que sejam
desabilitados em lançamentos usando-se -DNDEBUG. Especificamente, se o <xref
linkend="mesa"/> for construído com essas asserções habilitadas, [então]
algumas atividades, tais como o carregamento de níveis dos jogos, podem
tomar tempos extremamente longos, mesmo em placas de vídeo de alta
qualidade.
    </para>

    <bridgehead renderas="sect3" id="autotools-info">Autotools com Make</bridgehead>

      <para>
       Essa combinação frequentemente é descrita como 'CMMI' (configure; make; make
install) e é usada aqui também para cobrir os poucos pacotes que tem um
script de configuração que não é gerado por autotools.
      </para>

      <para>
        Ocasionalmente, executar-se <command>./configure --help</command> produzirá
opções úteis acerca de chaves que poderiam ser usadas. Em outras ocasiões,
depois de olhar para a saída gerada a partir do configure, você
possivelmente precise olhar para os detalhes do script para descobrir pelo
que ele estava procurando atualmente.
      </para>

      <para>
       Muitos scripts de configuração escolherão quaisquer CFLAGS ou CXXFLAGS a
partir do ambiente, porém os pacotes CMMI variam acerca do como esses serão
misturados com quaisquer sinalizadores que, de outra maneira, seriam usados
(<emphasis>variadamente</emphasis>: ignorados; usados para substituir a
sugestão do(a) programador(a); usados antes da sugestão do(a)
programador(a); ou usados depois da sugestão do(a) programador(a)).
      </para>

      <para>
       Na maioria dos pacotes CMMI, executar-se 'make' listará cada comando e o
executará, intercalado com quaisquer avisos. Porém, alguns pacotes tentam
ser 'silenciosos' e mostram somente qual arquivo eles estão compilando ou
vinculando em vez de mostrar a linha de comando. Se você precisar
inspecionar o comando, seja por causa de um erro, seja apenas para ver quais
opções e sinalizadores estão sendo usados, [então] adicionar 'V=1' à
invocação do make possivelmente ajude.
     </para>

    <bridgehead renderas="sect3" id="cmake-info">CMake</bridgehead>

      <para>
        O CMake funciona de uma maneira muito diferente e ele tem duas estruturas de
retaguarda que conseguem ser usadas no BLFS: 'make' e 'ninja'. A estrutura
de retaguarda padrão é o make, porém o ninja pode ser mais rápido sobre
pacotes largos com múltiplos processadores. Para usar o ninja, especifique
'-G Ninja' no comando cmake. Entretanto, existem alguns pacotes que criam
erros fatais nos arquivos ninja deles, porém constroem com sucesso usando o
padrão dos Makefiles do Unix.
      </para>

      <para>
        A parte mais difícil do usar-se o CMake é saber quais opções você poderia
desejar especificar. A única maneira de se obter uma lista do que o pacote
conhece é a de executar <command>cmake -LAH</command> e olhar para a saída
gerada para esta configuração padrão.
      </para>

      <para>
        Talvez a coisa mais importante acerca do CMake é que ele tem uma variedade
de valores CMAKE_BUILD_TYPE e esses afetam os sinalizadores. O padrão é o de
que isso não é configurado e nenhum sinalizador é gerado. Quaisquer CFLAGS
ou CXXFLAGS no ambiente serão usados. Se o(a) programador(a) tiver
codificado quaisquer asserções de depuração, [então] essas serão
habilitadas, a menos que -&nbsp;DNDEBUG seja usado. Os seguintes valores
CMAKE_BUILD_TYPE gerarão os sinalizadores mostrados e esses virão
<emphasis>depois de</emphasis> quaisquer sinalizadores no ambiente e,
portanto, terão precedência.
      </para>

      <informaltable align="center">
        <tgroup cols="2">
          <colspec colnum="1" align="center"/>
          <colspec colnum="2" align="center"/>
          <thead>
            <row><entry>Valor</entry><entry>Sinalizadores</entry></row>
          </thead>
          <tbody>
            <row>
              <entry>Debug</entry><entry><option>-g</option></entry>
            </row>
            <row>
              <entry>Release</entry><entry><option>-O3 -DNDEBUG</option></entry>
            </row>
            <row>
              <entry>RelWithDebInfo</entry><entry><option>-O2 -g -DNDEBUG</option></entry>
            </row>
            <row>
              <entry>MinSizeRel</entry><entry><option>-Os -DNDEBUG</option></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>
        O "CMake" tenta produzir construções silenciosas. Para ver os detalhes dos
comandos que estão sendo executados, use <command>make VERBOSE=1</command>
ou <command>ninja -v</command>.
      </para>

      <para>
        Por padrão, o "CMake" trata a instalação de arquivos diferentemente dos
outros sistemas de construção: se um arquivo já existir e não for mais
recente que um arquivo que o sobrescreveria, então o arquivo não será
instalado. Isso possivelmente seja um problema se um(a) usuário(a) quiser
registrar qual arquivo pertence a um pacote, seja usando
<envar>LD_PRELOAD</envar>, ou listando arquivos mais recentes que um carimbo
de tempo. O padrão pode ser mudado definindo-se a variável
<envar>CMAKE_INSTALL_ALWAYS</envar> como um ("1") no
<emphasis>ambiente</emphasis>, por exemplo, via <command>export</command>.
      </para>

    <bridgehead renderas="sect3" id="meson-info">Meson</bridgehead>

      <para>
        O Meson tem algumas semelhanças com o CMake, porém muitas diferenças. Para
obter os detalhes das definições que você possivelmente queira mudar, você
pode olhar para o <filename>meson_options.txt</filename> que normalmente
está no diretório de nível de topo.
      </para>

      <para>
        Se você já configurou o pacote executando o <command>meson</command> e,
agora, deseja mudar uma ou mais configurações, [então] você ou pode remover
o diretório de construção, recriá-lo e usar as opções alteradas; ou, dentro
do diretório de construção, executar <command>meson configure</command>, por
exemplo, para configurar uma opção:
      </para>

<screen><userinput>meson configure -D&lt;alguma_opção&gt;=true</userinput></screen>

      <para>
        Se você fizer isso, [então] o arquivo
<filename>meson-private/cmd_line.txt</filename> mostrará os
<emphasis>últimos</emphasis> comandos que foram usados.
      </para>

      <para>
        O Meson fornece os seguintes valores de tipo de construção e os
sinalizadores que eles habilitam vem <emphasis>depois</emphasis> de
quaisquer sinalizadores fornecidos no ambiente e, portanto, tem precedência.
      </para>

      <itemizedlist>
        <listitem>
          <para>plano : nenhum sinalizador adicionado. Isso é para os(as) distribuidores(as)
fornecerem os próprios CFLAGS, CXXFLAGS e LDFLAGS deles(as). Não existe
razão óbvia para usar isso no BLFS.</para>
        </listitem>
        <listitem>
          <para>depuração : '-g' - isso é o padrão, se nada for especificado, seja no
<filename>meson.build</filename>, seja na linha de comando. Entretanto,
resulta em binários largos e lentos, de forma que nós deveríamos
substitui-lo no BLFS.</para>
        </listitem>
        <listitem>
           <para>depuração otimizada : '-O2 -g' : isso é o padrão, especificado no
<filename>meson.build</filename>, de alguns pacotes.</para>
        </listitem>
        <listitem>
           <para>lançamento : '-O3 -DNDEBUG' (porém, ocasionalmente, um pacote forçará -O2
aqui)</para>
        </listitem>
      </itemizedlist>

      <para>
        Apesar do tipo de construção 'lançamento' estar descrito como habilitante do
-DNDEBUG e todas as construções CMake Release passarem isso, tem, até agora,
somente sido observado (em construções verbosas) para o <xref
linkend="mesa"/>. Isso sugere que somente poderia ser usado quando existirem
asserções de depuração presentes.
      </para>

      <para>
        O sinalizador -DNDEBUG também pode ser fornecido passando-se
<command>-Db_ndebug=true</command>.
      </para>

      <para>
        Para ver os detalhes dos comandos que estão sendo executados em um pacote
usando o meson, use 'ninja -v'.
      </para>

    <bridgehead renderas="sect3" id="rust-info">Rustc e Cargo</bridgehead>

      <para>
        A maioria dos aplicativos rustc lançados é fornecida como engradado
(tarballs de fonte), que consultarão um servidor para verificar as versões
atuais de dependências e, então, as transferirão conforme necessário. Esses
pacotes são construídos usando-se <command>cargo --release</command>. Na
teoria, você consegue manipular o RUSTFLAGS para mudar o nível de otimização
(padrão é 3, semelhante a -03; por exemplo,
<literal>-Copt-level=3</literal>) ou para forçá-lo a construir para a
máquina na qual está sendo compilado, usando
<literal>-Ctarget-cpu=native</literal>; porém, na prática, isso parece não
fazer uma diferença significante.
      </para>

      <para>
        Se você encontrar um aplicativo rustc interessante que seja fornecido apenas
como fonte desempacotado, [então] você deveria, pelo menos, especificar
<literal>RUSTFLAGS=-Copt-level=2</literal>; do contrário, fará uma
compilação não otimizada, com informação de depuração e executará
<emphasis>muito</emphasis> mais lento.
      </para>

      <para>
        Os(As) desenvolvedores(as) do rust parecem presumir que todos compilarão em
uma máquina dedicada a produzir construções, de forma que, por padrão, todas
as CPUs serão usadas. Isso, frequentemente, pode ser contornado, seja
exportando-se CARGO_BUILD_JOBS=&lt;N&gt;, seja passando-se --jobs &lt;N&gt;
para o cargo. Para compilar o próprio rustc, especificar-se --jobs &lt;N&gt;
em invocações de x.py (junto com a variável de ambiente
<envar>CARGO_BUILD_JOBS</envar>, que se parece com uma abordagem "cinto e
suspensórios", porém parece ser necessária) na maioria das vezes funciona. A
exceção é a de executar-se os testes quando construir-se o rustc; alguns
deles, ainda assim, usarão todas as CPUs online, pelo menos desde o
rustc-1.42.0.
      </para>

  </sect2>

  <sect2 id="optimizations">
    <title>Otimizando a construção</title>

      <para>
        Muitas pessoas preferirão otimizar compilações como acharem melhor,
fornecendo CFLAGS ou CXXFLAGS. Para uma introdução às opções disponíveis com
o gcc e com o g++, veja-se <ulink
url="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html"/>; e <ulink
url="https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html"/>; e
<command>info gcc</command>.

      </para>

      <para>
        Alguns pacotes padronizam para '-O2 -g'; outros para '-O3 -g'; e, se CFLAGS
ou CXXFLAGS forem fornecidos, [então] eles poderiam ser adicionados aos
padrões do pacote; substituir os padrões do pacote; ou até serem
ignorados. Existem detalhes acerca de alguns pacotes de área de trabalho que
eram na maioria das vezes atuais em abril de 2019 em <ulink
url="https://www.linuxfromscratch.org/~ken/tuning/"/> - em particular,
README.txt, tuning-1-packages-and-notes.txt e tuning-notes-2B.txt. A coisa
particular a se lembrar é a de que, se você quiser tentar algum dos mais
interessantes sinalizadores, [então] você possivelmente precise forçar
construções verbosas para confirmar o que está sendo usado.
      </para>

      <para>
        Claramente, se você estiver otimizando seu próprio aplicativo, [então] você
pode gastar tempo para perfilá-lo e, talvez, re-codificar algo dele, se ele
estiver lento demais. Porém, para construir um sistema inteiro, essa
abordagem é impraticável. No geral, -O3 geralmente produz aplicativos mais
rápidos que -O2. Especificar-se -march=native também é benéfico, porém
significa que você não pode mover os binários para uma máquina incompatível
- isso também pode se aplicar a máquinas mais novas, não apenas às máquinas
mais antigas. Por exemplo, os aplicativos compilados para 'amdfam10'
executam em Phenoms antigos; Kaveris; e Ryzens; porém, os aplicativos
compilados para um Kaveri não executarão em um Ryzen, pois certos códigos de
operação não estão presentes. Similarmente, se você construir para um
Haswell, [então] nem tudo executará em um SandyBridge.
      </para>

      <para>
        Existem também várias outras opções que algumas pessoas alegam que são
benéficas. Na pior das hipóteses, você consegue recompilar e testar e,
então, descobrir que, em seu uso, as opções não fornecem um benefício.
      </para>

      <para>
        Se construir módulos do Perl ou do Python; ou pacotes do Qt que usam o
qmake, [então], no geral, os CFLAGS e CXXFLAGS usados são aqueles que foram
usados por aqueles pacotes 'ancestrais'.
      </para>

  </sect2>

  <sect2 id="hardening">
    <title>Opções para fortalecer a construção</title>

      <para>
        Mesmo em sistemas de área de trabalho, existe ainda um monte de
vulnerabilidades exploráveis. Para muitas dessas, o ataque vem via
javascript em um navegador. Frequentemente, uma série de vulnerabilidades é
usada para ganhar acesso a dados (ou, às vezes, para pwn, isto é, dominar, a
máquina e instalar rootkits). A maioria das distribuições comerciais
aplicará várias medidas de fortalecimento.
      </para>

      <para>
        No passado, existia o "LFS Reforçado", onde o "GCC" (uma versão muito mais
antiga) era forçado a usar reforçamento (com opções para desativar parte
dele por pacote). Os livros atuais LFS e BLFS estão levando adiante uma
parte do espírito dele, habilitando "PIE" (<option>-fPIE -pie</option>) e
"SSP" (<option>-fstack-protector-strong</option>) como padrões para o "GCC"
e o "clang". O que está sendo abordado aqui é diferente - primeiro, você
precisa ter certeza de que o pacote está realmente usando os teus
sinalizadores adicionados e não os substituindo.
      </para>

      <para>
        Para opções de reforço que são razoavelmente baratas, existe alguma
discussão no link "ajuste" acima (ocasionalmente, uma ou mais dessas opções
podem ser inadequadas para um pacote). Essas opções são
<option>-D_FORTIFY_SOURCE=2</option> e (para "C++")
<option>-D_GLIBCXX_ASSERTIONS</option>. Nas máquinas modernas, isso deveria
ter somente um pequeno impacto na rapidez com que as coisas funcionam e,
muitas vezes, não serão perceptíveis.
      </para>

      <para>
        As principais distribuições usam muito mais, como "RELRO" ("Relocation Read
Only") e talvez <option>-fstack-clash-protection</option>. Você também
possivelmente encontre a chamada <quote>retpoline do espaço de
usuário(a)</quote> (<option>-mindirect-branch=thunk</option> etc.), que é o
equivalente às mitigações de espectro aplicadas ao núcleo Linux no final de
2018. As mitigações do núcleo causaram muitas reclamações acerca de perda de
desempenho; se você tiver um servidor de produção, você pode desejar
considerar testá-las, juntamente com outras opções disponíveis, para ver se
o desempenho ainda é suficiente.
      </para>

      <para>
        Embora o gcc tenha muitas opções de fortalecimento, os pontos fortes do
clang/LLVM estão em outro lugar. Algumas opções que o gcc fornece são ditas
serem menos efetivas no clang/LLVM.
      </para>

  </sect2>

</sect1>
