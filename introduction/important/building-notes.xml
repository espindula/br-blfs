<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="unpacking">
  <?dbhtml filename="notes-on-building.html"?>


  <title>Observações Acerca de Construir Software</title>

  <para>Aquelas pessoas que tenham construído um sistema LFS possivelmente estejam
cientes dos princípios gerais da transferência e do desempacotamento de
software. Alguma daquela informação está repetida aqui para aquelas novatas
em construir o próprio software delas.</para>

  <para>Cada conjunto de instruções de instalação contém um URL a partir do qual
você pode transferir o pacote. Os remendos, no entanto, estão armazenados
nos servidores do LFS e estão disponíveis via HTTP. Esses estão
referenciados conforme necessários nas instruções de instalação.</para>

  <para>While you can keep the source files anywhere you like, we assume that you
have unpacked the package and changed into the directory created by the
unpacking process (the source directory).  We also assume you have
uncompressed any required patches and they are in the directory immediately
above the source directory.</para>

  <para>Nós não podemos enfatizar fortemente o suficiente que você deveria iniciar a
partir de uma <emphasis>árvore limpa do fonte</emphasis> a cada vez. Isso
significa que, se você tiver tido um erro durante a configuração ou a
compilação, [então] geralmente é melhor deletar a árvore do fonte e
desempacotá-la outra vez <emphasis>antes de</emphasis> tentar
novamente. Isso, obviamente, não se aplica se você for um(a) usuário(a)
avançado(a) habituado(a) a hackear <filename>Makefile</filename>s e código
C; porém, se em dúvida, [então] inicie a partir de uma árvore limpa.</para>

  <sect2>
    <title>Construindo Software como um(a) Usuário(a) Não Privilegiado(a) (não root)</title>

    <para>A regra de ouro da Administração do Sistema Unix é a de usar os seus super
poderes somente quando necessário. Assim, o BLFS recomenda que você construa
software como um(a) usuário(a) não privilegiado(a) e somente se torne o(a)
usuário(a) <systemitem class='username'>root</systemitem> quando instalar o
software. Essa filosofia é seguida em todos os pacotes neste livro. A menos
que especificado de outra maneira, todas as instruções deveriam ser
executadas como um(a) usuário(a) não privilegiado(a). O livro alertará você
acerca de instruções que precisarem de privilégios do(a) <systemitem
class='username'>root</systemitem>.</para>

  </sect2>

  <sect2>
    <title>Desempacotando o Software</title>

    <para>Se um arquivo estiver no formato <filename class='extension'>.tar</filename>
e comprimido, [então] ele é desempacotado executando-se um dos seguintes
comandos:</para>

<screen><userinput>tar -xvf nome_arquivo.tar.gz
tar -xvf nome_arquivo.tgz
tar -xvf nome_arquivo.tar.Z
tar -xvf nome_arquivo.tar.bz2</userinput></screen>

    <note>
      <para>Você possivelmente omita o uso do parâmetro <option>v</option> nos comandos
mostrados acima e abaixo se você desejar suprimir a listagem verbosa de
todos os arquivos no arquivamento conforme eles forem extraídos. Isso pode
ajudar a acelerar a extração, bem como torna quaisquer erros produzidos
durante a extração mais óbvios para você.</para>
    </note>

    <para>Você também pode usar um método ligeiramente diferente:</para>

<screen><userinput>bzcat nome_arquivo.tar.bz2 | tar -xv</userinput></screen>

    <para>
      Finally, sometimes we have a compressed patch file in <filename
class='extension'>.patch.gz</filename> or <filename
class='extension'>.patch.bz2</filename> format.  The best way to apply the
patch is piping the output of the decompressor to the
<command>patch</command> utility.  For example:
    </para>

    <screen><userinput>gzip -cd ../patchname.patch.gz | patch -p1</userinput></screen>

    <para>
      Or for a patch compressed with <command>bzip2</command>:
    </para>

    <screen><userinput>bzcat ../patchname.patch.bz2 | patch -p1</userinput></screen>

  </sect2>

  <sect2>
    <title>Averiguando a Integridade do Arquivo</title>

    <para>Geralmente, para se averiguar se o arquivo transferido está completo,
muitos(as) mantenedores(as) de pacote também distribuem somas de verificação
md5 dos arquivos. Para averiguar a soma de verificação md5 dos arquivos
transferidos, transfira ambos, o arquivo e o arquivo correspondente de soma
de verificação md5, para o mesmo diretório (preferencialmente a partir de
locais diferentes online) e (assumindo que
<filename>arquivo.md5sum</filename> seja o arquivo de soma de verificação
md5 transferido) execute o seguinte comando:</para>

<screen><userinput>md5sum -c arquivo.md5sum</userinput></screen>

    <para>Se existirem quaisquer erros, [então] eles serão informados. Observe que o
livro BLFS inclui somas de verificação md5 para todos os arquivos de fonte
também. Para usar as somas de verificação md5 fornecidas pelo BLFS, você
pode criar um <filename>arquivo.md5sum</filename> (coloque os dados da soma
de verificação md5 e o nome exato do arquivo transferido na mesma linha de
um arquivo, separados por espaço em branco) e executar o comando mostrado
acima. Alternativamente, simplesmente execute o comando mostrado abaixo e
compare a saída gerada para os dados da soma de verificação md5 mostrada no
livro BLFS.</para>

<screen><userinput>md5sum <replaceable>&lt;nome_do_arquivo_transferido&gt;</replaceable></userinput></screen>

    <para>MD5 não é seguro criptograficamente, de forma que as somas de verificação
md5 são fornecidas somente para se detectar mudanças não maliciosas para o
conteúdo do arquivo. Por exemplo, um erro ou truncamento introduzido durante
a transferência de rede de comunicação; ou uma atualização
<quote>furtiva</quote> para o pacote oriunda do(a) desenvolvedor(a)
(atualizando o conteúdo de um tarball liberado em vez de fazer um lançamento
novo adequadamente).</para>

    <para>Não existe maneira <quote>100%</quote> segura de garantir a genuinidade dos
arquivos do fonte. Assumindo que o(a) desenvolvedor(a) esteja gerenciando
corretamente o sítio da web dele(a) (a chave privada não vazou e o domínio
não esteja sequestrado); e que as âncoras de confiança tenham sido
configuradas corretamente usando <xref linkend="make-ca"/> no sistema BLFS;
nós podemos razoavelmente confiar nos URLs de transferência para o sítio
oficial da web do(a) desenvolvedor(a) <emphasis role="bold">com protocolo
https</emphasis>. Observe que o próprio livro BLFS está publicado em um
sítio da web com https, de forma que você já deveria ter alguma confiança no
protocolo https ou você não confiaria no conteúdo do livro.</para>

    <para>Se o pacote for transferido a partir de um local não oficial (por exemplo,
um espelho local), [então] as somas de verificação geradas por algoritmos de
resumo criptograficamente seguros (por exemplo, SHA256) podem ser usadas
para averiguar a genuinidade do pacote. Transfira o arquivo da soma de
verificação a partir do sítio da web <emphasis
role="bold">oficial</emphasis> do(a) desenvolvedor(a) (ou algum lugar que
<emphasis role="bold">você possa confiar</emphasis>) e compare a soma de
verificação do pacote oriunda do local não oficial com ele. Por exemplo, a
soma de verificação SHA256 pode ser verificada com o comando:</para>

    <note>
      <para>Se a soma de verificação e o pacote forem transferidos a partir do mesmo
local não confiável, [então] você não ganharia melhoramento de segurança
averiguando o pacote com a soma de verificação. O(A) atacante pode falsear a
soma de verificação assim como comprometer o próprio pacote.</para>
    </note>

<screen><userinput>sha256sum -c <replaceable>arquivo</replaceable>.sha256sum</userinput></screen>

    <para>Se o <xref linkend="gnupg2"/> estiver instalado, [então] você também pode
averiguar a genuinidade do pacote com uma assinatura GPG. Importe a chave
pública GPG do(a) desenvolvedor(a) com:</para>

<screen><userinput>gpg --recv-key <replaceable>ID_da_chave</replaceable></userinput></screen>

    <para><replaceable>ID_da_chave</replaceable> deveria ser substituído pelo ID da
chave oriundo de algum lugar que <emphasis role="bold">você possa
confiar</emphasis> (por exemplo, copie-o a partir do sítio da web oficial
do(a) desenvolvedor(a) usando https). Agora, você consegue averiguar a
assinatura com:</para>

<screen><userinput>gpg --recv-key <replaceable>arquivo</replaceable>.sig <replaceable>arquivo</replaceable></userinput></screen>

    <para>A vantagem da assinatura <application>GnuPG</application> é, tão logo você
importou uma chave pública que possa ser confiada, você pode transferir
ambos, o pacote e a assinatura dele, a partir do mesmo local não oficial e
averiguá-los com a chave pública. Assim, você não precisaria conectar com o
sítio da web oficial do(a) desenvolvedor(a) para ir buscar uma soma de
verificação para cada lançamento novo. Você somente precisa atualizar a
chave pública se ela estiver expirada ou revogada.
    </para>

  </sect2>

  <sect2>
    <title>Criando Arquivos de Registro Durante a Instalação</title>

    <para>Para pacotes mais largos, é conveniente se criar arquivos de registro em vez
de olhar fixamente para a tela esperando pegar um erro ou aviso em
particular. Os arquivos de registro também são úteis para depuração e para
manter registros. O seguinte comando permite a você criar um registro da
instalação. Substitua <replaceable>&lt;comando&gt;</replaceable> pelo
comando que você pretende executar.</para>

<screen><userinput>( <replaceable>&lt;comando&gt;</replaceable> 2&gt;&amp;1 | tee compile.log &amp;&amp; exit $PIPESTATUS )</userinput></screen>

    <para><option>2&gt;&amp;1</option> redireciona as mensagens de erro para o mesmo
local que a saída gerada padrão. O comando <command>tee</command> permite
visualizar a saída gerada enquanto se registra os resultados em um
arquivo. Os parênteses em volta do comando executam o comando inteiro em um
sub shell; e, finalmente, o comando <command>exit $PIPESTATUS</command>
garante que o resultado do <replaceable>&lt;comando&gt;</replaceable> seja
retornado como o resultado e não o resultado do comando
<command>tee</command>.</para>

  </sect2>

  <sect2 id="parallel-builds" xreflabel="Usando Múltiplos Processadores">
    <title>Usando Múltiplos Processadores</title>

    <para>For many modern systems with multiple processors (or cores) the compilation
time for a package can be reduced by performing a "parallel make" by either
setting an environment variable or telling the make program how many
processors are available. For instance, a Core2Duo can support two
simultaneous processes with: </para>

    <screen><userinput>export MAKEFLAGS='-j2'</userinput></screen>

    <para>ou apenas construir com:</para>

    <screen><userinput>make -j2</userinput></screen>

    <para>
      Se você tiver aplicado o <command>sed</command> opcional quando da
construção do <application>ninja</application> no LFS, [então] você pode
usar:
    </para>

    <screen><userinput>export NINJAJOBS=2</userinput></screen>

    <para>
      quando um pacote usar o <command>ninja</command>; ou apenas:
    </para>

    <screen><userinput>ninja -j2</userinput></screen>

    <para>
      but for ninja, the default number of jobs is N + 2, if the number of logical
processors N is greater than 2; or N + 1 if N is 1 or 2.  The reason to use
a number of jobs slightly greater than the number of logical processors is
keeping all logical processors busy even if some jobs are performing I/O
operations.
    </para>

    <para>Generally the number of processes should not exceed the number of cores
supported by the CPU too much.  To list the processors on your system,
issue: <userinput>grep processor /proc/cpuinfo</userinput>.
    </para>

    <para>In some cases, using multiple processes may result in a race condition where
the success of the build depends on the order of the commands run by the
<command>make</command> program.  For instance, if an executable needs File
A and File B, attempting to link the program before one of the dependent
components is available will result in a failure.  This condition usually
arises because the upstream developer has not properly designated all the
prerequisites needed to accomplish a step in the Makefile.</para>

    <para>If this occurs, the best way to proceed is to drop back to a single
processor build.  Adding <option>-j1</option> to a make command will
override the similar setting in the <envar>MAKEFLAGS</envar> environment
variable.</para>

    <!-- outdated
    <note>
<para>When running the package tests or the install portion of the
    package build process, we do not recommend using an option greater than
    '-j1' unless specified otherwise.  The installation procedures or checks
    have not been validated using parallel procedures and may fail with issues
    that are difficult to debug.</para></note>
-->
<important>
      <para>
        Outro problema possivelmente ocorra com CPUs modernas, as quais tem um monte
de núcleos. Cada trabalho iniciado consome memória e, se a soma da memória
necessária para cada trabalho exceder da memória disponível, [então] você
possivelmente encontre, ou uma interrupção de kernel Out of Memory (OOM), ou
troca intensa, que retardará a construção além de limites razoáveis.
      </para>

      <para>
        Algumas compilações com o <command>g++</command> possivelmente consumam até
2,5 GB de memória, de forma que, para estar seguro(a), você deveria
restringir o número de trabalhos a (Memória Total em GB)/2,5, ao menos para
pacotes grandes, tais como o LLVM; o WebKitGtk; o QtWebEngine; ou o
Libreoffice.
      </para>
    </important>
  </sect2>

  <sect2 id="automating-builds" xreflabel="Procedimentos Automatizados de Construção">
    <title>Procedimentos Automatizados de Construção</title>

    <para>Existem ocasiões onde automatizar a construção de um pacote pode vir a
calhar. Todo mundo tem razões próprias para querer automatizar a construção
e todo mundo faz isso de maneira própria. Criar
<filename>Makefile</filename>s; scripts do <application>Bash</application>;
scripts do <application>Perl</application>; ou, simplesmente, uma lista de
comandos usados para recortar e colar, são apenas alguns dos métodos que
você pode usar para automatizar a construção de pacotes do BLFS. Detalhar
como e fornecer exemplos das muitas maneiras que você pode automatizar a
construção de pacotes está além do escopo desta seção. Esta seção exporá
você ao uso do redirecionamento de arquivo e do comando
<command>yes</command> para ajudar a fornecer ideias acerca do como
automatizar suas construções.</para>

    <bridgehead renderas="sect3">Redirecionamento de Arquivo para Automatizar a Entrada Gerada</bridgehead>

    <para>Você achará ocasiões ao longo da sua jornada BLFS quando você se deparará
com um pacote que tenha um comando solicitando informação. Essa informação
poderia ser detalhes de configuração; um caminho de diretório; ou uma
resposta a um acordo de licença. Isso pode apresentar um desafio para
automatizar a construção desse pacote. Ocasionalmente, você será
consultado(a) para diferentes informações em uma série de perguntas. Um
método para automatizar esse tipo de cenário exige colocar as respostas
desejadas em um arquivo e usar redirecionamento, de forma que o aplicativo
use os dados no arquivo como as respostas para as perguntas.</para>

    <!-- outdated
    <para>
Building the <application>CUPS</application> package is a good
    example of how redirecting a file as input to prompts can help you automate
    the build. If you run the test suite, you are asked to respond to a series
    of questions regarding the type of test to run and if you have any
    auxiliary programs the test can use. You can create a file with your
    responses, one response per line, and use a command similar to the
    one shown below to automate running the test suite:</para>

<screen><userinput>make check &lt; ../cups-1.1.23-testsuite_parms</userinput></screen>
-->
<para>Isso, efetivamente, faz com que a suíte de teste use as respostas no arquivo
como a entrada gerada para as perguntas. Ocasionalmente você possivelmente
termine fazendo um bocado de tentativa e erro para determinar o formato
exato do seu arquivo de entrada gerada para algumas coisas, porém, tão logo
determinado e documentado, você consegue usar isso para automatizar a
construção do pacote.</para>

    <bridgehead renderas="sect3">Usando o <command>yes</command> para Automatizar a Entrada Gerada</bridgehead>

    <para>Ocasionalmente você somente precisará fornecer uma resposta ou fornecer a
mesma resposta para muitas solicitações. Para tais instâncias, o comando
<command>yes</command> funciona realmente bem. O comando
<command>yes</command> pode ser usado para fornecer uma resposta (a mesma)
para uma ou mais instâncias de perguntas. Ele pode ser usado para simular o
pressionamento apenas da tecla <keycap>Enter</keycap>; informar a tecla
<keycap>Y</keycap>; ou informar uma sequência de caracteres de texto. Talvez
a maneira mais fácil de mostrar o uso dele é em um exemplo.</para>

    <para>Primeiro, crie um script curto do <application>Bash</application> informando
os seguintes comandos:</para>

<screen><userinput>cat &gt; blfs-yes-test1 &lt;&lt; "EOF"
<literal>#!/bin/bash

echo -n -e "\n\nPor favor, digite algo (ou nada) e pressione Enter ---> "

read A_STRING

if test "$A_STRING" = ""; then A_STRING="Apenas a tecla Enter foi pressionada"
else A_STRING="Você informou '$A_STRING'"
fi

echo -e "\n\n$A_STRING\n\n"</literal>
EOF
chmod 755 blfs-yes-test1</userinput></screen>

    <para>Agora execute o script emitindo <command>./blfs-yes-test1</command> a partir
da linha de comando. Ele aguardará por uma resposta, que pode ser algo (ou
nada) seguida pela tecla <keycap>Enter</keycap>. Depois de informar alguma
coisa, o resultado será ecoado para a tela. Agora use o comando
<command>yes</command> para automatizar a entrada de uma resposta:</para>

<screen><userinput>yes | ./blfs-yes-test1</userinput></screen>

    <para>Perceba que canalizar o próprio <command>yes</command> para o script resulta
em <keycap>y</keycap> sendo passada para o script. Agora tente com uma
sequência de caracteres de texto:</para>

<screen><userinput>yes 'Este é algum texto' | ./blfs-yes-test1</userinput></screen>

    <para>A sequência exata de caracteres foi usada como a resposta para o
script. Finalmente, tente usando uma sequência de caracteres vazia (nula):</para>

<screen><userinput>yes '' | ./blfs-yes-test1</userinput></screen>

    <para>Perceba que isso resulta na passagem apenas do pressionamento da tecla
<keycap>Enter</keycap> para o script. Isso é útil para ocasiões quando a
resposta padrão para a solicitação for suficiente. Essa sintaxe é usada nas
instruções do <xref linkend="net-tools-automate-example"/> para aceitar
todos os padrões para as muitas solicitações durante a etapa de
configuração. Você possivelmente agora remova o script de teste, se
desejado.</para>

    <bridgehead renderas="sect3">Redirecionamento de Arquivo para Automatizar a Saída Gerada</bridgehead>

    <para>Para a finalidade de automatizar a construção de alguns pacotes,
especialmente aqueles que exigem que você leia um acordo de licença em uma
página por vez, exige-se usar um método que evite ter que pressionar uma
tecla para exibir cada página. Redirecionar a saída gerada para um arquivo
pode ser usado nessas instâncias para auxiliar com a automação. A seção
anterior nesta página tocou na criação de arquivos de registro da saída
gerada da construção. O método de redirecionamento mostrado lá usou o
comando <command>tee</command> para redirecionar a saída gerada para um
arquivo enquanto também exibia a saída gerada na tela. Aqui, a saída gerada
somente será enviada para um arquivo.</para>

    <para>Novamente, a maneira mais fácil para demonstrar a técnica é de mostrar um
exemplo. Primeiro, emita o comando:</para>

<screen><userinput>ls -l /usr/bin | less</userinput></screen>

    <para>Of course, you'll be required to view the output one page at a time because
the <command>less</command> filter was used. Now try the same command, but
this time redirect the output to a file. The special file
<filename>/dev/null</filename> can be used instead of the filename shown,
but you will have no log file to examine:</para>

<screen><userinput>ls -l /usr/bin | less &gt; redirect_test.log 2&gt;&amp;1</userinput></screen>

    <para>Perceba que, dessa vez, o comando imediatamente retornou ao prompt do shell
sem ter que paginar ao longo da saída gerada. Você agora possivelmente
remova o arquivo de registro.</para>

    <para>O último exemplo usará o comando <command>yes</command> em combinação com o
redirecionamento da saída gerada para desviar-se de ter que paginar ao longo
da saída gerada e, então, fornecerá um <keycap>y</keycap> para uma
solicitação. Essa técnica poderia ser usada em instâncias quando, de outra
maneira, você teria que paginar ao longo da saída gerada de um arquivo (como
um acordo de licença) e, então, responder à pergunta de <quote>você aceita o
acima?</quote>. Para esse exemplo, outro script curto do
<application>Bash</application> é exigido:</para>

<screen><userinput>cat &gt; blfs-yes-test2 &lt;&lt; "EOF"
<literal>#!/bin/bash

ls -l /usr/bin | less

echo -n -e "\n\nDid you enjoy reading this? (y,n) "

read A_STRING

if test "$A_STRING" = "y"; then A_STRING="You entered the 'y' key"
else A_STRING="You did NOT enter the 'y' key"
fi

echo -e "\n\n$A_STRING\n\n"</literal>
EOF
chmod 755 blfs-yes-test2</userinput></screen>

    <para>Esse script pode ser usado para simular um aplicativo que exige que você
leia um acordo de licença, então responda apropriadamente que aceita o
acordo antes do aplicativo instalar qualquer coisa. Primeiro, execute o
script sem quaisquer técnicas de automação emitindo
<command>./blfs-yes-test2</command>.</para>

    <para>Agora emita o seguinte comando que usa duas técnicas de automação,
tornando-o adequado para uso em um script automatizado de construção:</para>

<screen><userinput>yes | ./blfs-yes-test2 &gt; blfs-yes-test2.log 2&gt;&amp;1</userinput></screen>

    <para>Se desejado, emita <command>tail blfs-yes-test2.log</command> para ver o
final da saída gerada paginada e a confirmação de que <keycap>y</keycap> foi
passada ao longo para o script. Tão logo satisfeito que ele funciona como
deveria, você possivelmente remova o script e o arquivo de registro.</para>

    <para>Finalmente, tenha em mente que existem muitas maneiras de automatizar e (ou)
roteirizar os comandos de construção. Não existe maneira única
<quote>correta</quote> para fazê-lo. Sua imaginação é o único limite.</para>

  </sect2>

  <sect2>
    <title>Dependências</title>

    <para>Para cada pacote descrito, o BLFS lista as dependências conhecidas. Essas
são listadas sob vários títulos, cujo significado é como segue:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Required</emphasis> means that the target package cannot be
correctly built without the dependency having first been installed, except
if the dependency is said to be <quote>runtime</quote>, which means the
target package can be built but cannot function without it.</para>
        <para>
          Note that a target package can start to <quote>function</quote> in many
subtle ways: an installed configuration file can make the init system, cron
daemon, or bus daemon to run a program automatically; another package using
the target package as an dependency can run a program from the target
package in the building system; and the configuration sections in the BLFS
book may also run a program from a just installed package.  So if you are
installing the target package without a <emphasis>Required
(runtime)</emphasis> dependency installed, You should install the dependency
as soon as possible after the installation of the target package.
        </para>
      </listitem>
      <listitem>
        <para><emphasis>Recommended</emphasis> means that BLFS strongly suggests this
package is installed first (except if said to be <quote>runtime</quote>, see
below) for a clean and trouble-free build, that won't have issues either
during the build process, or at run-time.  The instructions in the book
assume these packages are installed.  Some changes or workarounds may be
required if these packages are not installed. If a recommended dependency is
said to be <quote>runtime</quote>, it means that BLFS strongly suggests that
this dependency is installed before using the package, for getting full
functionality.</para>
      </listitem>
      <listitem>
        <para><emphasis>Optional</emphasis> means that this package might be installed for
added functionality. Often BLFS will describe the dependency to explain the
added functionality that will result.  An optional dependency may be
automatically pick up by the target package if the dependency is installed,
but another some optional dependency may also need additional configuration
options to enable them when the target package is built.  Such additional
options are often documented in the BLFS book.  If an optional dependency is
said to be <quote>runtime</quote>, it means you may install the dependency
after installing the target package to support some optional features of the
target package if you need these features.</para>
        <para>An optional dependency may be out of BLFS.  If you need such an
<emphasis>external</emphasis> optional dependency for some features you
need, read <xref linkend='beyond'/> for the general hint about installing an
out-of-BLFS package.</para>
      </listitem>
    </itemizedlist>

  </sect2>

  <sect2 id="package_updates">
    <title>Usando os Fontes Mais Atuais de Pacote</title>

    <para>Ocasionalmente você possivelmente se encontre em uma situação no livro onde
um pacote não construirá ou não funcionará adequadamente. Apesar dos(as)
Editores(as) tentarem garantir que cada pacote no livro construa e funcione
adequadamente, ocasionalmente um pacote tenha sido negligenciado ou não foi
testado com esta versão particular do BLFS.</para>

    <para>Se você descobrir que um pacote não construirá ou não funcionará
adequadamente, [então] você deveria ver se existe uma versão mais recente do
pacote. Tipicamente isso significa você ir ao sítio da web do(a)
mantenedor(a) e transferir o tarball mais recente e tentar construir o
pacote. Se você não conseguir determinar o sítio da web do(a) mantenedor(a)
olhando para os URLs de transferência, [então] use o Google e consulte o
nome do pacote. Por exemplo, na barra de pesquisa do Google, digite:
'nome_do_pacote download' (omita as aspas) ou algo
semelhante. Ocasionalmente, digitar: 'nome_do_pacote home page' resultará em
você encontrar o sítio da web do(a) mantenedor(a).</para>

  </sect2>

  <sect2 id="stripping">
    <title>Despojando Mais Uma Vez</title>

    <para>
      No LFS, a remoção de símbolos de depuração e entradas desnecessárias na
tabela de símbolos foi discutida algumas vezes. Ao construir pacotes BLFS,
geralmente não existem instruções especiais que discutam a remoção
novamente. A remoção pode ser feita durante a instalação de um pacote ou
posteriormente.
    </para>

    <bridgehead renderas="sect3" id="stripping-install">Despojando enquanto se Instala um Pacote</bridgehead>

    <para>
      Existem várias maneiras de se despojar executáveis instalados por um
pacote. Elas dependem do sistema de construção usado (veja-se abaixo <link
linkend="buildsystems">a seção acerca de sistemas de construção</link>), de
modo que somente algumas generalidades podem ser listadas aqui:
    </para>

    <note>
      <para>
        Os métodos a seguir que usam o recurso de um sistema de construção
("autotools", "meson" ou "cmake") não despojarão bibliotecas estáticas, se
alguma estiver instalada. Felizmente não existem muitas bibliotecas
estáticas no BLFS, e uma biblioteca estática sempre pode ser despojada com
segurança executando <command>strip --strip-unneeded</command> nela
manualmente.
      </para>
    </note>

    <itemizedlist>
      <listitem>
        <para>
          Os pacotes que usam "Autotools" geralmente tem um alvo
<parameter>install-strip</parameter> nos arquivos
<filename>Makefile</filename> gerados deles. Portanto, instalar executáveis
despojados é apenas uma questão de usar <command>make
install-strip</command> em vez de <command>make install</command>.
        </para>
      </listitem>
      <listitem>
        <para>
          Os pacotes que usam o sistema de construção "Meson" conseguem aceitar
<parameter>-Dstrip=true</parameter> ao executar <command>meson</command>. Se
esqueceu de adicionar essa opção executando o <command>meson</command>,
[então] você também consegue executar <command>meson install
--strip</command> em vez de <command>ninja install</command>.
        </para>
      </listitem>
      <listitem>
        <para>
          <command>cmake</command> gera alvos <parameter>install/strip</parameter>
para ambos os geradores <parameter>Unix Makefiles</parameter> e
<parameter>Ninja</parameter> (o padrão é <parameter>Unix
Makefiles</parameter> no Linux). Portanto, basta executar <command>make
install/strip</command> ou <command>ninja install/strip</command> em vez das
contrapartes <command>install</command>.
        </para>
      </listitem>
      <listitem>
        <para>
          A remoção (ou não geração) de símbolos de depuração também consegue ser
obtida removendo-se as opções <parameter>-g&lt;alguma_coisa&gt;</parameter>
em chamadas &quot;C/C++&quot;. Como fazer isso é muito específico para cada
pacote. E não remove entradas desnecessárias da tabela de
símbolos. Portanto, não será explicado em detalhes aqui. Veja-se também
abaixo os parágrafos acerca de otimização.
        </para>
      </listitem>
    </itemizedlist>

    <bridgehead renderas="sect3" id="stripping-installed">Despojando Executáveis Instalados</bridgehead>

    <para>
      The <command>strip</command> utility changes files in place, which may break
anything using it if it is loaded in memory. Note that if a file is in use
but just removed from the disk (i.e. not overwritten nor modified), this is
not a problem since the kernel can use <quote>deleted</quote> files.  Look
at <filename>/proc/*/maps</filename> and it is likely that you'll see some
<emphasis>(deleted)</emphasis> entries. The <command>mv</command> just
removes the destination file from the directory but does not touch its
content, so that it satisfies the condition for the kernel to use the old
(deleted) file.  But this approach can detach hard links into duplicated
copies, causing a bloat which is obviously unwanted as we are stripping to
reduce system size.  If two files in a same file system share the same inode
number, they are hard links to each other and we should reconstruct the
link.  The script below is just an example.  It should be run as the &root;
user:
    </para>

<screen><userinput>cat &gt; /usr/sbin/strip-all.sh &lt;&lt; "EOF"
<literal>#!/usr/bin/bash

if [ $EUID -ne 0 ]; then
  echo "Need to be root"
  exit 1
fi

last_fs_inode=
last_file=

{ find /usr/lib -type f -name '*.so*' ! -name '*dbg'
  find /usr/lib -type f -name '*.a'
  find /usr/{bin,sbin,libexec} -type f
} | xargs stat -c '%m %i %n' | sort | while read fs inode file; do
       if ! readelf -h $file >/dev/null 2>&amp;1; then continue; fi
       if file $file | grep --quiet --invert-match 'not stripped'; then continue; fi

       if [ "$fs $inode" = "$last_fs_inode" ]; then
         ln -f $last_file $file;
         continue;
       fi

       cp --preserve $file    ${file}.tmp
       strip --strip-unneeded ${file}.tmp
       mv ${file}.tmp $file

       last_fs_inode="$fs $inode"
       last_file=$file
done</literal>
EOF
chmod 744 /usr/sbin/strip-all.sh</userinput></screen>

    <para>
      Se você instalar aplicativos em outros diretórios, como <filename
class="directory">/opt</filename> ou <filename
class="directory">/usr/local</filename>, você possivelmente queira despojar
os arquivos lá também . Basta adicionar outros diretórios a escanear na
lista composta de comandos <command>find</command> entre chaves.
    </para>

    <para>
      Para mais informações acerca de despojamento, veja-se <ulink
url="https://www.technovelty.org/linux/stripping-shared-libraries.html"/>.
    </para>

  </sect2>


  <!--
  <sect2 id="libtool">

    <title>Libtool files</title>

    <para>
      One of the side effects of packages that use Autotools, including
      libtool, is that they create many files with an .la extension.  These
      files are not needed in an LFS environment.  If there are conflicts with
      pkgconfig entries, they can actually prevent successful builds.  You
      may want to consider removing these files periodically:
    </para>

<screen><userinput>find /lib /usr/lib -not -path "*Image*" -a -name \*.la -delete</userinput></screen>

    <para>
      The above command removes all .la files with the exception of those that
      have <quote>Image</quote> or <quote>openldap</quote> as a part of the
      path.  These .la files are used by the ImageMagick and openldap programs,
      respectively.  There may be other exceptions by packages not in BLFS.
    </para>

  </sect2>
-->
<sect2 id="buildsystems">
    <title>Trabalhando com diferentes sistemas de construção</title>

    <para>
      There are now three different build systems in common use for converting C
or C++ source code into compiled programs or libraries and their details
(particularly, finding out about available options and their default values)
differ. It may be easiest to understand the issues caused by some choices
(typically slow execution or unexpected use of, or omission of,
optimizations) by starting with the <envar>CFLAGS</envar>,
<envar>CXXFLAGS</envar>, and <envar>LDFLAGS</envar> environment variables.
There are also some programs which use Rust.
    </para>

    <para>
      Most LFS and BLFS builders are probably aware of the basics of
<envar>CFLAGS</envar> and <envar>CXXFLAGS</envar> for altering how a program
is compiled. Typically, some form of optimization is used by upstream
developers (<option>-O2</option> or <option>-O3</option>), sometimes with
the creation of debug symbols (<option>-g</option>), as defaults.
    </para>

    <para>
      If there are contradictory flags (e.g. multiple different
<option>-O</option> values), the <emphasis>last</emphasis> value will be
used. Sometimes this means that flags specified in environment variables
will be picked up before values hardcoded in the Makefile, and therefore
ignored.  For example, where a user specifies <option>-O2</option> and that
is followed by <option>-O3</option> the build will use <option>-O3</option>.
    </para>

    <para>
      There are various other things which can be passed in CFLAGS or CXXFLAGS,
such as allowing using the instruction set extensions available with a
specific microarchitecture (e.g.  <option>-march=amdfam10</option> or
<option>-march=native</option>), tune the generated code for a specific
microarchitecture (e. g.  <option>-mtune=tigerlake</option> or
<option>-mtune=native</option>, if <option>-mtune=</option> is not used, the
microarchitecture from <option>-march=</option> setting will be used), or
specifying a specific standard for C or C++ (<option>-std=c++17</option> for
example).  But one thing which has now come to light is that programmers
might include debug assertions in their code, expecting them to be disabled
in releases by using <option>-DNDEBUG</option>.  Specifically, if <xref
linkend="mesa"/> is built with these assertions enabled, some activities
such as loading levels of games can take extremely long times, even on
high-class video cards.
    </para>

    <bridgehead renderas="sect3" id="autotools-info">Autotools com Make</bridgehead>

      <para>
        This combination is often described as <quote>CMMI</quote> (configure, make,
make install) and is used here to also cover the few packages which have a
configure script that is not generated by autotools.
      </para>

      <para>
        Ocasionalmente, executar-se <command>./configure --help</command> produzirá
opções úteis acerca de chaves que poderiam ser usadas. Em outras ocasiões,
depois de olhar para a saída gerada a partir do configure, você
possivelmente precise olhar para os detalhes do script para descobrir pelo
que ele estava procurando atualmente.
      </para>

      <para>
       Muitos scripts de configuração escolherão quaisquer CFLAGS ou CXXFLAGS a
partir do ambiente, porém os pacotes CMMI variam acerca do como esses serão
misturados com quaisquer sinalizadores que, de outra maneira, seriam usados
(<emphasis>variadamente</emphasis>: ignorados; usados para substituir a
sugestão do(a) programador(a); usados antes da sugestão do(a)
programador(a); ou usados depois da sugestão do(a) programador(a)).
      </para>

      <para>
        In most CMMI packages, running <command>make</command> will list each
command and run it, interspersed with any warnings. But some packages try to
be <quote>silent</quote> and only show which file they are compiling or
linking instead of showing the command line.  If you need to inspect the
command, either because of an error, or just to see what options and flags
are being used, adding <option>V=1</option> to the make invocation may help.
      </para>

    <bridgehead renderas="sect3" id="cmake-info">CMake</bridgehead>

      <para>
        CMake works in a very different way, and it has two backends which can be
used on BLFS: <command>make</command> and <command>ninja</command>. The
default backend is make, but ninja can be faster on large packages with
multiple processors. To use ninja, specify <option>-G Ninja</option> in the
cmake command.  However, there are some packages which create fatal errors
in their ninja files but build successfully using the default of Unix
Makefiles.
      </para>

      <para>
        A parte mais difícil do usar-se o CMake é saber quais opções você poderia
desejar especificar. A única maneira de se obter uma lista do que o pacote
conhece é a de executar <command>cmake -LAH</command> e olhar para a saída
gerada para esta configuração padrão.
      </para>

      <para>
        Perhaps the most-important thing about CMake is that it has a variety of
CMAKE_BUILD_TYPE values, and these affect the flags. The default is that
this is not set and no flags are generated. Any <envar>CFLAGS</envar> or
<envar>CXXFLAGS</envar> in the environment will be used. If the programmer
has coded any debug assertions, those will be enabled unless -DNDEBUG is
used. The following CMAKE_BUILD_TYPE values will generate the flags shown,
and these will come <emphasis>after</emphasis> any flags in the environment
and therefore take precedence.
      </para>

      <informaltable align="center">
        <tgroup cols="2">
          <colspec colnum="1" align="center"/>
          <colspec colnum="2" align="center"/>
          <thead>
            <row><entry>Valor</entry><entry>Sinalizadores</entry></row>
          </thead>
          <tbody>
            <row>
              <entry>Debug</entry><entry><option>-g</option></entry>
            </row>
            <row>
              <entry>Release</entry><entry><option>-O3 -DNDEBUG</option></entry>
            </row>
            <row>
              <entry>RelWithDebInfo</entry><entry><option>-O2 -g -DNDEBUG</option></entry>
            </row>
            <row>
              <entry>MinSizeRel</entry><entry><option>-Os -DNDEBUG</option></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>
        O "CMake" tenta produzir construções silenciosas. Para ver os detalhes dos
comandos que estão sendo executados, use <command>make VERBOSE=1</command>
ou <command>ninja -v</command>.
      </para>

      <para>
        Por padrão, o "CMake" trata a instalação de arquivos diferentemente dos
outros sistemas de construção: se um arquivo já existir e não for mais
recente que um arquivo que o sobrescreveria, então o arquivo não será
instalado. Isso possivelmente seja um problema se um(a) usuário(a) quiser
registrar qual arquivo pertence a um pacote, seja usando
<envar>LD_PRELOAD</envar>, ou listando arquivos mais recentes que um carimbo
de tempo. O padrão pode ser mudado definindo-se a variável
<envar>CMAKE_INSTALL_ALWAYS</envar> como um ("1") no
<emphasis>ambiente</emphasis>, por exemplo, via <command>export</command>.
      </para>

    <bridgehead renderas="sect3" id="meson-info">Meson</bridgehead>

      <para>
        O Meson tem algumas semelhanças com o CMake, porém muitas diferenças. Para
obter os detalhes das definições que você possivelmente queira mudar, você
pode olhar para o <filename>meson_options.txt</filename> que normalmente
está no diretório de nível de topo.
      </para>

      <para>
        Se você já configurou o pacote executando o <command>meson</command> e,
agora, deseja mudar uma ou mais configurações, [então] você ou pode remover
o diretório de construção, recriá-lo e usar as opções alteradas; ou, dentro
do diretório de construção, executar <command>meson configure</command>, por
exemplo, para configurar uma opção:
      </para>

<screen><userinput>meson configure -D&lt;alguma_opção&gt;=true</userinput></screen>

      <para>
        Se você fizer isso, [então] o arquivo
<filename>meson-private/cmd_line.txt</filename> mostrará os
<emphasis>últimos</emphasis> comandos que foram usados.
      </para>

      <para>
        O Meson fornece os seguintes valores de tipo de construção e os
sinalizadores que eles habilitam vem <emphasis>depois</emphasis> de
quaisquer sinalizadores fornecidos no ambiente e, portanto, tem precedência.
      </para>

      <itemizedlist>
        <listitem>
          <para>plain : no added flags. This is for distributors to supply their own
<envar>CFLAGS</envar>, <envar>CXXFLAGS</envar> and
<envar>LDFLAGS</envar>. There is no obvious reason to use this in BLFS.</para>
        </listitem>
        <listitem>
          <para>debug : <option>-g</option> - this is the default if nothing is specified in
either <filename>meson.build</filename> or the command line. However it
results large and slow binaries, so we should override it in BLFS.</para>
        </listitem>
        <listitem>
          <para>debugoptimized : <option>-O2 -g</option> - this is the default specified in
<filename>meson.build</filename> of some packages.</para>
        </listitem>
        <listitem>
          <para>release : <option>-O3</option> (occasionally a package will force
<option>-O2</option> here) - this is the buildtype we use for most packages
with Meson build system in BLFS.</para>
        </listitem>
      </itemizedlist>

      
      <!-- From https://mesonbuild.com/Builtin-options.html#core-options:
           b_ndebug: Default value = false, Possible values are
           true, false, if-release.  Some packages sets it to if-release
           so we mistakenly believed if-release had been the default.  -->
<para>
        The <option>-DNDEBUG</option> flag is implied by the release buildtype for
some packages (for example <xref linkend='mesa'/>).  It can also be provided
explicitly by passing <option>-Db_ndebug=true</option>.
      </para>

      <para>
        To see the details of the commands which are being run in a package using
meson, use <command>ninja -v</command>.
      </para>

    <bridgehead renderas="sect3" id="rust-info">Rustc e Cargo</bridgehead>

      <para>
        Most released rustc programs are provided as crates (source tarballs)  which
will query a server to check current versions of dependencies and then
download them as necessary.  These packages are built using <command>cargo
--release</command>. In theory, you can manipulate the RUSTFLAGS to change
the optimize-level (default for <option>--release</option> is 3, i. e.
<option>-Copt-level=3</option>, like <option>-O3</option>) or to force it to
build for the machine it is being compiled on, using
<option>-Ctarget-cpu=native</option> but in practice this seems to make no
significant difference.
      </para>

      <para>
        If you are compiling a standalone Rust program (as an unpackaged <filename
class='extension'>.rs</filename> file) by running <command>rustc</command>
directly, you should specify <option>-O</option> (the abbreviation of
<option>-Copt-level=2</option>) or <option>-Copt-level=3</option> otherwise
it will do an unoptimized compile and run <emphasis>much</emphasis> slower.
If are compiling the program for debugging it, replace the
<option>-O</option> or <option>-Copt-level=</option> options with
<option>-g</option> to produce an unoptimized program with debug info.
      </para>

      <para>
        Like <command>ninja</command>, by default <command>cargo</command> uses all
logical processors.  This can often be worked around, either by exporting
<envar>CARGO_BUILD_JOBS=<replaceable>&lt;N&gt;</replaceable></envar> or
passing <option>--jobs <replaceable>&lt;N&gt;</replaceable></option> to
<command>cargo</command>.  For compiling rustc itself, specifying
<option>--jobs <replaceable>&lt;N&gt;</replaceable></option> for invocations
of <command>x.py</command> (together with the
<envar>CARGO_BUILD_JOBS</envar> environment variable, which looks like a
<quote>belt and braces</quote> approach but seems to be necessary) mostly
works. The exception is running the tests when building rustc, some of them
will nevertheless use all online CPUs, at least as of rustc-1.42.0.
      </para>

  </sect2>

  <sect2 id="optimizations">
    <title>Otimizando a construção</title>

      <para>
        Many people will prefer to optimize compiles as they see fit, by providing
<envar>CFLAGS</envar> or <envar>CXXFLAGS</envar>. For an introduction to the
options available with gcc and g++ see <ulink
url="https://gcc.gnu.org/onlinedocs/gcc-&gcc-version;/gcc/Optimize-Options.html"/>.
The same content can be also found in <command>info gcc</command>.
      </para>

      <para>
        Some packages default to <option>-O2 -g</option>, others to <option>-O3
-g</option>, and if <envar>CFLAGS</envar> or <envar>CXXFLAGS</envar> are
supplied they might be added to the package's defaults, replace the
package's defaults, or even be ignored.  There are details on some desktop
packages which were mostly current in April 2019 at <ulink
url="https://www.linuxfromscratch.org/~ken/tuning/"/> - in particular,
<filename>README.txt</filename>,
<filename>tuning-1-packages-and-notes.txt</filename>, and
<filename>tuning-notes-2B.txt</filename>. The particular thing to remember
is that if you want to try some of the more interesting flags you may need
to force verbose builds to confirm what is being used.
      </para>

      <para>
        Clearly, if you are optimizing your own program you can spend time to
profile it and perhaps recode some of it if it is too slow. But for building
a whole system that approach is impractical. In general,
<option>-O3</option> usually produces faster programs than
<option>-O2</option>.  Specifying <option>-march=native</option> is also
beneficial, but means that you cannot move the binaries to an incompatible
machine - this can also apply to newer machines, not just to older
machines. For example programs compiled for <literal>amdfam10</literal> run
on old Phenoms, Kaveris, and Ryzens : but programs compiled for a Kaveri
will not run on a Ryzen because certain op-codes are not present.
Similarly, if you build for a Haswell not everything will run on a
SandyBridge.
      </para>

      <note>
        <para>
          Be careful that the name of a <option>-march</option> setting does not
always match the baseline of the microarchitecture with the same name.  For
example, the Skylake-based Intel Celeron processors do not support AVX at
all, but <option>-march=skylake</option> assumes AVX and even AVX2.
        </para>
      </note>

      <para>
        When a shared library is built by GCC, a feature named <quote>semantic
interposition</quote> is enabled by default.  When the shared library refers
to a symbol name with external linkage and default visibility, if the symbol
exists in both the shared library and the main executable, semantic
interposition guarantees the symbol in the main executable is always used.
This feature was invented in an attempt to make the behavior of linking a
shared library and linking a static library as similar as possible.  Today
only a small number of packages still depend on semantic interposition, but
the feature is still on by the default of GCC, causing many optimizations
disabled for shared libraries because they conflict with semantic
interposition.  The <option>-fno-semantic-interposition</option> option can
be passed to <command>gcc</command> or <command>g++</command> to disable
semantic interposition and enable more optimizations for shared libraries.
This option is used as the default of some packages (for example <xref
linkend='python3'/>), and it's also the default of Clang.
      </para>

      <para>
        Existem também várias outras opções que algumas pessoas alegam que são
benéficas. Na pior das hipóteses, você consegue recompilar e testar e,
então, descobrir que, em seu uso, as opções não fornecem um benefício.
      </para>

      <para>
        If building Perl or Python modules, in general the <envar>CFLAGS</envar> and
<envar>CXXFLAGS</envar> used are those which were used by those
<quote>parent</quote> packages.
      </para>

      <para>
        For <envar>LDFLAGS</envar>, there are three options can be used for
optimization.  They are quite safe to use and the building system of some
packages use some of these options as the default.
      </para>

      <para>
        With <option>-Wl,-O1</option>, the linker will optimize the hash table to
speed up the dynamic linking.  Note that <option>-Wl,-O1</option> is
completely unrelated to the compiler optimization flag <option>-O1</option>.
      </para>

      <para>
        With <option>-Wl,--as-needed</option>, the linker will disregard unnecessary
<option>-l<replaceable>foo</replaceable></option> options from the command
line, i. e. the shared library <systemitem
class='library'>lib<replaceable>foo</replaceable></systemitem> will only be
linked if a symbol in <systemitem
class='library'>lib<replaceable>foo</replaceable></systemitem> is really
referred from the executable or shared library being linked.  This can
sometimes mitigate the <quote>excessive dependencies to shared
libraries</quote> issues caused by <application>libtool</application>.
      </para>

      <para>
        With <option>-Wl,-z,pack-relative-relocs</option>, the linker generates a
more compacted form of the relative relocation entries for PIEs and shared
libraries.  It reduces the size of the linked PIE or shared library, and
speeds up the loading of the PIE or shared library.
      </para>

      <para>
        The <option>-Wl,</option> prefix is necessary because despite the variable
is named <envar>LDFLAGS</envar>, its content is actually passed to
<command>gcc</command> (or <command>g++</command>, <command>clang</command>,
etc.) during the link stage, not directly passed to <command>ld</command>.
      </para>

  </sect2>

  <sect2 id="hardening">
    <title>Opções para fortalecer a construção</title>

      <para>
        Mesmo em sistemas de área de trabalho, existe ainda um monte de
vulnerabilidades exploráveis. Para muitas dessas, o ataque vem via
javascript em um navegador. Frequentemente, uma série de vulnerabilidades é
usada para ganhar acesso a dados (ou, às vezes, para pwn, isto é, dominar, a
máquina e instalar rootkits). A maioria das distribuições comerciais
aplicará várias medidas de fortalecimento.
      </para>

      <para>
        No passado, existia o "LFS Reforçado", onde o "GCC" (uma versão muito mais
antiga) era forçado a usar reforçamento (com opções para desativar parte
dele por pacote). Os livros atuais LFS e BLFS estão levando adiante uma
parte do espírito dele, habilitando "PIE" (<option>-fPIE -pie</option>) e
"SSP" (<option>-fstack-protector-strong</option>) como padrões para o "GCC"
e o "clang". O que está sendo abordado aqui é diferente - primeiro, você
precisa ter certeza de que o pacote está realmente usando os teus
sinalizadores adicionados e não os substituindo.
      </para>

      <para>
        For hardening options which are reasonably cheap, there is some discussion
in the 'tuning' link above (occasionally, one or more of these options might
be inappropriate for a package). These options are
<option>-D_FORTIFY_SOURCE=2</option> and (for C++)
<option>-D_GLIBCXX_ASSERTIONS</option>. On modern machines these should only
have a little impact on how fast things run, and often they will not be
noticeable.
      </para>

      <para>
        As principais distribuições usam muito mais, como "RELRO" ("Relocation Read
Only") e talvez <option>-fstack-clash-protection</option>. Você também
possivelmente encontre a chamada <quote>retpoline do espaço de
usuário(a)</quote> (<option>-mindirect-branch=thunk</option> etc.), que é o
equivalente às mitigações de espectro aplicadas ao núcleo Linux no final de
2018. As mitigações do núcleo causaram muitas reclamações acerca de perda de
desempenho; se você tiver um servidor de produção, você pode desejar
considerar testá-las, juntamente com outras opções disponíveis, para ver se
o desempenho ainda é suficiente.
      </para>

      <para>
        Embora o gcc tenha muitas opções de fortalecimento, os pontos fortes do
clang/LLVM estão em outro lugar. Algumas opções que o gcc fornece são ditas
serem menos efetivas no clang/LLVM.
      </para>

  </sect2>

</sect1>
