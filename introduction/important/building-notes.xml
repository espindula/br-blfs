<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="unpacking">
  <?dbhtml filename="notes-on-building.html"?>


  <title>Observações Acerca de Construir Software</title>

  <para>Aquelas pessoas que tenham construído um sistema LFS possivelmente estejam
cientes dos princípios gerais da transferência e do desempacotamento de
software. Alguma daquela informação está repetida aqui para aquelas novatas
em construir o próprio software delas.</para>

  <para>Cada conjunto de instruções de instalação contém um URL a partir do qual
você pode transferir o pacote. Os remendos, no entanto, estão armazenados
nos servidores do LFS e estão disponíveis via HTTP. Esses estão
referenciados conforme necessários nas instruções de instalação.</para>

  <para>While you can keep the source files anywhere you like, we assume that you
have unpacked the package and changed into the directory created by the
unpacking process (the 'build' directory).  We also assume you have
uncompressed any required patches and they are in the directory immediately
above the 'build' directory.</para>

  <para>Nós não podemos enfatizar fortemente o suficiente que você deveria iniciar a
partir de uma <emphasis>árvore limpa do fonte</emphasis> a cada vez. Isso
significa que, se você tiver tido um erro durante a configuração ou a
compilação, [então] geralmente é melhor deletar a árvore do fonte e
desempacotá-la outra vez <emphasis>antes de</emphasis> tentar
novamente. Isso, obviamente, não se aplica se você for um(a) usuário(a)
avançado(a) habituado(a) a hackear <filename>Makefile</filename>s e código
C; porém, se em dúvida, [então] inicie a partir de uma árvore limpa.</para>

  <sect2>
    <title>Construindo Software como um(a) Usuário(a) Não Privilegiado(a) (não root)</title>

    <para>A regra de ouro da Administração do Sistema Unix é a de usar os seus super
poderes somente quando necessário. Assim, o BLFS recomenda que você construa
software como um(a) usuário(a) não privilegiado(a) e somente se torne o(a)
usuário(a) <systemitem class='username'>root</systemitem> quando instalar o
software. Essa filosofia é seguida em todos os pacotes neste livro. A menos
que especificado de outra maneira, todas as instruções deveriam ser
executadas como um(a) usuário(a) não privilegiado(a). O livro alertará você
acerca de instruções que precisarem de privilégios do(a) <systemitem
class='username'>root</systemitem>.</para>

  </sect2>

  <sect2>
    <title>Desempacotando o Software</title>

    <para>Se um arquivo estiver no formato <filename class='extension'>.tar</filename>
e comprimido, [então] ele é desempacotado executando-se um dos seguintes
comandos:</para>

<screen><userinput>tar -xvf nome_arquivo.tar.gz
tar -xvf nome_arquivo.tgz
tar -xvf nome_arquivo.tar.Z
tar -xvf nome_arquivo.tar.bz2</userinput></screen>

    <note>
      <para>Você possivelmente omita o uso do parâmetro <option>v</option> nos comandos
mostrados acima e abaixo se você desejar suprimir a listagem verbosa de
todos os arquivos no arquivamento conforme eles forem extraídos. Isso pode
ajudar a acelerar a extração, bem como torna quaisquer erros produzidos
durante a extração mais óbvios para você.</para>
    </note>

    <para>Você também pode usar um método ligeiramente diferente:</para>

<screen><userinput>bzcat nome_arquivo.tar.bz2 | tar -xv</userinput></screen>

    <para>Finalmente, ocasionalmente, você precisa estar apto(a) a desempacotar
remendos que geralmente não estão no formato <filename
class='extension'>.tar</filename>. A melhor maneira de fazer isso é a de
copiar o arquivo do remendo para o ancestral do diretório da 'construção' e,
então, executar um dos seguintes comandos, dependendo se o arquivo for um
arquivo <filename class='extension'>.gz</filename> ou um <filename
class='extension'>.bz2</filename>:</para>

<screen><userinput>gunzip -v patchname.gz
bunzip2 -v patchname.bz2</userinput></screen>

  </sect2>

  <sect2>
    <title>Averiguando a Integridade do Arquivo</title>

    <para>Geralmente, para se averiguar se o arquivo transferido está completo,
muitos(as) mantenedores(as) de pacote também distribuem somas de verificação
md5 dos arquivos. Para averiguar a soma de verificação md5 dos arquivos
transferidos, transfira ambos, o arquivo e o arquivo correspondente de soma
de verificação md5, para o mesmo diretório (preferencialmente a partir de
locais diferentes online) e (assumindo que
<filename>arquivo.md5sum</filename> seja o arquivo de soma de verificação
md5 transferido) execute o seguinte comando:</para>

<screen><userinput>md5sum -c arquivo.md5sum</userinput></screen>

    <para>Se existirem quaisquer erros, [então] eles serão informados. Observe que o
livro BLFS inclui somas de verificação md5 para todos os arquivos de fonte
também. Para usar as somas de verificação md5 fornecidas pelo BLFS, você
pode criar um <filename>arquivo.md5sum</filename> (coloque os dados da soma
de verificação md5 e o nome exato do arquivo transferido na mesma linha de
um arquivo, separados por espaço em branco) e executar o comando mostrado
acima. Alternativamente, simplesmente execute o comando mostrado abaixo e
compare a saída gerada para os dados da soma de verificação md5 mostrada no
livro BLFS.</para>

<screen><userinput>md5sum <replaceable>&lt;nome_do_arquivo_transferido&gt;</replaceable></userinput></screen>

    <para>MD5 não é seguro criptograficamente, de forma que as somas de verificação
md5 são fornecidas somente para se detectar mudanças não maliciosas para o
conteúdo do arquivo. Por exemplo, um erro ou truncamento introduzido durante
a transferência de rede de comunicação; ou uma atualização
<quote>furtiva</quote> para o pacote oriunda do(a) desenvolvedor(a)
(atualizando o conteúdo de um tarball liberado em vez de fazer um lançamento
novo adequadamente).</para>

    <para>Não existe maneira <quote>100%</quote> segura de garantir a genuinidade dos
arquivos do fonte. Assumindo que o(a) desenvolvedor(a) esteja gerenciando
corretamente o sítio da web dele(a) (a chave privada não vazou e o domínio
não esteja sequestrado); e que as âncoras de confiança tenham sido
configuradas corretamente usando <xref linkend="make-ca"/> no sistema BLFS;
nós podemos razoavelmente confiar nos URLs de transferência para o sítio
oficial da web do(a) desenvolvedor(a) <emphasis role="bold">com protocolo
https</emphasis>. Observe que o próprio livro BLFS está publicado em um
sítio da web com https, de forma que você já deveria ter alguma confiança no
protocolo https ou você não confiaria no conteúdo do livro.</para>

    <para>Se o pacote for transferido a partir de um local não oficial (por exemplo,
um espelho local), [então] as somas de verificação geradas por algoritmos de
resumo criptograficamente seguros (por exemplo, SHA256) podem ser usadas
para averiguar a genuinidade do pacote. Transfira o arquivo da soma de
verificação a partir do sítio da web <emphasis
role="bold">oficial</emphasis> do(a) desenvolvedor(a) (ou algum lugar que
<emphasis role="bold">você possa confiar</emphasis>) e compare a soma de
verificação do pacote oriunda do local não oficial com ele. Por exemplo, a
soma de verificação SHA256 pode ser verificada com o comando:</para>

    <note>
      <para>Se a soma de verificação e o pacote forem transferidos a partir do mesmo
local não confiável, [então] você não ganharia melhoramento de segurança
averiguando o pacote com a soma de verificação. O(A) atacante pode falsear a
soma de verificação assim como comprometer o próprio pacote.</para>
    </note>

<screen><userinput>sha256sum -c <replaceable>arquivo</replaceable>.sha256sum</userinput></screen>

    <para>Se o <xref linkend="gnupg2"/> estiver instalado, [então] você também pode
averiguar a genuinidade do pacote com uma assinatura GPG. Importe a chave
pública GPG do(a) desenvolvedor(a) com:</para>

<screen><userinput>gpg --recv-key <replaceable>ID_da_chave</replaceable></userinput></screen>

    <para><replaceable>ID_da_chave</replaceable> deveria ser substituído pelo ID da
chave oriundo de algum lugar que <emphasis role="bold">você possa
confiar</emphasis> (por exemplo, copie-o a partir do sítio da web oficial
do(a) desenvolvedor(a) usando https). Agora, você consegue averiguar a
assinatura com:</para>

<screen><userinput>gpg --recv-key <replaceable>arquivo</replaceable>.sig <replaceable>arquivo</replaceable></userinput></screen>

    <para>A vantagem da assinatura <application>GnuPG</application> é, tão logo você
importou uma chave pública que possa ser confiada, você pode transferir
ambos, o pacote e a assinatura dele, a partir do mesmo local não oficial e
averiguá-los com a chave pública. Assim, você não precisaria conectar com o
sítio da web oficial do(a) desenvolvedor(a) para ir buscar uma soma de
verificação para cada lançamento novo. Você somente precisa atualizar a
chave pública se ela estiver expirada ou revogada.
    </para>

  </sect2>

  <sect2>
    <title>Criando Arquivos de Registro Durante a Instalação</title>

    <para>Para pacotes mais largos, é conveniente se criar arquivos de registro em vez
de olhar fixamente para a tela esperando pegar um erro ou aviso em
particular. Os arquivos de registro também são úteis para depuração e para
manter registros. O seguinte comando permite a você criar um registro da
instalação. Substitua <replaceable>&lt;comando&gt;</replaceable> pelo
comando que você pretende executar.</para>

<screen><userinput>( <replaceable>&lt;comando&gt;</replaceable> 2&gt;&amp;1 | tee compile.log &amp;&amp; exit $PIPESTATUS )</userinput></screen>

    <para><option>2&gt;&amp;1</option> redireciona as mensagens de erro para o mesmo
local que a saída gerada padrão. O comando <command>tee</command> permite
visualizar a saída gerada enquanto se registra os resultados em um
arquivo. Os parênteses em volta do comando executam o comando inteiro em um
sub shell; e, finalmente, o comando <command>exit $PIPESTATUS</command>
garante que o resultado do <replaceable>&lt;comando&gt;</replaceable> seja
retornado como o resultado e não o resultado do comando
<command>tee</command>.</para>

  </sect2>

  <sect2 id="parallel-builds" xreflabel="Usando Múltiplos Processadores">
    <title>Usando Múltiplos Processadores</title>

    <para>Para muitos sistemas modernos com múltiplos processadores (ou núcleos) o
tempo de compilação para um pacote pode ser reduzido realizando-se um "make
paralelo", ou configurando-se uma variável de ambiente, ou dizendo-se ao
aplicativo make quantos processadores estão disponíveis. Por exemplo, um
Core2Duo pode suportar dois processos simultâneos com: </para>

    <screen><userinput>export MAKEFLAGS='-j2'</userinput></screen>

    <para>ou apenas construir com:</para>

    <screen><userinput>make -j2</userinput></screen>

    <para>
      Se você tiver aplicado o <command>sed</command> opcional quando da
construção do <application>ninja</application> no LFS, [então] você pode
usar:
    </para>

    <screen><userinput>export NINJAJOBS=2</userinput></screen>

    <para>
      quando um pacote usar o <command>ninja</command>; ou apenas:
    </para>

    <screen><userinput>ninja -j2</userinput></screen>

    <para>
      porém, para o ninja, o número padrão de trabalhos é &lt;N&gt;+2, onde
&lt;N&gt; é o número de processadores disponíveis, de forma que usar os
comandos acima é preferencialmente para limitar o número de trabalhos
(veja-se abaixo para o porque isso poderia ser necessário).
    </para>

    <para>Generally the number of processes should not exceed the number of cores
supported by the CPU.  To list the processors on your system, issue:
<userinput>grep processor /proc/cpuinfo</userinput>.
    </para>

    <para>In some cases, using multiple processes may result in a 'race' condition
where the success of the build depends on the order of the commands run by
the <command>make</command> program.  For instance, if an executable needs
File A and File B, attempting to link the program before one of the
dependent components is available will result in a failure.  This condition
usually arises because the upstream developer has not properly designated
all the prerequisites needed to accomplish a step in the Makefile.</para>

    <para>If this occurs, the best way to proceed is to drop back to a single
processor build.  Adding '-j1' to a make command will override the similar
setting in the <envar>MAKEFLAGS</envar> environment variable.</para>

    <note><para>Quando se executar os testes de pacote ou a porção instalar do processo de
construção do pacote, nós não recomendamos usar uma opção maior que '-j1', a
menos que especificado de outra maneira. Os procedimentos ou verificações da
instalação não foram validados usando-se procedimentos paralelos e
possivelmente falhem com problemas que são difíceis de se depurar.</para></note>

    <important>
      <para>
        Outro problema possivelmente ocorra com CPUs modernas, as quais tem um monte
de núcleos. Cada trabalho iniciado consome memória e, se a soma da memória
necessária para cada trabalho exceder da memória disponível, [então] você
possivelmente encontre, ou uma interrupção de kernel Out of Memory (OOM), ou
troca intensa, que retardará a construção além de limites razoáveis.
      </para>

      <para>
        Algumas compilações com o <command>g++</command> possivelmente consumam até
2,5 GB de memória, de forma que, para estar seguro(a), você deveria
restringir o número de trabalhos a (Memória Total em GB)/2,5, ao menos para
pacotes grandes, tais como o LLVM; o WebKitGtk; o QtWebEngine; ou o
Libreoffice.
      </para>
    </important>
  </sect2>

  <sect2 id="automating-builds" xreflabel="Procedimentos Automatizados de Construção">
    <title>Procedimentos Automatizados de Construção</title>

    <para>Existem ocasiões onde automatizar a construção de um pacote pode vir a
calhar. Todo mundo tem razões próprias para querer automatizar a construção
e todo mundo faz isso de maneira própria. Criar
<filename>Makefile</filename>s; scripts do <application>Bash</application>;
scripts do <application>Perl</application>; ou, simplesmente, uma lista de
comandos usados para recortar e colar, são apenas alguns dos métodos que
você pode usar para automatizar a construção de pacotes do BLFS. Detalhar
como e fornecer exemplos das muitas maneiras que você pode automatizar a
construção de pacotes está além do escopo desta seção. Esta seção exporá
você ao uso do redirecionamento de arquivo e do comando
<command>yes</command> para ajudar a fornecer ideias acerca do como
automatizar suas construções.</para>

    <bridgehead renderas="sect3">Redirecionamento de Arquivo para Automatizar a Entrada Gerada</bridgehead>

    <para>Você achará ocasiões ao longo da sua jornada BLFS quando você se deparará
com um pacote que tenha um comando solicitando informação. Essa informação
poderia ser detalhes de configuração; um caminho de diretório; ou uma
resposta a um acordo de licença. Isso pode apresentar um desafio para
automatizar a construção desse pacote. Ocasionalmente, você será
consultado(a) para diferentes informações em uma série de perguntas. Um
método para automatizar esse tipo de cenário exige colocar as respostas
desejadas em um arquivo e usar redirecionamento, de forma que o aplicativo
use os dados no arquivo como as respostas para as perguntas.</para>

    <para>Construir o pacote <application>CUPS</application> é um bom exemplo de como
redirecionar um arquivo como entrada gerada para solicitações pode te ajudar
a automatizar a construção. Se você executar a suíte de teste, [então] você
é solicitado(a) a responder a uma série de perguntas relacionadas ao tipo do
teste a executar e se você tem quaisquer aplicativos auxiliares que o teste
possa usar. Você pode criar um arquivo com as suas respostas, uma resposta
por linha, e usar um comando similar ao mostrado abaixo para automatizar a
execução da suíte de teste:</para>

<screen><userinput>make check &lt; ../cups-1.1.23-testsuite_parms</userinput></screen>

    <para>Isso, efetivamente, faz com que a suíte de teste use as respostas no arquivo
como a entrada gerada para as perguntas. Ocasionalmente você possivelmente
termine fazendo um bocado de tentativa e erro para determinar o formato
exato do seu arquivo de entrada gerada para algumas coisas, porém, tão logo
determinado e documentado, você consegue usar isso para automatizar a
construção do pacote.</para>

    <bridgehead renderas="sect3">Usando o <command>yes</command> para Automatizar a Entrada Gerada</bridgehead>

    <para>Ocasionalmente você somente precisará fornecer uma resposta ou fornecer a
mesma resposta para muitas solicitações. Para tais instâncias, o comando
<command>yes</command> funciona realmente bem. O comando
<command>yes</command> pode ser usado para fornecer uma resposta (a mesma)
para uma ou mais instâncias de perguntas. Ele pode ser usado para simular o
pressionamento apenas da tecla <keycap>Enter</keycap>; informar a tecla
<keycap>Y</keycap>; ou informar uma sequência de caracteres de texto. Talvez
a maneira mais fácil de mostrar o uso dele é em um exemplo.</para>

    <para>Primeiro, crie um script curto do <application>Bash</application> informando
os seguintes comandos:</para>

<screen><userinput>cat &gt; blfs-yes-test1 &lt;&lt; "EOF"
<literal>#!/bin/bash

echo -n -e "\n\nPor favor, digite algo (ou nada) e pressione Enter ---> "

read A_STRING

if test "$A_STRING" = ""; then A_STRING="Apenas a tecla Enter foi pressionada"
else A_STRING="Você informou '$A_STRING'"
fi

echo -e "\n\n$A_STRING\n\n"</literal>
EOF
chmod 755 blfs-yes-test1</userinput></screen>

    <para>Agora execute o script emitindo <command>./blfs-yes-test1</command> a partir
da linha de comando. Ele aguardará por uma resposta, que pode ser algo (ou
nada) seguida pela tecla <keycap>Enter</keycap>. Depois de informar alguma
coisa, o resultado será ecoado para a tela. Agora use o comando
<command>yes</command> para automatizar a entrada de uma resposta:</para>

<screen><userinput>yes | ./blfs-yes-test1</userinput></screen>

    <para>Perceba que canalizar o próprio <command>yes</command> para o script resulta
em <keycap>y</keycap> sendo passada para o script. Agora tente com uma
sequência de caracteres de texto:</para>

<screen><userinput>yes 'Este é algum texto' | ./blfs-yes-test1</userinput></screen>

    <para>A sequência exata de caracteres foi usada como a resposta para o
script. Finalmente, tente usando uma sequência de caracteres vazia (nula):</para>

<screen><userinput>yes '' | ./blfs-yes-test1</userinput></screen>

    <para>Perceba que isso resulta na passagem apenas do pressionamento da tecla
<keycap>Enter</keycap> para o script. Isso é útil para ocasiões quando a
resposta padrão para a solicitação for suficiente. Essa sintaxe é usada nas
instruções do <xref linkend="net-tools-automate-example"/> para aceitar
todos os padrões para as muitas solicitações durante a etapa de
configuração. Você possivelmente agora remova o script de teste, se
desejado.</para>

    <bridgehead renderas="sect3">Redirecionamento de Arquivo para Automatizar a Saída Gerada</bridgehead>

    <para>Para a finalidade de automatizar a construção de alguns pacotes,
especialmente aqueles que exigem que você leia um acordo de licença em uma
página por vez, exige-se usar um método que evite ter que pressionar uma
tecla para exibir cada página. Redirecionar a saída gerada para um arquivo
pode ser usado nessas instâncias para auxiliar com a automação. A seção
anterior nesta página tocou na criação de arquivos de registro da saída
gerada da construção. O método de redirecionamento mostrado lá usou o
comando <command>tee</command> para redirecionar a saída gerada para um
arquivo enquanto também exibia a saída gerada na tela. Aqui, a saída gerada
somente será enviada para um arquivo.</para>

    <para>Novamente, a maneira mais fácil para demonstrar a técnica é de mostrar um
exemplo. Primeiro, emita o comando:</para>

<screen><userinput>ls -l /usr/bin | more</userinput></screen>

    <para>Of course, you'll be required to view the output one page at a time because
the <command>more</command> filter was used. Now try the same command, but
this time redirect the output to a file. The special file
<filename>/dev/null</filename> can be used instead of the filename shown,
but you will have no log file to examine:</para>

<screen><userinput>ls -l /usr/bin | more &gt; redirect_test.log 2&gt;&amp;1</userinput></screen>

    <para>Perceba que, dessa vez, o comando imediatamente retornou ao prompt do shell
sem ter que paginar ao longo da saída gerada. Você agora possivelmente
remova o arquivo de registro.</para>

    <para>O último exemplo usará o comando <command>yes</command> em combinação com o
redirecionamento da saída gerada para desviar-se de ter que paginar ao longo
da saída gerada e, então, fornecerá um <keycap>y</keycap> para uma
solicitação. Essa técnica poderia ser usada em instâncias quando, de outra
maneira, você teria que paginar ao longo da saída gerada de um arquivo (como
um acordo de licença) e, então, responder à pergunta de <quote>você aceita o
acima?</quote>. Para esse exemplo, outro script curto do
<application>Bash</application> é exigido:</para>

<screen><userinput>cat &gt; blfs-yes-test2 &lt;&lt; "EOF"
<literal>#!/bin/bash

ls -l /usr/bin | more

echo -n -e "\n\nDid you enjoy reading this? (y,n) "

read A_STRING

if test "$A_STRING" = "y"; then A_STRING="You entered the 'y' key"
else A_STRING="You did NOT enter the 'y' key"
fi

echo -e "\n\n$A_STRING\n\n"</literal>
EOF
chmod 755 blfs-yes-test2</userinput></screen>

    <para>Esse script pode ser usado para simular um aplicativo que exige que você
leia um acordo de licença, então responda apropriadamente que aceita o
acordo antes do aplicativo instalar qualquer coisa. Primeiro, execute o
script sem quaisquer técnicas de automação emitindo
<command>./blfs-yes-test2</command>.</para>

    <para>Agora emita o seguinte comando que usa duas técnicas de automação,
tornando-o adequado para uso em um script automatizado de construção:</para>

<screen><userinput>yes | ./blfs-yes-test2 &gt; blfs-yes-test2.log 2&gt;&amp;1</userinput></screen>

    <para>Se desejado, emita <command>tail blfs-yes-test2.log</command> para ver o
final da saída gerada paginada e a confirmação de que <keycap>y</keycap> foi
passada ao longo para o script. Tão logo satisfeito que ele funciona como
deveria, você possivelmente remova o script e o arquivo de registro.</para>

    <para>Finalmente, tenha em mente que existem muitas maneiras de automatizar e (ou)
roteirizar os comandos de construção. Não existe maneira única
<quote>correta</quote> para fazê-lo. Sua imaginação é o único limite.</para>

  </sect2>

  <sect2>
    <title>Dependências</title>

    <para>Para cada pacote descrito, o BLFS lista as dependências conhecidas. Essas
são listadas sob vários títulos, cujo significado é como segue:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Required</emphasis> means that the target package cannot be
correctly built without the dependency having first been installed.</para>
      </listitem>
      <listitem>
        <para><emphasis>Recommended</emphasis> means that BLFS strongly suggests this
package is installed first for a clean and trouble-free build, that won't
have issues either during the build process, or at run-time.  The
instructions in the book assume these packages are installed.  Some changes
or workarounds may be required if these packages are not installed.</para>
      </listitem>
      <listitem>
        <para><emphasis>Opcional</emphasis> significa que esse pacote poderia estar
instalado para funcionalidade adicionada. Frequentemente o BLFS descreverá a
dependência para explicar a funcionalidade adicionada que resultará.</para>
      </listitem>
    </itemizedlist>

  </sect2>

  <sect2 id="package_updates">
    <title>Usando os Fontes Mais Atuais de Pacote</title>

    <para>Ocasionalmente você possivelmente se encontre em uma situação no livro onde
um pacote não construirá ou não funcionará adequadamente. Apesar dos(as)
Editores(as) tentarem garantir que cada pacote no livro construa e funcione
adequadamente, ocasionalmente um pacote tenha sido negligenciado ou não foi
testado com esta versão particular do BLFS.</para>

    <para>Se você descobrir que um pacote não construirá ou não funcionará
adequadamente, [então] você deveria ver se existe uma versão mais recente do
pacote. Tipicamente isso significa você ir ao sítio da web do(a)
mantenedor(a) e transferir o tarball mais recente e tentar construir o
pacote. Se você não conseguir determinar o sítio da web do(a) mantenedor(a)
olhando para os URLs de transferência, [então] use o Google e consulte o
nome do pacote. Por exemplo, na barra de pesquisa do Google, digite:
'nome_do_pacote download' (omita as aspas) ou algo
semelhante. Ocasionalmente, digitar: 'nome_do_pacote home page' resultará em
você encontrar o sítio da web do(a) mantenedor(a).</para>

  </sect2>

  <sect2 id="stripping">
    <title>Despojando Mais Uma Vez</title>

    <para>
      In LFS, stripping of debugging symbols and unneeded symbol table entries was
discussed a couple of times.  When building BLFS packages, there are
generally no special instructions that discuss stripping again. Stripping
can be done while installing a package, or afterwards.
    </para>

    <bridgehead renderas="sect3" id="stripping-install">Stripping while Installing a Package</bridgehead>

    <para>
      There are several ways to strip executables installed by a package. They
depend on the build system used (see below <link linkend="buildsystems">the
section about build systems</link>), so only some generalities can be listed
here:
    </para>

    <note>
      <para>
        The following methods using the feature of a building system (autotools,
meson, or cmake) will not strip static libraries if any is installed.
Fortunately there are not too many static libraries in BLFS, and a static
library can always be stripped safely by running <command>strip
--strip-unneeded</command> on it manually.
      </para>
    </note>

    <itemizedlist>
      <listitem>
        <para>
          The packages using autotools usually have an
<parameter>install-strip</parameter> target in their generated
<filename>Makefile</filename> files. So installing stripped executables is
just a matter of using <command>make install-strip</command> instead of
<command>make install</command>.
        </para>
      </listitem>
      <listitem>
        <para>
          The packages using the meson build system can accept
<parameter>-Dstrip=true</parameter> when running <command>meson</command>.
If you've forgot to add this option running the <command>meson</command>,
you can also run <command>meson install --strip</command> instead of
<command>ninja install</command>.
        </para>
      </listitem>
      <listitem>
        <para>
          <command>cmake</command> generates <parameter>install/strip</parameter>
targets for both the <parameter>Unix Makefiles</parameter> and
<parameter>Ninja</parameter> generators (the default is <parameter>Unix
Makefiles</parameter> on linux). So just run <command>make
install/strip</command> or <command>ninja install/strip</command> instead of
the <command>install</command> counterparts.
        </para>
      </listitem>
      <listitem>
        <para>
          Removing (or not generating) debug symbols can also be achieved by removing
the <parameter>-g&lt;something&gt;</parameter> options in C/C++ calls. How
to do that is very specific for each package.  And, it does not remove
unneeded symbol table entries.  So it will not be explained in detail
here. See also below the paragraphs about optimization.
        </para>
      </listitem>
    </itemizedlist>

    <bridgehead renderas="sect3" id="stripping-installed">Stripping Installed Executables</bridgehead>

    <para>
      The <command>strip</command> utility changes files in place, which may break
anything using it if it is loaded in memory. Note that if a file is in use
but just removed from the disk (i.e. not overwritten nor modified), this is
not a problem since the kernel can use <quote>deleted</quote> files.  Look
at <filename>/proc/*/maps</filename> and it is likely that you'll see some
<emphasis>(deleted)</emphasis> entries. The <command>mv</command> just
removes the destination file from the directory but does not touch its
content, so that it satisfies the condition for the kernel to use the old
(deleted) file. The script below is just an example.  It should be run as
the &root; user:
    </para>

<screen><userinput>cat &gt; /usr/sbin/strip-all.sh &lt;&lt; "EOF"
<literal>#!/usr/bin/bash

if [ $EUID -ne 0 ]; then
  echo "Need to be root"
  exit 1
fi

{ find /usr/lib -type f -name '*.so*' ! -name '*dbg'
  find /usr/lib -type f -name '*.a'
  find /usr/{bin,sbin,libexec} -type f
} |  while read file; do
       if ! readelf -h $file >/dev/null 2>&amp;1; then continue; fi
       if file $file | grep --quiet --invert-match 'not stripped'; then continue; fi

       cp --preserve $file    ${file}.tmp
       strip --strip-unneeded ${file}.tmp
       mv ${file}.tmp $file
     done</literal>
EOF
chmod 744 /usr/sbin/strip-all.sh</userinput></screen>

    <para>
      If you install programs in other directories such as <filename
class="directory">/opt</filename> or <filename
class="directory">/usr/local</filename>, you may want to strip the files
there too. Just add other directories to scan in the compound list of
<command>find</command> commands between the braces.
    </para>

    <para>
      For more information on stripping, see <ulink
url="https://www.technovelty.org/linux/stripping-shared-libraries.html"/>.
    </para>

  </sect2>


  <!--
  <sect2 id="libtool">

    <title>Libtool files</title>

    <para>
      One of the side effects of packages that use Autotools, including
      libtool, is that they create many files with an .la extension.  These
      files are not needed in an LFS environment.  If there are conflicts with
      pkgconfig entries, they can actually prevent successful builds.  You
      may want to consider removing these files periodically:
    </para>

<screen><userinput>find /lib /usr/lib -not -path "*Image*" -a -name \*.la -delete</userinput></screen>

    <para>
      The above command removes all .la files with the exception of those that
      have <quote>Image</quote> or <quote>openldap</quote> as a part of the
      path.  These .la files are used by the ImageMagick and openldap programs,
      respectively.  There may be other exceptions by packages not in BLFS.
    </para>

  </sect2>
-->
<sect2 id="buildsystems">
    <title>Trabalhando com diferentes sistemas de construção</title>

    <para>
      There are now three different build systems in common use for converting C
or C++ source code into compiled programs or libraries and their details
(particularly, finding out about available options and their default values)
differ. It may be easiest to understand the issues caused by some choices
(typically slow execution or unexpected use of, or omission of,
optimizatons) by starting with the CFLAGS and CXXFLAGS environment
variables.  There are also some programs which use rust.
    </para>

    <para>
      Most LFS and BLFS builders are probably aware of the basics of CFLAGS and
CXXFLAGS for altering how a program is compiled. Typically, some form of
optimization is used by upstream developers (-O2 or -O3), sometimes with the
creation of debug symbols (-g), as defaults.
    </para>

    <para>
      If there are contradictory flags (e.g. multiple different -O values), the
<emphasis>last</emphasis> value will be used. Sometimes this means that
flags specified in environment variables will be picked up before values
hardcoded in the Makefile, and therefore ignored.  For example, where a user
specifies '-O2' and that is followed by '-O3' the build will use '-O3'.
    </para>

    <para>
      There are various other things which can be passed in CFLAGS or CXXFLAGS,
such as forcing compilation for a specific microarchitecture
(e.g. -march=amdfam10, -march=native) or specifying a specific standard for
C or C++ (-std=c++17 for example). But one thing which has now come to light
is that programmers might include debug assertions in their code, expecting
them to be disabled in releases by using -DNDEBUG.  Specifically, if <xref
linkend="mesa"/> is built with these assertions enabled, some activities
such as loading levels of games can take extremely long times, even on
high-class video cards.
    </para>

    <bridgehead renderas="sect3" id="autotools-info">Autotools com Make</bridgehead>

      <para>
       This combination is often described as 'CMMI' (configure, make, make
install) and is used here to also cover the few packages which have a
configure script that is not generated by autotools.
      </para>

      <para>
        Ocasionalmente, executar-se <command>./configure --help</command> produzirá
opções úteis acerca de chaves que poderiam ser usadas. Em outras ocasiões,
depois de olhar para a saída gerada a partir do configure, você
possivelmente precise olhar para os detalhes do script para descobrir pelo
que ele estava procurando atualmente.
      </para>

      <para>
       Muitos scripts de configuração escolherão quaisquer CFLAGS ou CXXFLAGS a
partir do ambiente, porém os pacotes CMMI variam acerca do como esses serão
misturados com quaisquer sinalizadores que, de outra maneira, seriam usados
(<emphasis>variadamente</emphasis>: ignorados; usados para substituir a
sugestão do(a) programador(a); usados antes da sugestão do(a)
programador(a); ou usados depois da sugestão do(a) programador(a)).
      </para>

      <para>
       In most CMMI packages, running 'make' will list each command and run it,
interspersed with any warnings. But some packages try to be 'silent' and
only show which file they are compiling or linking instead of showing the
command line. If you need to inspect the command, either because of an
error, or just to see what options and flags are being used, adding 'V=1' to
the make invocation may help.
     </para>

    <bridgehead renderas="sect3" id="cmake-info">CMake</bridgehead>

      <para>
        CMake works in a very different way, and it has two backends which can be
used on BLFS: 'make' and 'ninja'. The default backend is make, but ninja can
be faster on large packages with multiple processors. To use ninja, specify
'-G Ninja' in the cmake command. However, there are some packages which
create fatal errors in their ninja files but build successfully using the
default of Unix Makefiles.
      </para>

      <para>
        A parte mais difícil do usar-se o CMake é saber quais opções você poderia
desejar especificar. A única maneira de se obter uma lista do que o pacote
conhece é a de executar <command>cmake -LAH</command> e olhar para a saída
gerada para esta configuração padrão.
      </para>

      <para>
        Perhaps the most-important thing about CMake is that it has a variety of
CMAKE_BUILD_TYPE values, and these affect the flags. The default is that
this is not set and no flags are generated. Any CFLAGS or CXXFLAGS in the
environment will be used. If the programmer has coded any debug assertions,
those will be enabled unless -DNDEBUG is used.  The following
CMAKE_BUILD_TYPE values will generate the flags shown, and these will come
<emphasis>after</emphasis> any flags in the environment and therefore take
precedence.
      </para>

      <informaltable align="center">
        <tgroup cols="2">
          <colspec colnum="1" align="center"/>
          <colspec colnum="2" align="center"/>
          <thead>
            <row><entry>Value</entry><entry>Flags</entry></row>
          </thead>
          <tbody>
            <row>
              <entry>Debug</entry><entry><option>-g</option></entry>
            </row>
            <row>
              <entry>Release</entry><entry><option>-O3 -DNDEBUG</option></entry>
            </row>
            <row>
              <entry>RelWithDebInfo</entry><entry><option>-O2 -g -DNDEBUG</option></entry>
            </row>
            <row>
              <entry>MinSizeRel</entry><entry><option>-Os -DNDEBUG</option></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>
        CMake tries to produce quiet builds. To see the details of the commands
which are being run, use <command>make VERBOSE=1</command> or <command>ninja
-v</command>.
      </para>

      <para>
        By default, CMake treats file installation differently from the other build
systems: if a file already exists and is not newer than a file that would
overwrite it, then the file is not installed. This may be a problem if a
user wants to record which file belongs to a package, either using
<envar>LD_PRELOAD</envar>, or by listing files newer than a timestamp. The
default can be changed by setting the variable
<envar>CMAKE_INSTALL_ALWAYS</envar> to 1 in the
<emphasis>environment</emphasis>, for example by
<command>export</command>'ing it.
      </para>

    <bridgehead renderas="sect3" id="meson-info">Meson</bridgehead>

      <para>
        O Meson tem algumas semelhanças com o CMake, porém muitas diferenças. Para
obter os detalhes das definições que você possivelmente queira mudar, você
pode olhar para o <filename>meson_options.txt</filename> que normalmente
está no diretório de nível de topo.
      </para>

      <para>
        Se você já configurou o pacote executando o <command>meson</command> e,
agora, deseja mudar uma ou mais configurações, [então] você ou pode remover
o diretório de construção, recriá-lo e usar as opções alteradas; ou, dentro
do diretório de construção, executar <command>meson configure</command>, por
exemplo, para configurar uma opção:
      </para>

<screen><userinput>meson configure -D&lt;alguma_opção&gt;=true</userinput></screen>

      <para>
        Se você fizer isso, [então] o arquivo
<filename>meson-private/cmd_line.txt</filename> mostrará os
<emphasis>últimos</emphasis> comandos que foram usados.
      </para>

      <para>
        O Meson fornece os seguintes valores de tipo de construção e os
sinalizadores que eles habilitam vem <emphasis>depois</emphasis> de
quaisquer sinalizadores fornecidos no ambiente e, portanto, tem precedência.
      </para>

      <itemizedlist>
        <listitem>
          <para>plain : no added flags. This is for distributors to supply their own CLFAGS,
CXXFLAGS and LDFLAGS. There is no obvious reason to use this in BLFS.</para>
        </listitem>
        <listitem>
          <para>debug : '-g' - this is the default if nothing is specified in either
<filename>meson.build</filename> or the command line.  However it results
large and slow binaries, so we should override it in BLFS.</para>
        </listitem>
        <listitem>
           <para>debugoptimized : '-O2 -g' : this is the default specified in
<filename>meson.build</filename> of some packages.</para>
        </listitem>
        <listitem>
           <para>lançamento : '-O3 -DNDEBUG' (porém, ocasionalmente, um pacote forçará -O2
aqui)</para>
        </listitem>
      </itemizedlist>

      <para>
        Apesar do tipo de construção 'lançamento' estar descrito como habilitante do
-DNDEBUG e todas as construções CMake Release passarem isso, tem, até agora,
somente sido observado (em construções verbosas) para o <xref
linkend="mesa"/>. Isso sugere que somente poderia ser usado quando existirem
asserções de depuração presentes.
      </para>

      <para>
        O sinalizador -DNDEBUG também pode ser fornecido passando-se
<command>-Db_ndebug=true</command>.
      </para>

      <para>
        To see the details of the commands which are being run in a package using
meson, use 'ninja -v'.
      </para>

    <bridgehead renderas="sect3" id="rust-info">Rustc e Cargo</bridgehead>

      <para>
        Most released rustc programs are provided as crates (source tarballs)  which
will query a server to check current versions of dependencies and then
download them as necessary.  These packages are built using <command>cargo
--release</command>. In theory, you can manipulate the RUSTFLAGS to change
the optimize-level (default is 3, like -O3, e.g.
<literal>-Copt-level=3</literal>) or to force it to build for the machine it
is being compiled on, using <literal>-Ctarget-cpu=native</literal> but in
practice this seems to make no significant difference.
      </para>

      <para>
        Se você encontrar um aplicativo rustc interessante que seja fornecido apenas
como fonte desempacotado, [então] você deveria, pelo menos, especificar
<literal>RUSTFLAGS=-Copt-level=2</literal>; do contrário, fará uma
compilação não otimizada, com informação de depuração e executará
<emphasis>muito</emphasis> mais lento.
      </para>

      <para>
        The rust developers seem to assume that everyone will compile on a machine
dedicated to producing builds, so by default all CPUs are used.  This can
often be worked around, either by exporting CARGO_BUILD_JOBS=&lt;N&gt; or
passing --jobs &lt;N&gt; to cargo. For compiling rustc itself, specifying
--jobs &lt;N&gt; on invocations of x.py (together with the
<envar>CARGO_BUILD_JOBS</envar> environment variable, which looks like a
"belt and braces" approach but seems to be necessary) mostly works. The
exception is running the tests when building rustc, some of them will
nevertheless use all online CPUs, at least as of rustc-1.42.0.
      </para>

  </sect2>

  <sect2 id="optimizations">
    <title>Otimizando a construção</title>

      <para>
        Many people will prefer to optimize compiles as they see fit, by providing
CFLAGS or CXXFLAGS. For an introduction to the options available with gcc
and g++ see <ulink
url="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html"/> and <ulink
url="https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html"/> and
<command>info gcc</command>.

      </para>

      <para>
        Some packages default to '-O2 -g', others to '-O3 -g', and if CFLAGS or
CXXFLAGS are supplied they might be added to the package's defaults, replace
the package's defaults, or even be ignored.  There are details on some
desktop packages which were mostly current in April 2019 at <ulink
url="https://www.linuxfromscratch.org/~ken/tuning/"/> - in particular,
README.txt, tuning-1-packages-and-notes.txt, and tuning-notes-2B.txt. The
particular thing to remember is that if you want to try some of the more
interesting flags you may need to force verbose builds to confirm what is
being used.
      </para>

      <para>
        Clearly, if you are optimizing your own program you can spend time to
profile it and perhaps recode some of it if it is too slow. But for building
a whole system that approach is impractical. In general, -O3 usually
produces faster programs than -O2.  Specifying -march=native is also
beneficial, but means that you cannot move the binaries to an incompatible
machine - this can also apply to newer machines, not just to older
machines. For example programs compiled for 'amdfam10' run on old Phenoms,
Kaveris, and Ryzens : but programs compiled for a Kaveri will not run on a
Ryzen because certain op-codes are not present.  Similarly, if you build for
a Haswell not everything will run on a SandyBridge.
      </para>

      <para>
        Existem também várias outras opções que algumas pessoas alegam que são
benéficas. Na pior das hipóteses, você consegue recompilar e testar e,
então, descobrir que, em seu uso, as opções não fornecem um benefício.
      </para>

      <para>
        If building Perl or Python modules, or Qt packages which use qmake, in
general the CFLAGS and CXXFLAGS used are those which were used by those
'parent' packages.
      </para>

  </sect2>

  <sect2 id="hardening">
    <title>Opções para fortalecer a construção</title>

      <para>
        Mesmo em sistemas de área de trabalho, existe ainda um monte de
vulnerabilidades exploráveis. Para muitas dessas, o ataque vem via
javascript em um navegador. Frequentemente, uma série de vulnerabilidades é
usada para ganhar acesso a dados (ou, às vezes, para pwn, isto é, dominar, a
máquina e instalar rootkits). A maioria das distribuições comerciais
aplicará várias medidas de fortalecimento.
      </para>

      <para>
        In the past, there was Hardened LFS where gcc (a much older version)  was
forced to use hardening (with options to turn some of it off on a
per-package basis).  The current LFS and BLFS books are carrying forward a
part of its spirit by enabling PIE (<option>-fPIE -pie</option>) and SSP
(<option>-fstack-protector-strong</option>) as the defaults for GCC and
clang.  What is being covered here is different - first you have to make
sure that the package is indeed using your added flags and not over-riding
them.
      </para>

      <para>
        For hardening options which are reasonably cheap, there is some discussion
in the 'tuning' link above (occasionally, one or more of these options might
be inappropriate for a package). These options are
<option>-D_FORTIFY_SOURCE=2</option> and (for C++)
<option>-D_GLIBCXX_ASSERTIONS</option>. On modern machines these should only
have a little impact on how fast things run, and often they will not be
noticeable.
      </para>

      <para>
        The main distros use much more, such as RELRO (Relocation Read Only)  and
perhaps <option>-fstack-clash-protection</option>. You may also encounter
the so-called <quote>userspace retpoline</quote>
(<option>-mindirect-branch=thunk</option> etc.) which is the equivalent of
the spectre mitigations applied to the linux kernel in late 2018. The kernel
mitigations caused a lot of complaints about lost performance, if you have a
production server you might wish to consider testing that, along with the
other available options, to see if performance is still sufficient.
      </para>

      <para>
        Embora o gcc tenha muitas opções de fortalecimento, os pontos fortes do
clang/LLVM estão em outro lugar. Algumas opções que o gcc fornece são ditas
serem menos efetivas no clang/LLVM.
      </para>

  </sect2>

</sect1>
